<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kotazi.com</title>
    <link>http://kotazi.github.io/blog/</link>
    <description>Recent content on kotazi.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Feb 2016 11:40:44 +0900</lastBuildDate>
    <atom:link href="http://kotazi.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>【読書】インターネットの基礎　〜デジタル時代の知識創造ー〜</title>
      <link>http://kotazi.github.io/blog/post/2016/0229_internet/</link>
      <pubDate>Mon, 29 Feb 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0229_internet/</guid>
      <description>

&lt;p&gt;14冊目。&lt;/p&gt;

&lt;p&gt;&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/404653883X/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=404653883X&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;角川インターネット講座 (3) デジタル時代の知識創造 変容する著作権&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=404653883X&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;を読みました。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次-http-kci-salon-jp-books-03:01b0d2df845d71ef3a201cb60330d856&#34;&gt;&lt;a href=&#34;http://kci-salon.jp/books/03/&#34;&gt;目次&lt;/a&gt;&lt;/h3&gt;

&lt;h5 id=&#34;第1部-知の共有と著作者の権利:01b0d2df845d71ef3a201cb60330d856&#34;&gt;◯ 第1部 知の共有と著作者の権利&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;序章　知識・情報の活用と著作権   　…長尾 真 著&lt;/li&gt;
&lt;li&gt;第1章　インターネット時代の著作権制度   　…中山 信弘 著&lt;/li&gt;
&lt;li&gt;第2章　万人が著作者の時代 米国の議論から    　…名和 小太郎 著&lt;/li&gt;
&lt;li&gt;第3章　デジタルアーカイブのオープン化と著作権の新時代   　…岡本 真 著&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;第2部-出版と知識創造の未来:01b0d2df845d71ef3a201cb60330d856&#34;&gt;◯ 第2部 出版と知識創造の未来&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;第4章　電子書籍とは何か? 　…萩野 正昭 著&lt;/li&gt;
&lt;li&gt;第5章　情報共有時代の社会制度 グーグルとフェイスブックが投げかける問い 　…歌田 明弘 著&lt;/li&gt;
&lt;li&gt;第6章　ウェブと電子書籍は、作品と作者をどう変えたか  　…仲俣 暁生 著&lt;/li&gt;
&lt;li&gt;第7章　デジタルアーカイブとは何か  　…杉本 重雄 著&lt;/li&gt;
&lt;li&gt;第8章　メタ複製技術時代の〈世界脳〉書物へのオマージュと電子化された〈知〉    　…遠藤 薫 著&lt;/li&gt;
&lt;li&gt;第9章　デジタルの衝撃と文化のサスティナビリティ   　…吉見 俊哉 著&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;これを読むまでしっかりとインターネットにおける著作権問題についてしっかりと考えたことがなかった。
そもそも著作権が生まれた経緯についてしっかりと書かれているため、
なぜ著作権問題が生まれてくるのか、なぜ当時の法が適用できなくなってしまっているのかということについて感じ取ることができた。&lt;/p&gt;

&lt;p&gt;世界中の本が誰にでも読めるようになるためにはまだまだ課題がありそう。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】ピープルウエア</title>
      <link>http://kotazi.github.io/blog/post/2016/0228_peopelwear/</link>
      <pubDate>Sun, 28 Feb 2016 22:33:30 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0228_peopelwear/</guid>
      <description>

&lt;p&gt;13冊目。
アメリカのソフトウェア工学者トム・デマルコの著書、&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/B00I96CJWO/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00I96CJWO&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;ピープルウエア　第3版&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=B00I96CJWO&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;
を読みました。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;strong&gt;実際のところ、ソフトウェア開発上の問題の多くは、技術的というより社会学的なものである。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;というとても有名な文章が登場する本書。
ソフトウェア開発においてありがちな人間関係のトラブルとそれらに対する有用な対処が紹介される。&lt;/p&gt;

&lt;p&gt;目次は下記である。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第1部: 人材を活用する&lt;/li&gt;
&lt;li&gt;第2部: オフィス環境と生産性&lt;/li&gt;
&lt;li&gt;第3部: 人材を揃える&lt;/li&gt;
&lt;li&gt;第4部: 生産性の高いチームを育てる&lt;/li&gt;
&lt;li&gt;第5部: 肥沃な土壌&lt;/li&gt;
&lt;li&gt;第6部: きっとそこは楽しいところ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本テーマの出発点は失敗したプロジェクトの調査にあった。
調査した失敗プロジェクトの圧倒的多数は、
原因が単なる技術的問題として片付けられないものばかりだった。
ということから始められる。&lt;/p&gt;

&lt;p&gt;プロジェクトの成功は関係者の緊密な対人関係によって生まれ、
失敗は疎遠な対人関係の結果である。&lt;/p&gt;

&lt;h5 id=&#34;品質第一主義からの頭皮:b53d3c79502dfc895a23efe945a89b7a&#34;&gt;◯ 品質第一主義からの頭皮&lt;/h5&gt;

&lt;p&gt;ユーザーの品質意識は実は低い。
少なくとも開発者に比べると、必要とする製品品質のレベルが低いということだ。&lt;/p&gt;

&lt;p&gt;開発者ではなく、買い手に品質基準を決めさせることを「&lt;strong&gt;品質第一主義からの逃避&lt;/strong&gt;」という。
顧客の要求通りの品質を提供することは一見最もらしく見えるが、
長い目で見ると市場に品質を合わせるとコストが増える。&lt;/p&gt;

&lt;p&gt;言い換えるならば、
&lt;strong&gt;エンドユーザーの要求を遥かに超えた品質水準は、生産性を上げるひとつの手段である。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;価格と品質はトレードオフであるという考えは、日本には存在しない。反対に、高品質がコスト低減をもたらすという考えが広く受け入れられている。&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&#34;ラエトライルの話:b53d3c79502dfc895a23efe945a89b7a&#34;&gt;◯ ラエトライルの話&lt;/h5&gt;

&lt;p&gt;ラエトライルとは、杏の種の中のある部分から搾り取れる液体。
スウェーデンではアーモンドエキスと同じぐらいの値段で買えるが、
メキシコでは末期癌の治療薬として一滴50ドルで売られている。
絶望の淵にある人には、証拠などどうでもよくすがってしまうとうこと。&lt;/p&gt;

&lt;p&gt;プロジェクト開発においても同じようなことが見られる。
多くのマネージャーが生産性があがると聞くと、証拠もなしに飛びついてしまう。&lt;/p&gt;

&lt;p&gt;安易な解決方法では手に負えない。
よい実績は、効果的な人の使い方、作業場所や企業文化の改善などから生まれる。
けれども企業文化の改善は難しく、短期的には効果が上がりにくいため、
生産性向上ツールなどに手を伸ばしたくなってしまう。&lt;/p&gt;

&lt;h5 id=&#34;生産性の高いチームを育てる:b53d3c79502dfc895a23efe945a89b7a&#34;&gt;◯ 生産性の高いチームを育てる&lt;/h5&gt;

&lt;p&gt;挑戦はチームメンバーに&lt;strong&gt;一緒になって努力する&lt;/strong&gt;目標を与えるからこそ重要。
挑戦とはチームをひとつにまとめるための道具である。&lt;/p&gt;

&lt;p&gt;チームの結束の可能性を高めるように行動することもできるが、
現実に結束させることはできない。チーム結束の過程はコントロールしようとすると壊れてしまう。&lt;/p&gt;

&lt;p&gt;チームの構築とは言わずに、チームの育成と言うこと。&lt;/p&gt;

&lt;h5 id=&#34;健全な会社にするための化学反応を生み出す要素:b53d3c79502dfc895a23efe945a89b7a&#34;&gt;◯ 健全な会社にするための化学反応を生み出す要素&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;品質至上主義を作り出す&lt;/li&gt;
&lt;li&gt;満足感を与える打ち上げをたくさん用意する&lt;/li&gt;
&lt;li&gt;エリート感覚を醸成する&lt;/li&gt;
&lt;li&gt;チームに異分子を混ぜることを奨励する&lt;/li&gt;
&lt;li&gt;成功しているチームを守り、維持する&lt;/li&gt;
&lt;li&gt;戦術ではなく戦略を与える&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いい加減な製品を納入することからは、仲間とともに味合う満足感によって、
チームを一体化させる力は生まれない。
逆に、「完全な製品だけを求める」態度を取れば、
チームが一つにまとまる可能性が高くなる。この品質至上主義が、
チーム形成にとって最も強力な触媒である。&lt;/p&gt;

&lt;h5 id=&#34;メソドロジー:b53d3c79502dfc895a23efe945a89b7a&#34;&gt;◯ メソドロジー&lt;/h5&gt;

&lt;p&gt;メソドロジーとは、あらゆる頭脳集約型作業をどのように進めるかについての一般的なシステム理論。
大抵の組織では、業務の質が職員の質を超えることができない。
平凡であまり能力のない人々でも、優れた組織を作るための方法論。&lt;/p&gt;

&lt;p&gt;すべての決定を下すのはメソドロジーであり、人間は何も判断しない。
組織は完全に決定論的になる。&lt;/p&gt;

&lt;p&gt;=&amp;gt; ある意味全てをマニュアル化するなど。臨機応変な対応がとれなかったりして一長一短。&lt;/p&gt;

&lt;h5 id=&#34;ホーソン効果:b53d3c79502dfc895a23efe945a89b7a&#34;&gt;◯ ホーソン効果&lt;/h5&gt;

&lt;p&gt;人は、他と違った扱いを受けることに魅力を感じ、注目されることを好み、珍しい物に好奇心をよせる。
これをホーソン効果という。&lt;/p&gt;

&lt;h5 id=&#34;君主論:b53d3c79502dfc895a23efe945a89b7a&#34;&gt;◯ 君主論&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;自分が先頭に立って新たな秩序を導入することほど、扱うのが困難で、成功が疑わしく、管理するのが危険なものはない、
ということをよく考えるべきだ。導入する人々にとって、古い秩序から恩恵を受けた人は全て敵であり、新たな秩序から恩恵を受ける人からは、
気のない支援しか受けられない。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;アリストテレスの哲学を構成する5つの学問:b53d3c79502dfc895a23efe945a89b7a&#34;&gt;◯ アリストテレスの哲学を構成する5つの学問&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;形而上学&lt;/li&gt;
&lt;li&gt;論理学&lt;/li&gt;
&lt;li&gt;倫理学&lt;/li&gt;
&lt;li&gt;政治学&lt;/li&gt;
&lt;li&gt;美学&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;少し各項目が抽象的すぎたような感じもするが書かれている項目は的を得ていた。
とくに現場経験のあまりない人間が読むにはちょうどよい感じがした。&lt;/p&gt;

&lt;p&gt;表紙から受けたイメージよりはかなり入門的な本。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【Rails】whenever導入を通した学び</title>
      <link>http://kotazi.github.io/blog/post/2016/0227_whenever/</link>
      <pubDate>Sat, 27 Feb 2016 20:18:53 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0227_whenever/</guid>
      <description>

&lt;p&gt;Railsのwheneverを使う機会があったのでその学びをまとめる。
やりたかっとことはRakeタスクを作成し、wheneverを使って定期的にSlackへポストする。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&#34;slack通知:8316899f0dd43c4b70b3dee52ffee325&#34;&gt;Slack通知&lt;/h2&gt;

&lt;p&gt;Slackへの通知はすごく簡単。&lt;br /&gt;
ここにだいたい書いてある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/ysk_1031/items/f74c8b8274ec6c58520d&#34;&gt;RailsアプリからSlackに通知&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とりあえず、&lt;code&gt;config/intializers/slack_api.rb&lt;/code&gt;を作成してtokenを登録しておけば、いろいろできるみたい。&lt;/p&gt;

&lt;h2 id=&#34;rakeタスクの作成:8316899f0dd43c4b70b3dee52ffee325&#34;&gt;rakeタスクの作成&lt;/h2&gt;

&lt;p&gt;初めてrakeタスクを作成した。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ruby-lang.org/ja/2.2.0/library/rake.html&#34;&gt;library rake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ rake &amp;lt;タスク名&amp;gt; # 指定のタスクを実行。
$ rake &amp;lt;パラメータキー&amp;gt;=&amp;lt;値&amp;gt; &amp;lt;タスク名&amp;gt; # パラメータ指定ありで、指定のタスクを実行。
$ rake -h # 使い方を表示。
$ rake -T # 定義されているタスク一覧を表示
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(引用:&lt;a href=&#34;http://unageanu.hatenablog.com/entry/20100829/1283069269&#34;&gt;Rakeの基本的な使い方まとめ|うなの日記&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;whenever:8316899f0dd43c4b70b3dee52ffee325&#34;&gt;whenever&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/javan/whenever&#34;&gt;javan/whenever|github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://morizyun.github.io/blog/whenever-gem-rails-ruby-capistrano/&#34;&gt;Wheneverは導入が超簡単なcrontab管理ライブラリGemです！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mixpanel:8316899f0dd43c4b70b3dee52ffee325&#34;&gt;mixpanel&lt;/h2&gt;

&lt;p&gt;mixpanelのデータのエクスポートしたい。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mixpanel.com/docs/api-documentation/data-export-api&#34;&gt;Data Export API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kitak.hatenablog.jp/entry/2014/10/07/231003&#34;&gt;Rubyでmixpanelのイベントをtrackしたり、データをexportする術&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>【読書】インターネットの基礎　〜情報革命を支えるインフラストラクチャー〜</title>
      <link>http://kotazi.github.io/blog/post/2016/0224_internet/</link>
      <pubDate>Wed, 24 Feb 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0224_internet/</guid>
      <description>

&lt;p&gt;2016年12冊目。&lt;/p&gt;

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/B00PRPWMXG/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00PRPWMXG&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;角川インターネット講座２　ネットを支えるオープンソース　ソフトウェアの進化&amp;lt;角川インターネット講座&amp;gt; (角川学芸出版全集)&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=B00PRPWMXG&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;を読みました。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次-http-kci-salon-jp-books-02:07728f0e849bb9a57f3960dfd474f609&#34;&gt;&lt;a href=&#34;http://kci-salon.jp/books/02/&#34;&gt;目次&lt;/a&gt;&lt;/h3&gt;

&lt;h5 id=&#34;第1部-プログラミングがすべてをつくった:07728f0e849bb9a57f3960dfd474f609&#34;&gt;◯ 第1部 プログラミングがすべてをつくった&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;序章　インターネットはソフトウェアでできている   　…まつもと ゆきひろ 著&lt;/li&gt;
&lt;li&gt;第1章　インターネットを支えるソフトウェアを知る  　…法林 浩之 著&lt;/li&gt;
&lt;li&gt;第2章　プログラミングとは何か   　…久野 靖 著&lt;/li&gt;
&lt;li&gt;第3章　プログラミングと教育    　…阿部 和広 著&lt;/li&gt;
&lt;li&gt;第4章　ハッカー精神とは何か    　&lt;/li&gt;
&lt;li&gt;プログラマーに求められる素養と思考方法   　…吉岡 弘隆 著&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;第2部-オープンソースが高めたネットの価値:07728f0e849bb9a57f3960dfd474f609&#34;&gt;◯ 第2部 オープンソースが高めたネットの価値&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;第5章　ライセンスというプロトコル OSSエコシステムを繋ぐ仕組み 　…やまね ひでき 著&lt;/li&gt;
&lt;li&gt;第6章　オープンソース化が生んだ変化    　…瀧田 佐登子 著&lt;/li&gt;
&lt;li&gt;第7章　企業とオープンソース    　…鵜飼 文敏 著&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;第2回はプログラミングとオープンソースについて。
各種ライセンスについて触れられていてとても勉強になりました。
今後は自分のプロジェクトでもライセンスを付加して利用者のリスクを可視化するよう心掛けようと思った。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】インターネットの基礎　〜情報革命を支えるインフラストラクチャー〜</title>
      <link>http://kotazi.github.io/blog/post/2016/0218_internet/</link>
      <pubDate>Thu, 18 Feb 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0218_internet/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4046538813/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4046538813&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;角川インターネット講座 (1) インターネットの基礎情報革命を支えるインフラストラクチャー&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4046538813&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;
を読みました。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次-http-kci-salon-jp-books-01:2a8efb0e9ce9ce1d09880ed3ba0fd408&#34;&gt;&lt;a href=&#34;http://kci-salon.jp/books/01/&#34;&gt;目次&lt;/a&gt;&lt;/h3&gt;

&lt;h5 id=&#34;はしがき:2a8efb0e9ce9ce1d09880ed3ba0fd408&#34;&gt;◯ はしがき&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;インターネット前提社会の出発によせて&amp;hellip;村井 純 著&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;第1部-インターネットの理念:2a8efb0e9ce9ce1d09880ed3ba0fd408&#34;&gt;◯ 第1部 インターネットの理念&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;序章　フロンティアの流儀&amp;hellip;村井 純 著&lt;/li&gt;
&lt;li&gt;第1章　技術の誕生と成長&amp;hellip;村井 純 著&lt;/li&gt;
&lt;li&gt;第2章　インターネットの仕組み&amp;hellip;村井 純 著&lt;/li&gt;
&lt;li&gt;第3章　変貌するインターネット&amp;hellip;村井 純 著&lt;/li&gt;
&lt;li&gt;第4章　インターネットを誰がどのように運用するのか&amp;hellip;村井 純 著&lt;/li&gt;
&lt;li&gt;技術解説　インターネットプロコトル&amp;hellip;砂原 秀樹 著&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;第2部-tcp-ip発明者からの-宿題:2a8efb0e9ce9ce1d09880ed3ba0fd408&#34;&gt;◯ 第2部 TCP/IP発明者からの「宿題」&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;インターネットの再発明 Reinventing the Internet&amp;hellip;ヴィントン・グレイ・サーフ&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;日本のインターネットの父とも呼ばれる村井純氏によって、インターネットの歴史や仕組みが語られる。&lt;/p&gt;

&lt;p&gt;現代のインターネットの成り立ちまでの経緯が当事者でしか知らないであろう言葉によって語られ、
難しいと思っていたインターネットの仕組みや全貌もとても分かりやすく解説されている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】ユーザーストーリーマッピング</title>
      <link>http://kotazi.github.io/blog/post/2016/0213_user_story/</link>
      <pubDate>Wed, 17 Feb 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0213_user_story/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4873117321/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4873117321&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;ユーザーストーリーマッピング&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4873117321&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;
を読みました。&lt;/p&gt;

&lt;p&gt;アジャイルUXの第一人者として活躍するジェフ・パットン氏の著書。&lt;br /&gt;
自身が開発した手法について書き下ろされら書籍。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://codezine.jp/article/detail/6404&#34;&gt;良いプロダクトを発見・具現化するために、チームはどう動くべきか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://daipresents.com/2011/jeff-patton%E6%B0%8F%E3%81%AE-%E6%83%85%E7%86%B1%E3%83%97%E3%83%AD%E3%83%80%E3%82%AF%E3%83%88%E3%82%AA%E3%83%BC%E3%83%8A%E3%83%BC%E3%82%B7%E3%83%83%E3%83%97-%E3%81%AB%E5%8F%82%E5%8A%A0%E3%81%97/&#34;&gt;Jeff Patton氏の “情熱プロダクトオーナーシップ” に参加しました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次:2179e5f5f3ee66c47dc4d32c38e661c1&#34;&gt;目次&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;0章 まず最初に読んでください&lt;/li&gt;
&lt;li&gt;1章 全体像&lt;/li&gt;
&lt;li&gt;2章 作るものを減らすためのプラン&lt;/li&gt;
&lt;li&gt;3章 より速く学ぶためのプラン&lt;/li&gt;
&lt;li&gt;4章 時間どおりに終わらせるためのプラン&lt;/li&gt;
&lt;li&gt;5章 あなたはもうやり方を知っている&lt;/li&gt;
&lt;li&gt;6章 ストーリーについての本当のストーリー&lt;/li&gt;
&lt;li&gt;7章 より良いストーリーテリングのために&lt;/li&gt;
&lt;li&gt;8章 カードに書かれていることが全てではない&lt;/li&gt;
&lt;li&gt;9章 カードは始まりにすぎない&lt;/li&gt;
&lt;li&gt;10章 ケーキのようにストーリーを焼く&lt;/li&gt;
&lt;li&gt;11章 岩を砕いていく&lt;/li&gt;
&lt;li&gt;12章 岩を砕く人&lt;/li&gt;
&lt;li&gt;13章 オポチュニティから始める&lt;/li&gt;
&lt;li&gt;14章 ディスカバリーを介して共通理解を築く&lt;/li&gt;
&lt;li&gt;15章 ディスカバリーによる検証された学習&lt;/li&gt;
&lt;li&gt;16章 リファイン、定義、構築&lt;/li&gt;
&lt;li&gt;17章 ストーリーは実際にはアステロイドに似ている&lt;/li&gt;
&lt;li&gt;18章 構築するすべてのものから学ぶ&lt;/li&gt;
&lt;li&gt;19章 終わり？それとも&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;多くの企業がアジャイルやリーンプロセスを取り入れる一環としてストーリーを取り入れている。
しかしその取組の中で、全体像を見失ってしまったり、何が作られているのか分からなくなってしまったり、
共通理解が得られなかったり。そういったチーム開発における悩みをユーザーストーリーマッピングを用いて紐解いていく本。&lt;/p&gt;

&lt;p&gt;ただ、この本の序文を&lt;a href=&#34;http://www.amazon.co.jp/Inspired-%E9%A1%A7%E5%AE%A2%E3%81%AE%E5%BF%83%E3%82%92%E6%8D%89%E3%81%88%E3%82%8B%E8%A3%BD%E5%93%81%E3%81%AE%E5%89%B5%E3%82%8A%E6%96%B9-%E3%83%9E%E3%83%BC%E3%83%86%E3%82%A3-%E3%82%B1%E3%82%A4%E3%82%AC%E3%83%B3-ebook/dp/B00TCM8TB4&#34;&gt;Inspired&lt;/a&gt;の著者マーティケーガンが執筆しており、
&lt;a href=&#34;http://www.amazon.co.jp/HARD-THINGS-%E7%AD%94%E3%81%88%E3%81%8C%E3%81%AA%E3%81%84%E9%9B%A3%E5%95%8F%E3%81%A8%E5%9B%B0%E9%9B%A3%E3%81%AB%E3%81%8D%E3%81%BF%E3%81%AF%E3%81%A9%E3%81%86%E7%AB%8B%E3%81%A1%E5%90%91%E3%81%8B%E3%81%86%E3%81%8B-%E3%83%99%E3%83%B3-%E3%83%9B%E3%83%AD%E3%82%A6%E3%82%A3%E3%83%83%E3%83%84-ebook/dp/B00W535LOU&#34;&gt;HARD THINGS&lt;/a&gt;の著者ベン・ホロヴィッツの
&lt;a href=&#34;https://a16z.files.wordpress.com/2014/08/good-product-manager.pdf&#34;&gt;Good Product Manager/Bad Product Manager&lt;/a&gt;
に倣い、強力な製品開発チームと非力なチームの重要な違いを挙げている。&lt;br /&gt;
それが面白かったので引用したい。&lt;/p&gt;

&lt;p&gt;優れたチームには、使命感といえるほどの情熱を持って追求したくなる圧倒的な魅力のあるビジョンがある。
ダメなチームは報酬しか考えない。&lt;/p&gt;

&lt;p&gt;優れたチームは、リアルな問題を解決するためにスコアカードKPI，顧客の苦闘の状況、顧客が製品を使った時に生成されるデータを良く見て、絶えず新技術を応用するチャンスを探しながら、ヒントやアイディアを掴んでいる。ダメなチームは営業や顧客から要件を集めてくる。&lt;/p&gt;

&lt;p&gt;優れたチームは、もっとも大切なステークホルダーが誰か、そのステークホルダーがどのような制約を抱えているのかを理解し、
ユーザーと顧客のために役立つだけでなく、ビジネスの制約の枠内で作れるソリューションを作り出すことに力を注いでいる。
ダメなチームは、ステークホルダーから要件を集めてくる。&lt;/p&gt;

&lt;p&gt;優れたチームは、そのアイディアが本当に構築に値するのか見極めるために、アイディアをすぐに試せるテクニックを習熟している。
ダメなチームは、優先順位を指定したロードマップを作るために会議を開く。&lt;/p&gt;

&lt;p&gt;優れたチームは、社内各部署の優秀なリーダーを集めたブレーンストーミングを積極的に行う。ダメなチームは、チーム外の誰かが提案してくれても反発する。&lt;/p&gt;

&lt;p&gt;優れたチームは、製品担当、デザイン担当、技術担当が隣同士に座り、機能、ユーザーエクスペリエンス、実現するためのテクノロジーにおける助け合いを推進している。ダメなチームは、それぞれの部門の席に座り、部門の外からのサービスの以来には、文書による以来や会議の日程調整を要求する。&lt;/p&gt;

&lt;p&gt;優れたチームは、イノベーションのためにいつでも新しいアイディアを試そうとするが、収益とブランドはきっちり守る。
ダメなチームはテストの実行許可を待ち続ける。&lt;/p&gt;

&lt;p&gt;優れたチームは、力のあるインタラクションデザインなど、勝てる商品を作るために必要なスキルセットの確保にこだわる。
ダメなチームは、インタラクションデザインがどのような仕事かさえ知らない。&lt;/p&gt;

&lt;p&gt;優れたチームは、エンジニアが毎日ディスカバリープロトタイプを試す時間を持っている。製品をよくするための意見も言える。
ダメなチームは、急ぎの案件の時だけ、見積書を作るためにエンジニアにプロトタイプを見せる。&lt;/p&gt;

&lt;p&gt;優れたチームは、顧客をよりよく理解し、最新のアイディアに対する顧客の反応を見るために毎週、顧客と直接議論する。
ダメなチームは、自分がお客さんだと思っている。&lt;/p&gt;

&lt;p&gt;優れたチームは、自分たちが気に入ったアイディアの多くが顧客の役に立たないことを知っており、役に立つかもしれないものでも、
望ましい成果を挙げるまでには、数回のイテレーションが必要であることを知っている。
ダメなチームは、ロードマップに載ったものを作り、納期と要件を満たしていれば満足してしまう。&lt;/p&gt;

&lt;p&gt;優れたチームは、スピードの重要性を知っていて、イノベーションで鍵を握るのがイテレーションの早さであることを理解している。
ここで言うスピードは、適切なテクニックによって得られるもので、時間労働のようなもので得られるものではないこともわかっている。
ダメなチームは、同僚が働いてくれないからペースが上がらないと不満を言う。&lt;/p&gt;

&lt;p&gt;優れたチームは、顧客からの要望をよく吟味し、顧客と自社の業績に貢献できそうなソリューションだと確信したら、
その実現のために力を注ぐ。
ダメなチームは、営業に振り回される会社だと文句を言う。&lt;/p&gt;

&lt;p&gt;優れたチームは、フィードバックの仕組みを作る。製品がどのように使われているかをすばやく知り、そのデータにもとづいて製品に調整を加える。
ダメなチームは、分析、レポート機能を、あると良い機能だと思っている。&lt;/p&gt;

&lt;p&gt;優れたチームは、コンスタントに小規模なリリースを重ねたほうが顧客に安定したソリューションを提供できることを知っている。
そのために継続的にインテグレーション、リリースを行う。ダメなチームは、苦痛に満ちたインテグレーションのフェーズの
最後にマニュアルでテストを行い、それからすべてをまとめてリリースをする。&lt;/p&gt;

&lt;p&gt;優れたチームは、重要な顧客のことで悩む。
ダメなチームは、競合他社のことで悩む。&lt;/p&gt;

&lt;p&gt;優れたチームは、ビジネスKPIに大きなインパクトを与えられたときに祝杯をあげる。
ダメなチームは、何かをリリース出来たときに祝杯をあげる。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;序文を引用したら長くなってしまった。
とにかく本著の内容は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ストーリーは、要件を形式に落としこむためのものではない。言葉と絵を使いながらストーリーを話すのは、共通理解を築くためのメカニズムだ。&lt;/li&gt;
&lt;li&gt;ストーリーは要件ではない。会社、顧客、ユーザーが抱える問題の解決についての議論であり、何を作るかについての意見を一致に導くものだ。&lt;/li&gt;
&lt;li&gt;あなたがしなければならないことは、より早くより多くのソフトウェアを作ることではない。作ると決めたものから最大限の成果とインパクトを生み出すことだ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということである。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;最後に、もっとも感動した一文。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「本当は、あなたの仕事は世界を変えることだ。」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;素晴らしいアイディアを製品に転化するのであれば、
それを使う人々の世界を少し、あるいは少なからず変えてしまうことになる。&lt;br /&gt;
実際にそうなっていなければ、あなたの取り組みは失敗なのだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】アルゴリズムが世界を支配する</title>
      <link>http://kotazi.github.io/blog/post/2016/0213_algorithm/</link>
      <pubDate>Tue, 16 Feb 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0213_algorithm/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/B00FMI2XIW/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00FMI2XIW&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;アルゴリズムが世界を支配する (角川ＥＰＵＢ選書)&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=B00FMI2XIW&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;
を読みました。&lt;/p&gt;

&lt;p&gt;オンラインスーパーマーケットAisle50の共同設立社、クリストファー・スタイナーの著書。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次:ede789d548135e377784ce81f1ae62ff&#34;&gt;目次&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;第1章 ドミノの最初の一牌目、ウォールストリート&lt;/li&gt;
&lt;li&gt;第2章 人類とアルゴリズムの歴史&lt;/li&gt;
&lt;li&gt;第3章 ボット トップ40&lt;/li&gt;
&lt;li&gt;第4章 ボットの秘密のハイウェイ&lt;/li&gt;
&lt;li&gt;第5章 システムをゲーム化しろ&lt;/li&gt;
&lt;li&gt;第6章 ドクター・ボットを呼べ&lt;/li&gt;
&lt;li&gt;第7章 人類をカテゴライズする&lt;/li&gt;
&lt;li&gt;第8章 ウォールストリート vs シリコンバレー&lt;/li&gt;
&lt;li&gt;第9章 ウォールストリートが損をすれば他のみんなは儲かる&lt;/li&gt;
&lt;li&gt;第10章 未来はアルゴリズムとそのクリエイターのもの&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;ここのところ機械学習やディープラーニングの話題をよく耳にするので買ってみた。&lt;/p&gt;

&lt;p&gt;読んでみると株式取引や音楽を自動生成するアルゴリズムなどがかなり昔から存在することを知った。
近年ではポーカーや医療の場でもアルゴリズムは大きく活躍しており、
これからは本当にデータやアルゴリズムの時代のような気がしてしまった。&lt;/p&gt;

&lt;p&gt;アルゴリズムはすでに我々の言葉をきいて、その本音を読み取ることができるようになっている。
ポーカーや電話の自動オペレーターの話を読んでいると、今まではアルゴリズムは
天才的な人間のモデルを作ることだと思っていたけれど、どうやらそれには少し誤解があるらしかった。&lt;/p&gt;

&lt;p&gt;例えば電話対応の場合、ある電話は情報を得るためにかけられており、ある電話は共感や日常会話を求めてかかってきたものだとする。
最初の電話では、情報を伝えれば相手はすぐに満足するだろうが、雑談をし始めたらイライラするかもしれない。
2つ目の電話の場合、謝罪や誠実で思いやりのある対応が相手を最も満足させる。&lt;/p&gt;

&lt;p&gt;このようにアルゴリズムは相手によって対応を変える必要がある。&lt;br /&gt;
そして元々NASAで宇宙飛行士の相性を調べるために開発されたテービー・ケーラー博士の手法では
人間を以下の6つのタイプに分類するらしい。&lt;/p&gt;

&lt;p&gt;1: 感情重視型の人。課題に取り掛かる前に関係者と人間関係を築く。女性がこのグループの3/4を占める。全体の30%がこのグループ。窮地に陥ると劇的になり過剰反応を起こす&lt;br /&gt;
2: 思考重視型の人。社交辞令や冗談を言わない。現実ジを重視し、意思決定は厳格な現実主義に基づいて行われる。&lt;br /&gt;
3: 行動重視型の人。進捗や行動を望む。常に精力的で押しが強い。魅力的な人間が多い。&lt;br /&gt;
4: 内省重視型の人。温和で想像力が豊か。現実に取り組みよりも、これからどうなるだろうかと考えをめぐらせる。&lt;br /&gt;
5: 意見重視型の人。話し言葉は命令形と断定系が多い。状況の一面しか見ない傾向がある。自分お意見に固執する。政治家の70%はこのグループ。全人口ではったの10%。勤勉であり、問題解決まで粘り強い。&lt;br /&gt;
6: リアクション重視型の人。自発的で独創的。冗談が好きである。物事に対して強い反応を示す。起業家、発明家に多い。&lt;/p&gt;

&lt;p&gt;もちろん複数のタイプを持つこともある。&lt;/p&gt;

&lt;p&gt;この本を読んでアルゴリズムに興味が湧いた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【DMM英会話】 Job Interview | Business Basic</title>
      <link>http://kotazi.github.io/blog/post/2016/0216_dmm/</link>
      <pubDate>Tue, 16 Feb 2016 00:46:15 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0216_dmm/</guid>
      <description>

&lt;p&gt;DMM英会話のレッスン中。その日学んだことをメモ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://eikaiwa.dmm.com/download/pdf/Business_basic_07_01.pdf/&#34;&gt;Lesson 07: Discussion | Business Basic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h5 id=&#34;practice-1-formal-and-informal-expressions:96a284edaf73bd0716f6191114b57a19&#34;&gt;◯ Practice 1 | Formal and Informal Expressions&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;I beg to differ =&amp;gt; I doubt this is a good idea&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;practice-2-reading-sentences:96a284edaf73bd0716f6191114b57a19&#34;&gt;◯ Practice 2 | Reading Sentences&lt;/h5&gt;

&lt;p&gt;割愛。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;practice-3-studying-the-manual:96a284edaf73bd0716f6191114b57a19&#34;&gt;◯ Practice 3 | Studying the Manual&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;You need to be polite and show respect for a different opinion.&lt;/li&gt;
&lt;li&gt;When you disagree you need to mention that the opinion is interesting but you think in a different way.&lt;/li&gt;
&lt;li&gt;Use the following expressions: “In my opinion”, “If you ask me”, “To my mind”, “Personally I believe that”, “As far as I’m concerned”, etc.&lt;/li&gt;
&lt;li&gt;It would be perfect if after expressing your opinion, you would ask what the other person thinks: “Do you like this idea?”, “What do you think about it?”, “What are your ideas?”, etc.&lt;/li&gt;
&lt;li&gt;You need to show your response to what the other person is saying. So, sometimes add something like: “I see”, “That’s why”, “hm&amp;hellip;” for the person to feel that you are paying attention to his ideas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;意訳&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;異なる意見に対して丁寧に敬いを持つべき&lt;/li&gt;
&lt;li&gt;反対意見をいうことはいいことだが、代案を提示すること&lt;/li&gt;
&lt;li&gt;&amp;ldquo;私の見解では&amp;rdquo;、&amp;rdquo;個人的には&amp;rdquo;、&amp;rdquo;私の知る限り、&amp;rdquo;などが使える&lt;/li&gt;
&lt;li&gt;自分の意見を述べたあとに他人の意見を聞くといい。&lt;/li&gt;
&lt;li&gt;他の人が言ったことに反応すること。あいづち大事。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;practice-4-situation-questions:96a284edaf73bd0716f6191114b57a19&#34;&gt;◯ Practice 4 | Situation Questions&lt;/h5&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;You are in the middle of a business discussion and you remember that you have an appointment and　you need to go. What do you do?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;I&amp;rsquo;ll judge witch promise is important for job in spirit.
And if current meeting is important, I&amp;rsquo;ll send a mail to the man who have appointment.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;You are expressing your idea and suddenly another employee impolitely interrupts you. What do you do?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;If his attitude is impolitely, I want to understand his opinion in good spirits.
And after discussion, I&amp;rsquo;ll point out to him about for his attitude for him.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;You are in a meeting where people are discussing an important topic, but no one asks for your opinion even though you have one. What do you do?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Raise my hand. And say &amp;ldquo;I have a opinion.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;覚えた英単語:96a284edaf73bd0716f6191114b57a19&#34;&gt;◯ 覚えた英単語&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;単語&lt;/th&gt;
&lt;th&gt;意味&lt;/th&gt;
&lt;th&gt;その他&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;destination&lt;/td&gt;
&lt;td&gt;目的地&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;convinced&lt;/td&gt;
&lt;td&gt;確信している&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;colleague&lt;/td&gt;
&lt;td&gt;仲間&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;the following month&lt;/td&gt;
&lt;td&gt;翌月&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;within a company&lt;/td&gt;
&lt;td&gt;社内&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;The ability to keep calm is one of her many strengths.&lt;/li&gt;
&lt;li&gt;He has applied to join the army.&lt;/li&gt;
&lt;li&gt;She quit school at 16.&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;ve quit smoking.&lt;/li&gt;
&lt;li&gt;Being able to speak a foreign language is a major asset.&lt;/li&gt;
&lt;li&gt;She&amp;rsquo;ll be an asset to the team.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;けっこう喋れるようになってきた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>信頼残高のことを思い出した。</title>
      <link>http://kotazi.github.io/blog/post/2016/0215_trast/</link>
      <pubDate>Mon, 15 Feb 2016 19:27:45 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0215_trast/</guid>
      <description>&lt;p&gt;サイバーエージェントで働いていたころ、しばしば「信頼残高」という言葉を耳にした。(こういう考え方が社内に浸透していることが本当にすごいと今になって思う。)&lt;/p&gt;

&lt;p&gt;仕事というものは信頼の積み重ねで成り立っている。
この信頼の積み重ねこそが、自身の「信頼残高」だ。&lt;/p&gt;

&lt;p&gt;大きな仕事や、期待以上の成果を出せば信頼残高が増えていく。
信頼残高のある人間には、また大きな仕事やチャンスが回ってくる。&lt;/p&gt;

&lt;p&gt;逆につまらないミスなどをすれば信頼残高は減っていってしまう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メールの誤字脱字が多い&lt;/li&gt;
&lt;li&gt;会議に2、3分遅刻してしまう&lt;/li&gt;
&lt;li&gt;二日酔いで出社してくる&lt;/li&gt;
&lt;li&gt;資料のまとめ方が下手&lt;/li&gt;
&lt;li&gt;デスク周りがいつも散らかっている&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こういったことでも信頼残高はどんどん削られていってしまう。
「稼いでいるのに全然貯金が貯まらない人」みたいになってしまう。&lt;/p&gt;

&lt;p&gt;日々の積み重ねをしっかりとやっていこう。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;個人的に思ったのが、NZ内での信頼が積み重ねられていないなと思った。
自分の成果が海を超えて認められるように努力することはもちろんなのだけれど、
各国での評価が一律になるような透明度の高い組織を作っていきたい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails内でのwebpackの使い方</title>
      <link>http://kotazi.github.io/blog/post/2016/0214_rails_webpack/</link>
      <pubDate>Sun, 14 Feb 2016 13:41:03 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0214_rails_webpack/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://clarkdave.net/2015/01/how-to-use-webpack-with-rails/&#34;&gt;&amp;ldquo;How to use webpack with Rails&amp;rdquo;&lt;/a&gt;翻訳記事になります。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;webpackは強力なモジュールバンドラである。主としてフロントエンド開発のために設計されており、
bowerやnpmのJavaScriptモジュールをうまく統合することができる。&lt;/p&gt;

&lt;p&gt;Sproketsやアセットパイプラインを用いればシームレスな挿入をすることが可能だけれども、これには典型的なRailsのJSマネジメントシステムを使うによりいくつか大きな利点がある。残念ながらwebpackのドキュメントはまだ要約することが難しく、特にRailsに統合したいとなればなおさらだ。&lt;/p&gt;

&lt;p&gt;あなたがまだwebpackを使っていないのであれば、ここに何ができるのかを示そう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;npmやbowerを使っている全てのフロントエンドのJS(依存関係も)管理する&lt;/li&gt;
&lt;li&gt;CoffeeScriptやES6を自動で処理する&lt;/li&gt;
&lt;li&gt;最小の力で全てのソースマップを出力する&lt;/li&gt;
&lt;li&gt;難しい部分でのJSの分離に役に立つ。&amp;rdquo;common&amp;rdquo;モジュールが自動的に全てのページに渡ってシェアしてくれる&lt;/li&gt;
&lt;li&gt;大きなモジュールを複数のファイルに分割し、必要なファイルのみをダウンロードする(&lt;code&gt;require.ensure&lt;/code&gt;を用いる)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いいなと思ったら、これらを既存のRailsアプリ、もしくは新たなRailsアプリでどのように利用するか呼んでみるといい。
ちなみに、これはRails中心に書かれているけれども、Railsでなくともそのようなフレームワークにwebpackを導入したいのであればきっと役に立つだろう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;getting-started:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Getting Started&lt;/h3&gt;

&lt;h4 id=&#34;is-webpack-right-for-your-app:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Is webpack right for your app?&lt;/h4&gt;

&lt;p&gt;webpackは本当にパワフルで素晴らしいツールである。
けれども本当に効果的に利用するには、あなたが&amp;rdquo;モジュールとしてのJS&amp;rdquo;という哲学をしっかりと信じる必要がある。
jQueryやBackboneといった人気のライブラリを使っているなら簡単なことだ。
けれども、特に大きなアプリをwebpackを用いてコンバートしているのなら、いくつかの問題につまづくであろうことを知っておくべきだ。&lt;/p&gt;

&lt;p&gt;典型的な問題:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;モジュールにはちゃんと定義されてエントリーポイントがない(webpackはあなたが要求したときに何を含むべきか知らない)&lt;/li&gt;
&lt;li&gt;モジュールに&lt;code&gt;package.json&lt;/code&gt;や&lt;code&gt;bower.json&lt;/code&gt;は無効である&lt;/li&gt;
&lt;li&gt;modules which simply stick something on window and call it a day&lt;/li&gt;
&lt;li&gt;modules which add something to jQuery, instead of exporting anything&lt;/li&gt;
&lt;li&gt;modules which, by default, give you a gigantic kitchen sink you don’t need&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;幸運にもこれらの問題に対処するための様々なメソッドがあるため、webpackで全て解決できる。
さっきも述べたようにwebpackのドキュメントは量が多いので、私が上記についてはカバーする。&lt;/p&gt;

&lt;p&gt;あなたのアプリに向いているか？&lt;/p&gt;

&lt;h4 id=&#34;新しいrailsアプリを作っているところ:78a84d7a250550b9fca3451f0818ba23&#34;&gt;新しいRailsアプリを作っているところ&lt;/h4&gt;

&lt;p&gt;大量のJSコードを使うのなら絶対に。試さない理由がない。&lt;/p&gt;

&lt;h4 id=&#34;アプリは大きいがjsはそこまで量がない:78a84d7a250550b9fca3451f0818ba23&#34;&gt;アプリは大きいがJSはそこまで量がない&lt;/h4&gt;

&lt;p&gt;多分価値が無いかも。webpackはたくさんのモジュールを使っていたり、たくさんのJSコードを書いているときに
本当に輝く。そんなにJSがないのであれば、大きなメリットはないだろう。&lt;/p&gt;

&lt;h4 id=&#34;アプリは大きいが-jsはよく整備されており-特に問題がない:78a84d7a250550b9fca3451f0818ba23&#34;&gt;アプリは大きいが、JSはよく整備されており、特に問題がない&lt;/h4&gt;

&lt;p&gt;全てをwebpackに移行することはそれなりに労力がかかるため、多分やる価値はない。&lt;/p&gt;

&lt;h4 id=&#34;アプリは大きく-大量のスパゲッティコード-jsファイルは800kbを超えている:78a84d7a250550b9fca3451f0818ba23&#34;&gt;アプリは大きく、大量のスパゲッティコード、jsファイルは800kbを超えている&lt;/h4&gt;

&lt;p&gt;きっとwebpackを使ったほうがいい！少々大変だが、知るべきことはこのガイドで伝える。&lt;/p&gt;

&lt;p&gt;始める準備ができたら、Railsアプリをwebpackに移行しよう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;preparing-rails-for-webpack:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Preparing Rails for webpack&lt;/h3&gt;

&lt;p&gt;Railsにwebpackを統合するベストプラクティスは存在しないため、多くは意見である。
もしディレクトリの置き場所が気に食わなければ、好きな場所においてもらって構わない。&lt;/p&gt;

&lt;h4 id=&#34;untangling-sprockets:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Untangling Sprockets&lt;/h4&gt;

&lt;p&gt;最初にすることは&lt;code&gt;app/assets/javascripts&lt;/code&gt;を空にすることだ。
webpackの設定を個々にすると、Sprocketsに拾われてしまう。
全てのJSコードを他の場所に移そう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt;にこれを追加しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/app/assets/javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これには2つの理由がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;生成されるバンドルは大きくなりがちだったり変更されがちだったりで、ただのgitのスパムを生成することになる&lt;/li&gt;
&lt;li&gt;We’ll be integrating webpack with our deloy process later, which will build a production version of the bundles and placing them here. So, even if you checked in the bundles, you’d be replacing them during deploy anyway.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記のアドバイスはあなたが全てをwebpackに移行するものとしてのことだ。
もちろんSprocketsのJSバンドラとwebpackを併用することもできる。
その場合は、&lt;code&gt;.gitignore&lt;/code&gt;を&lt;code&gt;/app/assets/javascripts/bundle-*&lt;/code&gt;みたいに生成されたJSのみを無視するように修正する。&lt;/p&gt;

&lt;h4 id=&#34;a-new-home-for-your-javascript:78a84d7a250550b9fca3451f0818ba23&#34;&gt;A new home for your JavaScript&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;app/assets/javascripts&lt;/code&gt;は生成されたバンドラのためのものなので、実際のJSのために新しいホームを生成する必要がある。
私は新しいフォルダを作成するが、もちろん他の場所においてもいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/frontend/javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ディレクトリ内部に&lt;code&gt;entry.js&lt;/code&gt;というファイルを作成しよう。
またあとで説明するので、とりあえず追加してくれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var _ = require(&#39;lodash&#39;);
_.times(5, function(i) {
  console.log(i);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;installing-webpack-bower:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Installing webpack &amp;amp; Bower&lt;/h3&gt;

&lt;h4 id=&#34;installing-webpack:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Installing webpack&lt;/h4&gt;

&lt;p&gt;webpackはnode.jsのアプリケーションのため、&lt;code&gt;package.json&lt;/code&gt;がRailsルートの中に必要だ。&lt;br /&gt;
シンプルであるために、webpackとwebpackのモジュールを管理するためだけに使っている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;my-rails-app&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;my-rails-app&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;webpack&amp;quot;: &amp;quot;~1.4.13&amp;quot;,
    &amp;quot;expose-loader&amp;quot;: &amp;quot;~0.6.0&amp;quot;,
    &amp;quot;imports-loader&amp;quot;: &amp;quot;~0.6.3&amp;quot;,
    &amp;quot;exports-loader&amp;quot;: &amp;quot;~0.6.2&amp;quot;,
    &amp;quot;lodash&amp;quot;: &amp;quot;~2.4.1&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依存関係に&lt;code&gt;webpack&lt;/code&gt;があることが見えるだろう。それと多分必要であろういくつかwebpackのローダーを追加した(後で説明する)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install&lt;/code&gt;をして&lt;code&gt;node_modules&lt;/code&gt;を確認しよう。
すでにnode.jsはインストール済み？まだだったらインストールしよう！&lt;/p&gt;

&lt;p&gt;続いて&lt;code&gt;webpack&lt;/code&gt;グローバルにインストールし、コマンドラインツールで使えるようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;installing-bower-optional:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Installing Bower (optional)&lt;/h4&gt;

&lt;p&gt;webpackのいいところのひとつは利用するパッケージ管理ツールを強要しないところだ。
デフォルトはたくさんのフロントエンドモジュールをもったnpmだ。
けれどもBowerというweb用に設計された別のパッケージ管理ツールでしか利用できないフロントエンドライブラリもたくさんある。&lt;/p&gt;

&lt;p&gt;jQueryやunderscore、lodashといった人気で整備されているライブラリのみを使う予定なのであればBowerは必要ない。
これらはnpmで十分だ。&lt;code&gt;package.json&lt;/code&gt;はnpmを使って簡単に追加できる。&lt;/p&gt;

&lt;p&gt;しかしながら、もし多くのライブラリを使う必要があったり、単にBowerが好きならセットアップは簡単にできる。
まずは&lt;code&gt;bower&lt;/code&gt;コマンドをインストールしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g bower
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてRailsルートに&lt;code&gt;bower.json&lt;/code&gt;を作成しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;my-rails-app&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;my-rails-app&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;jquery&amp;quot;: &amp;quot;~1.11.0&amp;quot;,
    &amp;quot;lodash&amp;quot;: &amp;quot;~2.4.1&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではjQueryとlodashを依存関係に持った最小限の&lt;code&gt;bower.json&lt;/code&gt;を作成した。
Railsルートで&lt;code&gt;bower install&lt;/code&gt;を実行すると、bowerはこれらのライブラリを依存関係に沿って&lt;code&gt;bower_components&lt;/code&gt;にインストールする。&lt;/p&gt;

&lt;p&gt;覚えておいて欲しいのが、npmと違いbowerは、フラットな階層で依存関係を解消する。
だからもし、あなたがjQueryの1.x系を指定しながら、別の依存関係では最低のjQueryバージョンを2.x以上と指定していたのであれば、
これを自分自身で解消する必要がある。&lt;/p&gt;

&lt;h3 id=&#34;using-bower-and-npm-together:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Using bower and npm together&lt;/h3&gt;

&lt;p&gt;webpack内でnpmとbowerを一緒に使うことを止めるものはいない。
たとえばもしjQueryとBackboneをnpmから、人気のないモジュールをBowerからといったように。
事実、&lt;a href=&#34;https://webpack.github.io/docs/usage-with-bower.html#prefer-modules-from-npm-over-bower&#34;&gt;webpackのドキュメント&lt;/a&gt;にも書かれている。&lt;/p&gt;

&lt;p&gt;In a nutshell, npm (CommonJS-style) modules are typically cleaner and easier for webpack to optimise, which will result in smaller bundles and faster compile times.&lt;/p&gt;

&lt;p&gt;In practice, this might not make a huge difference. In the case of large modules like &lt;code&gt;React&lt;/code&gt;, it may be worth including it as a one-off from npm so webpack can optimise it a little better, but for almost everything else I recommend sticking with Bower so you have one place for all your dependencies.&lt;/p&gt;

&lt;h3 id=&#34;configuring-webpack:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Configuring webpack&lt;/h3&gt;

&lt;p&gt;たくさんの引数を用いて完全にコマンドラインからwebpackを実行することもできるが、複雑になってしまうので、コンフィグファイルを用いて始めよう。&lt;/p&gt;

&lt;p&gt;Railsルートに&lt;code&gt;webpack.config.js&lt;/code&gt;を作成しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var path = require(&#39;path&#39;);
var webpack = require(&#39;webpack&#39;);

var config = module.exports = {
  // the base path which will be used to resolve entry points
  context: __dirname,
  // the main entry point for our application&#39;s frontend JS
  // メインとなるエントリーポイント
  entry: &#39;./app/frontend/javascripts/entry.js&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的に非常に複雑なファイルになるので、最小限のところから始めて、説明をしながら加えていこう。
ガイドを通してたくさんのことをフィルについかしていくことになる。
&lt;a href=&#34;https://webpack.github.io/docs/configuration.html&#34;&gt;webpackドキュメント&lt;/a&gt;にも設定用プロパティの概要については書かれている。&lt;/p&gt;

&lt;p&gt;現在ひとつのエントリーファイルを持っているが、配列やオブジェクトを設定することも可能だ。(後に説明)
注意すべき重要な事は、このエントリーファイルがJSのコアとなるということだ。
ここでファイルを指定しなければコンパイルが完了することはない。&lt;/p&gt;

&lt;p&gt;次は&lt;code&gt;output&lt;/code&gt;を追加しよう。コンパイルされたバンドルの場所を占めるものだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.output = {
  // this is our app/assets/javascripts directory, which is part of the Sprockets pipeline
  // app/assets/javascriptsディレクトリのこと。Sprocketsの一部となる。
  path: path.join(__dirname, &#39;app&#39;, &#39;assets&#39;, &#39;javascripts&#39;),
  // the filename of the compiled bundle, e.g. app/assets/javascripts/bundle.js
  // コンパイルされらバンドラのファイル名。
  filename: &#39;bundle.js&#39;,
  // if the webpack code-splitting feature is enabled, this is the path it&#39;ll use to download bundles
  // webpackの&amp;quot;code-splitting&amp;quot;機能を使う場合。
  publicPath: &#39;/assets&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いて&lt;code&gt;resolve&lt;/code&gt;を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.resolve = {
  // tell webpack which extensions to auto search when it resolves modules. With this,
  // you&#39;ll be able to do `require(&#39;./utils&#39;)` instead of `require(&#39;./utils.js&#39;)`
  // 自動補完をwebpackに伝える。
  // この場合`require(&#39;./utils.js&#39;)`の代わりに`require(&#39;./utils&#39;)`とすることができる
  extensions: [&#39;&#39;, &#39;.js&#39;],
  // by default, webpack will search in `web_modules` and `node_modules`. Because we&#39;re using
  // Bower, we want it to look in there too
  // デフォルトでは`web_module`と`node_modules`を探す。今回はBowerを使うので下記になる
  modulesDirectories: [ &#39;node_modules&#39;, &#39;bower_components&#39; ],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に&lt;code&gt;plugins&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.plugins = [
  // we need this plugin to teach webpack how to find module entry points for bower files,
  // as these may not have a package.json file
  new webpack.ResolverPlugin([
    new webpack.ResolverPlugin.DirectoryDescriptionFilePlugin(&#39;.bower.json&#39;, [&#39;main&#39;])
  ])
];
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;running-webpack:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Running webpack&lt;/h3&gt;

&lt;p&gt;webpackを実行する前に、Bowerの依存関係をインストールしよう。
NPMだけなら&lt;code&gt;npm install&lt;/code&gt;を実行すればいい。Bower依存関係をインストールするには:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bower install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;jquery&lt;/code&gt;と&lt;code&gt;lodash&lt;/code&gt;の入った&lt;code&gt;bower_components/&lt;/code&gt;ディレクトリがあることだろう。&lt;/p&gt;

&lt;p&gt;それが終わればwebpackをRailsルートから実行しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ webpack -d --display-reasons --display-chunks --progress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドはwebpackをdevelopmentモードで実行し、何を実行しているかを表示するようになる。
ゆくゆくはこのコマンドを自動化する。
すべてが上手く行けば、このような出力が確認できるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hash: cfee07d10692c4ab1eeb
Version: webpack 1.4.14
Time: 548ms
        Asset    Size  Chunks             Chunk Names
    bundle.js  254088       0  [emitted]  main
bundle.js.map  299596       0  [emitted]  main
chunk    {0} bundle.js, bundle.js.map (main) 244421 [rendered]
    [0] ./app/frontend/javascripts/entry.js 73 {0} [built]
     + 2 hidden modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この出力には、&lt;code&gt;bundle.js&lt;/code&gt;という&amp;rdquo;チャンク&amp;rdquo;が作成されたことと、sourcemapが作成されたことが書かれている。
チャンクはJSの分割方法についてだ。
いまはただ、エントリーポイントにつき一つのチャンクを作成しただけだ。
けれどももし、エントリーポイント間にたくさんのモジュールがあったり、code-splitting機能を使っているのであれば、
webpackは&lt;code&gt;1.1-bundle.js&lt;/code&gt;といった名前でたくさんのチャンクを作成する。&lt;/p&gt;

&lt;h4 id=&#34;the-compiled-webpack-bundle:78a84d7a250550b9fca3451f0818ba23&#34;&gt;The compiled webpack bundle&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;app/assets/javascripts/bundle.js&lt;/code&gt;ファイルを開いてみると、コンパイルされたJavaScriptが確認できる。
このファイルでは、標準のJavaScriptは持っていない機能である依存関係の&lt;code&gt;require&lt;/code&gt;機能を全てのモジュールに提供するwebpackローダーを含んでいる。(数バイト)&lt;/p&gt;

&lt;p&gt;webpackが実際に行っていることは下記のコードを見て呼び出しを&lt;code&gt;require(&#39;lodash&#39;)&lt;/code&gt;に変えてみるといい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var _ = __webpack_require__(/*! lodash */ 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全てのモジュールに注入される&lt;code&gt;__webpack_require__&lt;/code&gt;関数は要求された依存関係をロードすることができる。
サンプル通りにやっているのであれば、50行目は下記のようになっているはずである。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 0 */
/*!*******************************************!*\
  !*** ./app/frontend/javascripts/entry.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

  var _ = __webpack_require__(/*! lodash */ 1);
  _.times(5, function(i) {
    console.log(i);
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;including-webpack-bundles-in-rails-views:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Including webpack bundles in Rails views&lt;/h4&gt;

&lt;p&gt;思っている通りで、コンパイルされtらJSバンドラは普通に含めることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;%= javascript_include_tag &#39;bundle&#39;  %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基礎はこれで完了。
あとは大きなアプリケーションで必要になりそうなことをカバーしていく。&lt;/p&gt;

&lt;h3 id=&#34;exposing-global-modules-e-g-jquery:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Exposing global modules (e.g. jQuery)&lt;/h3&gt;

&lt;p&gt;特定のモジュールでjQueryを使いたければ下記のように書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ = require(&#39;jquery&#39;);
$(&#39;p&#39;).show();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;けれどもきっとこのようなことがしたいだろう:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自動で全てのモジュールにjQueryを使えるようにし、毎回&lt;code&gt;$ = require(&#39;jquery&#39;)&lt;/code&gt;のようなことは書く必要がない&lt;/li&gt;
&lt;li&gt;モジュールの外側でも使えるように、&lt;code&gt;window.$&lt;/code&gt;のようにグローバルオブジェクトにする。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;webpackでどちらも可能だ。&lt;code&gt;ProvidePlugin&lt;/code&gt;を使う。webpackのコンフィグにプラグインの配列を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new webpack.ProvidePlugin({
  $: &#39;jquery&#39;,
  jQuery: &#39;jquery&#39;,
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで自動的に&lt;code&gt;$&lt;/code&gt;と&lt;code&gt;jQuery&lt;/code&gt;を注入するようになり、全てのモジュールに&lt;code&gt;require&lt;/code&gt;を追加する必要はもはやなくなる。&lt;/p&gt;

&lt;p&gt;次のステップとして&lt;code&gt;window&lt;/code&gt;オブジェクトの追加だ。&lt;a href=&#34;https://webpack.github.io/docs/loaders.html&#34;&gt;loader&lt;/a&gt;
を追加する。loaders apply some kind of transformation on a file. For example, later we’ll show how to use a loader to transform CoffeeScript files into JavaScript.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expose&lt;/code&gt;ローダーはモジュールからエクスポートし、それをグローバルに追加する。今回の場合&lt;code&gt;window&lt;/code&gt;だ。
ou can configure loaders in the webpack config, which makes sense for transformations like CoffeeScript, but you can also specify them when you require a module, which I think makes more sense for the expose loader as it expresses the intent in your code.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;entry.js&lt;/code&gt;のトップに書きを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require(&#39;expose?$!expose?jQuery!jquery&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書式がアホらしいことは分かっている。&lt;code&gt;window.$&lt;/code&gt;と&lt;code&gt;window.jQuery&lt;/code&gt;にjQueryを追加するために、&lt;code&gt;expose&lt;/code&gt;ローダーを２回呼び出している。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require(expose?&amp;lt;libraryName&amp;gt;!&amp;lt;moduleName&amp;gt;)&lt;/code&gt;のように書いている。
&lt;code&gt;&amp;lt;libraryName&amp;gt;&lt;/code&gt;は&lt;code&gt;window.libraryName&lt;/code&gt;となり、&lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt;とは含むモジュールのこと。
このケースでは&lt;code&gt;jquery&lt;/code&gt;だ。&lt;code&gt;!&lt;/code&gt;を使って上記に書いたようにチェインすることが可能。&lt;/p&gt;

&lt;p&gt;さきほどと同じコマンドを使って、再度webpackを実行すると、&lt;code&gt;$&lt;/code&gt;と&lt;code&gt;jQuery&lt;/code&gt;にグローバルアクセスできることが分かるだろう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;source-maps:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Source maps&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;bundle.js.map&lt;/code&gt;が出力先のディレクトリに作成されていることに気付いただろう。
このソースマップはwebpackの働きによって生成されている。
The source maps generated by webpack work extremely well. You get to download a single bundle (instead of 10+ individual files, which can get slow) but can view errors inside individual files, as they exist on your file system. And of course, if you’re using CoffeeScript and friends, you can view errors in the context of the actual CoffeeScript file.&lt;/p&gt;

&lt;p&gt;However, by default Sprockets will break the source maps by appending a semi-colon to them, so browsers can’t parse them. You can fix this with the following configuration option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rails.application.config.assets.configure do |env|
  env.unregister_postprocessor &#39;application/javascript&#39;, Sprockets::SafetyColons
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this to your &lt;code&gt;config/initializers/assets.rb&lt;/code&gt; (or directly in &lt;code&gt;config/application.rb&lt;/code&gt; for older versions of Rails). Then clear your Sprockets cache: $ rm -r tmp/cache`&lt;/p&gt;

&lt;p&gt;Now when you get errors, or view loaded sources in a browser, you’ll see the actual file (e.g. entry.js) instead of the giant bundled file.&lt;/p&gt;

&lt;h4 id=&#34;virtual-source-paths:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Virtual source paths&lt;/h4&gt;

&lt;p&gt;In Chrome, by default the source map generated by webpack will put everything in a &amp;lsquo;pseudo path’, &lt;code&gt;webpack://&lt;/code&gt;, when you view it in the inspector’s Sources tab. You can make this a bit nicer by adding the following to your webpack &lt;code&gt;config.output&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;devtoolModuleFilenameTemplate: &#39;[resourcePath]&#39;,
devtoolFallbackModuleFilenameTemplate: &#39;[resourcePath]?[hash]&#39;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now your &amp;lsquo;virtual’ source files will appear under the &lt;code&gt;domain &amp;gt; assets&lt;/code&gt; directory in the Sources tab.&lt;/p&gt;

&lt;h4 id=&#34;sprockets-cache-and-source-maps:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Sprockets cache and source maps&lt;/h4&gt;

&lt;p&gt;In my experience, Sprockets can be very aggressive at caching source maps. If they ever start acting weird, make sure to clear the sprockets cache in &lt;code&gt;tmp/cache&lt;/code&gt; first.&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;loading-coffeescript-and-other-transpiled-languages:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Loading CoffeeScript and other transpiled languages&lt;/h3&gt;

&lt;p&gt;CoffeeScriptやその類で書かれたモジュールをローダーを使って自動でトランスパイルすることができる。
&lt;code&gt;expose&lt;/code&gt;ローダーのように、&lt;code&gt;require&lt;/code&gt;ステートメントの内部で実行されるが、webpackのコンフィグに記述することがよいとは言えないので、
CoffeeScriptモジュールをrequireする。&lt;/p&gt;

&lt;p&gt;はじめに、書きのように&lt;code&gt;package.json&lt;/code&gt;に&lt;code&gt;coffee-loader&lt;/code&gt;をインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install coffee-loader@0.7.2 --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpackのコンフィグで、&lt;code&gt;config.resolve.extensions&lt;/code&gt;も書いておく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.coffee&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、ローダーを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.module = {
  loaders: [
    { test: /\.coffee$/, loader: &#39;coffee-loader&#39; },
  ],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;app/frontend/javascripts/app.coffee&lt;/code&gt;を作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_ = require(&#39;lodash&#39;)

module.exports = class App
  start: -&amp;gt;
    _.times 3, (i) -&amp;gt; console.log(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既存の&lt;code&gt;entry.js&lt;/code&gt;を更新する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require(&#39;expose?$!expose?jQuery!jquery&#39;);
var App = require(&#39;./app&#39;);

var app = new App();
app.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再度webpackを実行して、ブラウザで予想通りに動作していることが確認できる。&lt;/p&gt;

&lt;h3 id=&#34;code-splitting-and-lazily-loading-modules:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Code splitting and lazily loading modules&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>【プログラミング言語Ruby】3章-データ型とオブジェクト</title>
      <link>http://kotazi.github.io/blog/post/2016/0212_ruby/</link>
      <pubDate>Sat, 13 Feb 2016 20:34:06 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0212_ruby/</guid>
      <description>

&lt;h3 id=&#34;数値:1999afa650d3f1ac291df7d051f99de9&#34;&gt;数値&lt;/h3&gt;

&lt;p&gt;Rubyは数値を表現する5種類の組み込みクラスを持っており、
標準ライブラリにはさらに3種類の役に立ち数値クラスが含まれている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/l/AHWcSL7aQflDHarJQfPcwzy2xDWCtDv8WdUB/image.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Rubyの全ての数値オブジェクトは&lt;code&gt;Numeric&lt;/code&gt;のインスタンスになっている。
全ての整数は&lt;code&gt;Integer&lt;/code&gt;のインスタンスである。31ビット幅に収まる整数値は&lt;code&gt;Fixnum&lt;/code&gt;のインスタンスであり、
そうでなければ&lt;code&gt;Bignum&lt;/code&gt;のインスタンスである。
Rubyでは実数値を&lt;code&gt;Float&lt;/code&gt;クラスで近似的に表現する。&lt;code&gt;Float&lt;/code&gt;クラスは
プラットフォーム固有の浮動小数点表現を使う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Complex&lt;/code&gt;クラスは複素数を表現する。
&lt;code&gt;BigDecimal&lt;/code&gt;クラスは10進数表現を使って任意の制度の実数を表現する。
&lt;code&gt;Rational&lt;/code&gt;クラスは有理数、すなわち整数を別の整数で除算した値を表現する。&lt;/p&gt;

&lt;p&gt;また、全ての数値オブジェクトはイミュータブルである。&lt;/p&gt;

&lt;h3 id=&#34;文字列:1999afa650d3f1ac291df7d051f99de9&#34;&gt;文字列&lt;/h3&gt;

&lt;p&gt;文字列は&lt;code&gt;String&lt;/code&gt;クラスによって表現する。ミュータブルなオブジェクトである。
パターンは&lt;code&gt;Regexp&lt;/code&gt;オブジェクトとして表現される。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%q&lt;/code&gt;、&lt;code&gt;%Q&lt;/code&gt;はStringリテラル。&lt;/p&gt;

&lt;h3 id=&#34;配列:1999afa650d3f1ac291df7d051f99de9&#34;&gt;配列&lt;/h3&gt;

&lt;p&gt;配列とは、値の列で、列の中の位置(添字)によって値にアクセスできるようになっているものである。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%w&lt;/code&gt;、&lt;code&gt;%W&lt;/code&gt;は配列リテラル。&lt;/p&gt;

&lt;p&gt;配列は&lt;code&gt;Array.new&lt;/code&gt;コンストラクタでも作成できる。&lt;/p&gt;

&lt;h3 id=&#34;ハッシュ:1999afa650d3f1ac291df7d051f99de9&#34;&gt;ハッシュ&lt;/h3&gt;

&lt;p&gt;ハッシュとはキーと呼ばれるオブジェクトの集合を保持し、ここのキーに値を対応付けているデータ構造である。
キーを値にマッピングするので、ハッシュはマップとも呼ばれる。
個々のキーから値を連想するように導き出すので、連想配列とも呼ばれることもあるし、
添字が整数ではなく任意のオブジェクトになった配列と考え得ることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numbers = Hash.new
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;ハッシュリテラル:1999afa650d3f1ac291df7d051f99de9&#34;&gt;ハッシュリテラル&lt;/h4&gt;

&lt;p&gt;ハッシュリテラルは全体が中括弧で囲まれ、カンマで区切られたキー/値の対という形で記述される。
キーと値は&lt;code&gt;=&amp;gt;&lt;/code&gt;という2文字の矢印で区切られる。先ほど作成したHashオブジェクトは次のリテラルでも作成できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numbers = { &amp;quot;one&amp;quot; =&amp;gt; 1, &amp;quot;two&amp;quot; =&amp;gt; 2, &amp;quot;three&amp;quot; =&amp;gt; 3 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般に、ハッシュキーとしては文字列よりも&lt;code&gt;Symbol&lt;/code&gt;オブジェクトの方が効率的に使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numbers = { :one =&amp;gt; 1, :two =&amp;gt; 2, :three =&amp;gt; 3 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Symbol&lt;/code&gt;とはinternされたイミュータブルな文字列で、プレフィックスとしてコロンが付けられた識別子という形で記述される。&lt;/p&gt;

&lt;p&gt;Rubyのハッシュは、ハッシュテーブルというデータ構造を使って実装されている。
ハッシュのキーとして使えるオブジェクトは、キーのハッシュ値となるFixnumを返すhashという名前のメソッドを保つ必要がある。&lt;/p&gt;

&lt;h3 id=&#34;範囲:1999afa650d3f1ac291df7d051f99de9&#34;&gt;範囲&lt;/h3&gt;

&lt;p&gt;Rangeオブジェクトは先頭の値から末尾の値までのすべての値を表す。範囲リテラルは、先頭の値と末尾の値の間に2個または3子のドットを入れて記述する。
ドットが２個なら範囲は包含的で、末尾の値も範囲の一部となる。
ドットが３個なら、範囲は排他的で、末尾の値は範囲に含まれない。&lt;/p&gt;

&lt;p&gt;範囲には暗黙的に順序がある。
Stringクラスにはsuccメソッド定義されており、&lt;code&gt;&#39;a&#39;.succ&lt;/code&gt;が&amp;rsquo;b&amp;rsquo;、&lt;code&gt;&#39;b&#39;.succ&lt;/code&gt;が&amp;rsquo;c&amp;rsquo;である。
このように反復処理できる範囲を離散範囲(discrete range)という。短点がsuccメソッドを定義していない範囲は反復処理できないので
連続範囲(continuous range)という。
短点が整数になっている範囲は離散範囲だが、浮動小数点になっている範囲は連続範囲である。&lt;/p&gt;

&lt;h3 id=&#34;シンボル:1999afa650d3f1ac291df7d051f99de9&#34;&gt;シンボル&lt;/h3&gt;

&lt;p&gt;Rubyの一般的な実装は、実装が把握しているすべてのクラス、メソッド、変数の名前を格納するシンボルテーブルを管理している。
シンボルテーブルがあるおかげで、インタープリタは文字列の比較をほとんどせずに済ませられる。
たとえばメソッド名は、このシンボルテーブル内でのメソッド名の位置によって参照する。
こうすることにより、比較的コストの高い文字列の処理がコストの低い整数処理に変わる。&lt;br /&gt;
これらのシンボルは、純粋にインタープリタの内部構造としてしまい込まれているわけではなく、Rubyプログラムからも使えるようになっている。
Symbolオブジェクトは、シンボルを参照しているのである。シンボルリテラルは、コロンをプレフィックスとする識別子や文字列という形で書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:symbol       # Symbolのリテラル
:&amp;quot;symbol&amp;quot;     # 全く同じリテラル
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2個の文字列では、同じ内容を持ちつつ、全く異なるオブジェクトという場合があるが、シンボルではそのようなことは決して起きない。
同じ内容を持つ2個の文字列をシンボルに変換すると、全く同じSymbolオブジェクトになる。2つの異なるSymbolオブジェクトは、必ず異なる内容を持つ。&lt;/p&gt;

&lt;p&gt;文字列の内容のためではなく、一種の固有な識別子として文字列を扱うコードを書こうとしているときには、シンボルを使うことを検討すると良い。
たとえば、引数として&amp;rdquo;AM&amp;rdquo;または&amp;rdquo;PM&amp;rdquo;という文字列を受け付けるメソッドを書くのではなく、:AMか:PMというシンボルを受け付けるようにするのである。
2つの文字列が等しいかどうかを比較するよりも、2つのSymbolオブジェクトが等しいかどうかを検討する方が、はるかに速い。
同じ理由から、ハッシュキーとしては一般に文字列を使うよりもシンボルを使ったほうがよい。&lt;/p&gt;

&lt;h3 id=&#34;true-false-nil:1999afa650d3f1ac291df7d051f99de9&#34;&gt;true、false、nil&lt;/h3&gt;

&lt;p&gt;true、false、nilはRubyのキーワードとなっており、予約された特別な値である。
これらのキーワードを評価すると、専用のオブジェクトになる。
trueを評価すると、&lt;code&gt;TrueClass&lt;/code&gt;のシングルトンインスタンスのオブジェクトになる。
同様に、falseとnilは&lt;code&gt;FalseClass&lt;/code&gt;、&lt;code&gt;NilClass&lt;/code&gt;のシングルトンインスタンスである。
Booleanクラスがないことに注意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o == nil
o.nil?
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;オブジェクト:1999afa650d3f1ac291df7d051f99de9&#34;&gt;オブジェクト&lt;/h3&gt;

&lt;p&gt;Rubyはオブジェクト指向言語として非常に純度が高い。
すべての値はオブジェクトであり、他の多くの言事は異なり、原始型と呼べるようなものはない。
Rubyでは、すべてのオブジェクトはObjectだという名前のクラスの敬称をシており、&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【プログラミング言語Ruby】2章-Rubyプログラムの構造と実行</title>
      <link>http://kotazi.github.io/blog/post/2016/0211_ruby/</link>
      <pubDate>Fri, 12 Feb 2016 20:34:06 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0211_ruby/</guid>
      <description>

&lt;p&gt;Rubyインタープリタは、トークンの連続としてプログタムを解析する。
トークンは、コメント、リテラル、記号類、識別子、キーワードである。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;コメントは&lt;code&gt;#&lt;/code&gt;。
複数行コメントは&lt;code&gt;=begin&lt;/code&gt;に始まり、&lt;code&gt;=end&lt;/code&gt;で終わる&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;リテラルはRubyソースコードに直接現れる値。数値、文字列、正規表現の3種類がある。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;識別子とは単純に名前のことである。Rubyは変数、メソッド、クラスなどに名前を与えるために識別子を使っている。&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id=&#34;識別子の中の記号類:5cf09527adc08d8c661f06f43d913565&#34;&gt;▼ 識別子の中の記号類&lt;/h4&gt;

&lt;p&gt;|記号|意味|
|===|===|
|$|グローバル変数にプレフィックスとして付ける。|
|@|インスタンス変数に付ける。クラス変数には２つつける|
|?|役に立つ慣習として、論理値を返すメソッドの末尾に疑問符を付ける|
|!|注意が必要なことを示すときに付ける|
|=|末尾が統合になっているメソッド式は、代入演算子のサ変で東道なしのメソッド名を置くだけで実行できる|&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Rubyの構文の基本単位は式である。Rubyインタープリタは式を評価して値を生成する。&lt;/p&gt;

&lt;p&gt;Rubyはオブジェクト指向なので、メソッドという言葉を使う。&lt;/p&gt;

&lt;p&gt;相互作用するように作られたメソッドのグループはクラスにまとめることができる。
そして、関連するクラスとクラスを持たないメソッドはモジュールにまとめることができる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【プログラミング言語Ruby】1章-イントロダクション</title>
      <link>http://kotazi.github.io/blog/post/2016/0210_ruby/</link>
      <pubDate>Thu, 11 Feb 2016 20:34:06 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0210_ruby/</guid>
      <description>&lt;p&gt;Rubyは完全なオブジェクト指向言語。
すべての値は、単純な数値リテラルやbooleanなども含めてオブジェクトである。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Rubyでは関数やメソッド軌道のための括弧が多くの場合省略可能である。
メソッド呼び出しで括弧が省略されているためオブジェクトの名前付きフィールドか名前付き変数のように見える。
オブジェクトの外からオブジェクトの内部状態にアクセスすることはできない、カプセル化については厳格な言語である。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;ブロックとイテレータは繰り返し処理でよく使われるが、
ブロックを一度しか実行しないメソッドでも役に立つ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;File.open(&amp;quot;data.txt&amp;quot;) do |f|
  line = f.readline
end
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;Rubyのメソッド名は疑問符や感嘆符で終わることもできる。
通常感嘆符のないメソッドは元のオブジェクトのコピーに変更を加えて返してくるが、
感嘆符付きのメソッドはオブジェクトをその場で書き換えるミューテータ(mutator)メソッドである。&lt;/p&gt;

&lt;p&gt;グローバル変数には&lt;code&gt;$&lt;/code&gt;、インスタンス変数には&lt;code&gt;@&lt;/code&gt;、クラス変数には&lt;code&gt;@@&lt;/code&gt;というプレフィックスをつける。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;クラスとはオブジェクトの状態を操作する関連メソッドのコレクションである。
オブジェクトの状態は、インスタンス変数によって管理されている。
インスタンス変数とは名前の先頭が&lt;code&gt;@&lt;/code&gt;で、オブジェクトごとに異なる値を持てる変数のことである。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【Flux】概要</title>
      <link>http://kotazi.github.io/blog/post/2016/0202_flux/</link>
      <pubDate>Tue, 09 Feb 2016 17:46:23 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0202_flux/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://facebook.github.io/flux/docs/overview.html#content&#34;&gt;Overview|Flux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;FluxはFacebookがクライアントサイドのWebアプリケーション構築の際に利用するアプリケーションのアーキテクチャです。
一定方向のデータフローを利用することでReactのビューコンポーネントの構成を補います。
Fluxはフレームワークというよりひとつのパターンなので、新しいコードを必要とすることなくいつでもFluxを使い始めることができます。&lt;/p&gt;

&lt;p&gt;Fluxアプリケーションには主要な3つのパーツがあります。ディスパッチャー、ストア、ビュー(Reactコンポーネント)です。
これらをMVCと混同すべきではありません。
コントローラはFluxアプリケーションの中にも存在します。
&lt;code&gt;controller-views&lt;/code&gt;-ビューはストアからデータを受け取るヒエラルキーのトップに位置し、受け取ったデータを子へと渡します。
加えて、アクションを生成する— dispatcher helper methods —はアプリケーション内で可能な変更を全て描画するセマンティックなAPIを
描画するサポートに利用します。
それらをFluxの更新サイクルにおける4番目のパートと考えると便利です。&lt;/p&gt;

&lt;p&gt;FluxではMVCを避けて一定方向のデータフローを支持しています。
あるユーザーがReactのビューに触れると、そのビューはアプリケーションのデータやロジックを保持した様々なストアへと、中央のディスパッチャーを介してアクションを広め、影響する全てのビューを更新します。
とりわけReactのプログラミングスタイルに良く働き、ステート間でのビューの遷移を細かく支持することなくストアが更新を送れるようになります。&lt;/p&gt;

&lt;p&gt;私たちは元々得られたデータを正しく扱います。例として、スレッドのリストを表示するビューに対して、メッセージスレッドの未読数を表示したかったとします。
MVCでは、単一のスレッドをマークし、スレッドモデルと未読数モデルを更新することは難しいです。
これらの依存関係やカスケードの更新は大規模なMVCアプリケーションでしばしば行われ、
データの流れをもつれさせ、予期せぬ結果をもたらします。&lt;/p&gt;

&lt;p&gt;ストアが制御をひっくり返します。ストアは外部の何かに更新を依存するのではなく、更新を受け入れ、適切に調和します。
内部でのデータの管理方法をストアに留めれば、心配事がなくなります。
ストアは&lt;code&gt;setAsRead()&lt;/code&gt;といった直接的なセッターメソッドを持ちませんが、代わりに自身のコンテナに新しいデータを取得する手段をもっています。
そのコールバックをディスパッチャーとともに登録します。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;structure-and-data-flow:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Structure and Data Flow&lt;/h3&gt;

&lt;p&gt;Fluxアプリケーションのデータの流れは一方向です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一方高のデータの流れはFluxアプリケーションの基本であり、上図はFluxプログラマーにとって主要なメンタルモデルとなります。
ディスパッチャー、ストア、ビューは入力と出力をもった独立したノードです。
アクションは新データと&lt;code&gt;type&lt;/code&gt;プロパティをもった単純なオブジェクトです。&lt;/p&gt;

&lt;p&gt;ビューはユーザーインタラクションが起こるとシステムを通して新しいアクションを伝播します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ディスパッチャーを介した全てのデータフローはセントラルハブとなります。
ディスパッチャーに提供されるアクションは、ユーザーのインタラクションをきっかけに、たいていはアクション生成メソッドから始まります。
そしてディスパッチャーはストアに登録されたコールバックを発動し、アクションを全てのストアに伝えます。
登録されたコールバック内では、ストアの保持しているステートに関連している全てのアクションに反応します。
そしてストアはデータレイヤーが引き起こした変更のイベントをcontroller-viewsに送信します。
controller-viewsはこれらのイベントをキャッチし、イベントハンドラ内でストアからデータを受け取ります。
controller-viewsは自身の&lt;code&gt;setState()&lt;/code&gt;メソッドを呼び出し、自身と全ての子孫を再度レンダリングします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-explained-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;この構造によって、関数型リアクティブプログラミング(FRP)、データフロープログラミング(DFP)、フローベースプログラミング(FBP)の理解が容易になり、アプリケーション内のデータの流れが一方向になります。(これは2wayバインディングとは異なります。)
アプリケーションのステートはストア内のみに保たれ、アプリケーションの異なる部分をしっかりと分離させることができます。
ストア間での依存関係は、ヒエラルキーにより厳格に保たれ、ディスパッチャーによって更新が同期されます。&lt;/p&gt;

&lt;p&gt;2wayデータバインディングではあるオブジェクトが変更されると他のオブジェクトも変更され、たくさんの更新がトリガされます。
アプリケーションが大きくなると、ユーザのインタラクションによって引き起こされる結果として何が変更されるかを予測することが非常に難しくなってシまいます。
シングルラウンド内でデータの変更ができれば、システム全体を予測しやすくなります。&lt;/p&gt;

&lt;p&gt;Fluxの様々な部分を見ていきましょう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;a-single-dispatcher:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;A Single Dispatcher&lt;/h3&gt;

&lt;p&gt;Fluxアプリケーションではディスパッチャーがセントラルハブであり、全てのデータの流れを管理します。
ストアにコールバックを登録することが本質的なところであり、ディスパッチャー自身が実際に知性を持っているわけではありません。
ストアにアクションを割り当てるためのシンプルなmechanismです。
各ストアは自身を登録し、コールバックを提供します。
アクションクリエータが新しいアクションを持ったディスパッチャーを登録すると、アプリケーション内の登録されたすべてのストアがコールバックを通してアクションを受け取ります。&lt;/p&gt;

&lt;p&gt;アプリケーションが大きくなると、ディスパッチャーはより活発になり、明確な順番で登録されたコールバックを呼び出すため、ストア間の依存関係を管理するために役立ちます。
ストアは他のストアの更新を待ち、そのあとに自身を更新します。&lt;/p&gt;

&lt;p&gt;npmやbowerからFacebookが実際の本番環境で使用しているディスパッチャーが利用可能です。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;stores:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Stores&lt;/h3&gt;

&lt;p&gt;ストアにはアプリケーションのステートとロジックが含まれます。
ストアの役割は伝統的なMVCにおけるモデルに似ていますが、ストアはたくさんのオブジェクトのステートを管理します。(ORMのようなシングルレコードを表すわけではありません。)
Backboneのコレクションとも違います。
ORMスタイルのコレクションをよりシンプルに管理するもので、ストアはアプリケーション内で特定のドメインのためのアプリケーションステートを管理します。&lt;/p&gt;

&lt;p&gt;例としてFacebookのLookback Video Editorは&amp;rdquo;TimeStore&amp;rdquo;を利用して、プレイバックタイムの位置とステートのトラックを保ちます。
一方で、同アプリケーションの&amp;rdquo;ImageStore&amp;rdquo;はToDoリストの管理に似ています。ストアはモデルのコレクションとシングルトンとしての特徴を持ち合わせています。&lt;/p&gt;

&lt;p&gt;上記で言及したように、ストアは自身にディスパッチャーを登録し、コールバックをもったディスパッチャーを提供します。
このコールバックはアクションをparameterとして受け取ります。
ストアに登録されたコールバックの内部では、アクションタイプに基づいたステートのスイッチはアクションを解釈し、固有のフックをストア内部のメソッドに提供するために使われます。
こうしてアクションはディスパッチャーを介してストアのステートを更新します。
ストアが更新された後、ステートが変更されたことを宣言するイベントをブロードキャストします。
そしてビューがステートと更新を確認します。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;views-and-controller-views:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Views and Controller-Views&lt;/h3&gt;

&lt;p&gt;Reactは私たちがビューレイヤーに必要としていた構成可能かつ自由で再レンダリングが可能なビューを提供します。
ビューヒエラルキーのトップに位置するビューは依存するストアにブロードキャストされたイベントを受け取る特別なビューです。
これらをcontroller-viewと呼び、ストアからデータを取得し、取得したデータを子孫に渡すようなグルーコードを提供します。&lt;/p&gt;

&lt;p&gt;controller-viewがストアからイベントを受け取ると、ストアのゲッターメソッドを通して必要な新しいデータを要求します。
自身の&lt;code&gt;setState()&lt;/code&gt;もしくは&lt;code&gt;forceUpdate()&lt;/code&gt;関数を呼び出し、自身の&lt;code&gt;render()&lt;/code&gt;メソッドと、子孫の&lt;code&gt;render()&lt;/code&gt;メソッドを引き起こします。&lt;/p&gt;

&lt;p&gt;シングルオブジェクト内のストアの全体のステートを子のビューに下ろすことで、異なる子孫が使えるようになります。
トップ階層でコントローラのような振る舞いを保つことで、このビューを機能的に保つことが可能になり、管理しなければならないプロパティの数を減らすことができます。&lt;/p&gt;

&lt;p&gt;時々、コンポーネントをシンプルに保つために、追加でcontroller-viewsを付け足す必要が出てくるかもしれません。
特定のデータドメインに関連するセクションのヒエラルキーを要約することに役立ちます。
しかし、controller-viewsを深くすることで一方向のデータフローを破ってしまう可能性があることに注意してください。
controller-viewを深い位置に追加するのであれば、異なる点でのヒエラルキーにおいてシンプルなコンポーネントとデータ更新のフローの複雑性にバランスをとってください。
こういった複雑なデータの更新は、Reactのレンダリングメソッドを繰り返し発動させてしまう恐れがあり、潜在的にデバッグを難しくしてしまいます。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;actions:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Actions&lt;/h3&gt;

&lt;p&gt;ディスパッチャーはストアとデータに対してのディスパッチをトリガするメソッドを提供し、
アクションの生成はディスパッチャーにアクションを送るセマンティックなヘルパーメソッドにラップされます。
例えば、ToDoリストアプリケーションのToDoアイテムのテキストを変更したかったとします。
&lt;code&gt;TodoActions&lt;/code&gt;モジュール内で&lt;code&gt;updateText(todoId, newText)&lt;/code&gt;関数を生成します。
このメソッドはビューのイベントハンドラから呼び出され、ユーザーインタラクションによって呼び出すことができます。
このアクションを生成するメソッドはアクションに&lt;code&gt;type&lt;/code&gt;を持たせるため、ストア内で解釈され、適切に反応することができます。
例として、&lt;code&gt;type&lt;/code&gt;を&lt;code&gt;TODO_UPDATE_TEXT&lt;/code&gt;のように名づけます。&lt;/p&gt;

&lt;p&gt;アクションはサーバーなど別の場所から来ることもあるかもしれません。
例えば、データ初期化時などにおこります。
サーバーがエラーコードを返した時や、アプリケーションをアップデートしたときに起こります。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;what-about-that-dispatcher:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;What About that Dispatcher?&lt;/h3&gt;

&lt;p&gt;以前に言及したように、ディスパッチャーはストア間の依存関係を管理します。
ディスパッチャークラスの&lt;code&gt;waitFor()&lt;/code&gt;関数を通して利用可能です。
極めてシンプルなTodoアプリなどで使用する必要はありませんが、より複雑で大きなアプリケーションでは活発になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TodoStore&lt;/code&gt;に登録されたコールバックが他の依存関係の更新を待っている様子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case &#39;TODO_CREATE&#39;:
  Dispatcher.waitFor([
    PrependedTextStore.dispatchToken,
    YetAnotherStore.dispatchToken
  ]);

  TodoStore.create(PrependedTextStore.getText() + &#39; &#39; + action.text);
  break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;waitFor()&lt;/code&gt;は登録したディスパッチャーの配列を一つ引数として受け、&lt;code&gt;dispatch token&lt;/code&gt;と呼ばれます。
このように&lt;code&gt;waitFor()&lt;/code&gt;を発動するストアはどのように自身のステートを更新するかを通知するために別のストアのステートに依存します。&lt;/p&gt;

&lt;p&gt;ディスパッチャーのコールバックが登録された時に&lt;code&gt;register()&lt;/code&gt;が&lt;code&gt;dispatch token&lt;/code&gt;を返します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PrependedTextStore.dispatchToken = Dispatcher.register(function (payload) {
  // ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;より&lt;code&gt;waitFor()&lt;/code&gt;やアクションクリエータ、ディスパッチャーについてしりたければ&lt;a href=&#34;http://facebook.github.io/react/blog/2014/07/30/flux-actions-and-the-dispatcher.html&#34;&gt;こちら&lt;/a&gt;です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【Angular】ユニットテスト</title>
      <link>http://kotazi.github.io/blog/post/2016/0202_angular_unit/</link>
      <pubDate>Mon, 08 Feb 2016 18:45:53 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0202_angular_unit/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.angularjs.org/guide/unit-testing&#34;&gt;Unit Testing|AngularJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;JavaScriptは強い式の力を持った動的型付け言語であり、コンパイラの助けを得ることがない。
そのため、JavaScriptのコードにはしっかりしたテストが必要である。
Angularには、Angularアプリケーションのテストを用意にするための機能がたくさん組み込まれている。
Angularにおいて、テストをしないということはありえない。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;separation-of-concerns:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Separation of Concerns&lt;/h3&gt;

&lt;p&gt;ユニットテストという名前から示されるように、これは独立した単体のコードのテストのことである。
ユニットテストは「そのロジックは正しく動くだろうか」、「ソート関数が並び替えたリストは正しい順番だろうか」
といった質問に回答しようとするものだ。&lt;/p&gt;

&lt;p&gt;テストにおいてこのような質問に答えるためには、単体のコードを孤立させることがとても重要である。
ソート関数のテストをしている時に、関連するDOM要素を生成したり、ソートデータをフェッチするためにXHRを呼び出すといったことをしたくないため。&lt;/p&gt;

&lt;p&gt;これは明らかなことなのに、典型的なプロジェクトでは独立した関数を呼び出すことはとてもむずかしい。
これは開発者がしばしば全てのことをするコードを混合させてしまうことに原因があり、
XHRを生成するもの、受け取ったデータをソートするもの、そしてDOMを操作するもの、である。&lt;/p&gt;

&lt;p&gt;Angularを用いて、あなたが正しくことを行うことを簡単にした。
XHRのために依存性注入を提供するので、リクエストをシミュレーションすることが可能になり、
レスポンスデータをソートすることができ、DOMを操作することができる。
DOMを生成したり、状態を監視したりXHRリクエストのレスポンスデータを待ったりすることなく、
データのソートをテストすることができる。
単独のソート関数を分離してテストすることができる。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;with-great-power-comes-great-responsibility:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;With great power comes great responsibility&lt;/h3&gt;

&lt;p&gt;Angularはテストしやすいことを念頭に書かれているが、それでもまだ
正しい書き方をする必要がある。
書き方が簡単になるよう努めたものの、ガイドラインを無視すれば
アンテスタブルなアプリケーションになってしまう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;dependency-injection:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Dependency Injection&lt;/h3&gt;

&lt;p&gt;Angularは&lt;a href=&#34;https://docs.angularjs.org/guide/di&#34;&gt;依存性注入&lt;/a&gt;のビルトインからなっており、
それはテストのコンポーネント化するため、思いどおりにコンポーネント間での依存関係やスタブ、モックをテストすることが可能。&lt;/p&gt;

&lt;p&gt;コンポーネントに依存性注入をすればテストのモックが簡単になり、
グローバル汚染もなくなりうっかり別のテストに影響してしまうこともなくなる。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;additional-tools-for-testing-angular-applications:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Additional tools for testing Angular applications&lt;/h3&gt;

&lt;p&gt;Angularアプリケーションのテストでは、テストをより簡単にセットアップし実行するために使うべきツールがある。&lt;/p&gt;

&lt;h4 id=&#34;karma:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Karma&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://karma-runner.github.io/&#34;&gt;Karma&lt;/a&gt;はコマンドラインツールである。
アプリケーションのコードを読み込み、実行するWebサーバーを用意する。
アプリケーションがサポートする全てのブラウザにで操作することをテストするために、ブラウザの数分に対してKarmaを実行するように設定することができる。
Karmaをコマンドライン上で実行すると、ブラウザでのテスト実行結果をコマンドライン上にすぐに表示する。&lt;/p&gt;

&lt;p&gt;KarmaはNodeJS製のアプリケーションであり、npmでインストールする。
インストールガイドについては&lt;a href=&#34;http://karma-runner.github.io/0.12/intro/installation.html&#34;&gt;Karmaのサイト&lt;/a&gt;が役に立つ。&lt;/p&gt;

&lt;h4 id=&#34;jasmine:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Jasmine&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html&#34;&gt;Jasmin&lt;/a&gt;はビヘイビア駆動開発のJavaScriptフレームワークであり、
Angularアプリケーションをテストするうえで最も人気のフレームワークである。
テストに構造をもたせ、アサーションを作成するための関数を提供する。
テストが大きくなっても構造的であり、ドキュメント性を保ちながら、アーカイブしてく。&lt;/p&gt;

&lt;p&gt;テストをグループ化するためには&lt;code&gt;describe&lt;/code&gt;を利用する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&amp;quot;sorting the list of users&amp;quot;, function() {
  // individual tests go here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;個々のテストは&lt;code&gt;it&lt;/code&gt;関数の中に定義される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;sorting the list of users&#39;, function() {
  it(&#39;sorts in descending order by default&#39;, function() {
    // your test assertion goes here
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関連するテストを&lt;code&gt;describe&lt;/code&gt;ブロックでグルーピングし、個々のテストは&lt;code&gt;it&lt;/code&gt;関数内に記述することで
テストをドキュメントとして保ち続けることが可能になる。&lt;/p&gt;

&lt;p&gt;最後に、Jasmineは作成するアサーションのマッチャーを提供する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;sorting the list of users&#39;, function() {
  it(&#39;sorts in descending order by default&#39;, function() {
    var users = [&#39;jack&#39;, &#39;igor&#39;, &#39;jeff&#39;];
    var sorted = sortUsers(users);
    expect(sorted).toEqual([&#39;jeff&#39;, &#39;jack&#39;, &#39;igor&#39;]);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jasminは様々なアサーションを作成するためのたくさんのマッチャーから成っている。
マッチャーについては&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html#section-Matchers&#34;&gt;こちらの記事&lt;/a&gt;を読むこと。
KarmaとJasminを使うために、&lt;a href=&#34;https://github.com/karma-runner/karma-jasmine&#34;&gt;karma-jasmin&lt;/a&gt;を利用する。&lt;/p&gt;

&lt;h4 id=&#34;angular-mocks:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;angular-mocks&lt;/h4&gt;

&lt;p&gt;Angularはテスト用のモックを提供する&lt;code&gt;ngMock&lt;/code&gt;というものを用意している。
ユニットテスト内でのAngularサービスをモックしたりインジェクトするために用いられる。
加えて、別のモジュールを拡張できるので、同期的だ。
テストを同期することで明確に保ち、簡単に動作させることができる。
もっとも便利なうちのひとつが&lt;code&gt;$httpBackend&lt;/code&gt;だ。
テストでXHRリクエストのモックを行うことができ、代わりにサンプルのデータを返す。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-a-controller:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing a Controller&lt;/h3&gt;

&lt;p&gt;Angularのビューレイヤーはロジックから切り離されているので、コントローラを簡単にテストすることができる。
下記でコントローラをどのようにテストしているか見ていこう。
パスワードの長さに基づいてスコープのプロパティをセットする&lt;code&gt;$scope.grade&lt;/code&gt;を提供している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.module(&#39;app&#39;, [])
.controller(&#39;PasswordController&#39;, function PasswordController($scope) {
  $scope.password = &#39;&#39;;
  $scope.grade = function() {
    var size = $scope.password.length;
    if (size &amp;gt; 8) {
      $scope.strength = &#39;strong&#39;;
    } else if (size &amp;gt; 3) {
      $scope.strength = &#39;medium&#39;;
    } else {
      $scope.strength = &#39;weak&#39;;
    }
  };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コントローラはグローバルスコープでは利用できないため、
はじめに&lt;code&gt;angular.mock.inject&lt;/code&gt;を使ってコントローラをインジェクトする必要がある。
最初のステップは、angular-mocksが提供する&lt;code&gt;module&lt;/code&gt;関数を使うことだ。
この関数は与えられたモジュールを読み込み、読み込まれたモジュールはテスト内で利用う可能となる。
これをJasminの提供する関数であり、各テストの前にコードを実行できる&lt;code&gt;beforeEach&lt;/code&gt;に渡す。
そしてコントローラのインスタンス化に責任を持つサービス&lt;code&gt;$controller&lt;/code&gt;にアクセスするために&lt;code&gt;inject&lt;/code&gt;を用いる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ネストした&lt;code&gt;describe&lt;/code&gt;の呼び出しや、文字列を用いて呼び出す時の描写でテストが明確になっていることに注目する。
何をテストしているかハッキリと記し、何が起きているかを簡単に理解できる。
では3文字以下のパスワードを追加して、&lt;code&gt;$scope.strength&lt;/code&gt;が&amp;rdquo;weak&amp;rdquo;であるか見ていこう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });

    it(&#39;sets the strength to &amp;quot;weak&amp;quot; if the password length &amp;lt;3 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;a&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;weak&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在２つのテストがあるが、テストが重複していることに気付いて欲しい。
両方で&lt;code&gt;$scope&lt;/code&gt;を作成しており、コントローラを生成している。
テストを重複するならこの重複は良くない。
ありがたいことにJasminには&lt;code&gt;beforeEach&lt;/code&gt;がある。
個々のテストの前に関数を実行してくれる。
どのようにテストをセットするか確認しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    var $scope, controller;

    beforeEach(function() {
      $scope = {};
      controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
    });

    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });

    it(&#39;sets the strength to &amp;quot;weak&amp;quot; if the password length &amp;lt;3 chars&#39;, function() {
      $scope.password = &#39;a&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;weak&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重複部分を外へ出し、&lt;code&gt;beforeEach&lt;/code&gt;ブロックへ移動した。
これで個々のテストには特有のコードだけになり、全体に入っているようなコードはなくなった。
テストを拡張するうえで、テストをきちんとするためにどこで&lt;code&gt;beforeEach&lt;/code&gt;を使えるか目を見張ることだ。
Jasminが提供するのは&lt;code&gt;beforeEach&lt;/code&gt;だけじゃない。&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html#section-Setup_and_Teardown&#34;&gt;こちら&lt;/a&gt;も見てみること。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-filters:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Filters&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.angularjs.org/api/ng/provider/$filterProvider&#34;&gt;フィルタ&lt;/a&gt;はデータをユーザが読みやすいフォーマットに変換する。
これはフォーマットの責任をアプリケーションロジックから取り除くことになるのでとても重要なこと。さらにはアプリケーションロジックを単純にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myModule.filter(&#39;length&#39;, function() {
  return function(text) {
    return (&#39;&#39; + (text || &#39;&#39;)).length;
  }
});

describe(&#39;length filter&#39;, function() {

  var $filter;

  beforeEach(inject(function(_$filter_){
    $filter = _$filter_;
  }));

  it(&#39;returns 0 when given null&#39;, function() {
    var length = $filter(&#39;length&#39;);
    expect(length(null)).toEqual(0);
  });

  it(&#39;returns the correct value when given a string of chars&#39;, function() {
    var length = $filter(&#39;length&#39;);
    expect(length(&#39;abc&#39;)).toEqual(3);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-directives:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Directives&lt;/h3&gt;

&lt;p&gt;AngularのディレクティブはカスタムHTMLタグや属性、クラス、コメントと複雑な機能に責任を持っている。
ディレクティブを使って生成したコンポーネントがさまざまな背景で思った通りに使われているかのテストになるので、
ディレクティブのユニットテストはとても重要です。&lt;/p&gt;

&lt;h4 id=&#34;simple-html-element-directive:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Simple HTML Element Directive&lt;/h4&gt;

&lt;p&gt;依存関係のないAngularアプリで始める。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = angular.module(&#39;myApp&#39;, []);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アプリにディレクティブを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.directive(&#39;aGreatEye&#39;, function () {
    return {
        restrict: &#39;E&#39;,
        replace: true,
        template: &#39;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&#39;
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&lt;/code&gt;といったタグでこのディレクティブは利用する。
タグごと&lt;code&gt;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&lt;/code&gt;テンプレートを置き換えるものだ。
その機能を確認するためのJasminテストを書いていく。
レンダリングされると&lt;code&gt;{{1 + 1}}&lt;/code&gt;式が評価されることに注意する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;Unit testing great quotes&#39;, function() {
  var $compile,
      $rootScope;

  // ディレクティブを含んだmyAppモジュールを読み込む
  beforeEach(module(&#39;myApp&#39;));

  // $rootScopeと$compileへの参照を保持する
  // このdescribeブロックにおいて全てのテストで利用可能になる
  beforeEach(inject(function(_$compile_, _$rootScope_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $compile = _$compile_;
    $rootScope = _$rootScope_;
  }));

  it(&#39;Replaces the element with the appropriate content&#39;, function() {
    // ディレクティブのHTMLをコンパイルする
    var element = $compile(&amp;quot;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&amp;quot;)($rootScope);
    // ウォッチャーを発火させ、式を評価する
    $rootScope.$digest();
    // コンパイルされた要素がテンプレートの中身を含んでいることを確認する
    expect(element.html()).toContain(&amp;quot;lidless, wreathed in flame, 2 times&amp;quot;);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$compile&lt;/code&gt;サービスと&lt;code&gt;$rootScope&lt;/code&gt;をJasminテストの前にインジェクトする。
&lt;code&gt;$compile&lt;/code&gt;サービスはaGreatEyeディレクティブをレンダリングするために利用する。
レンダリング後に、&amp;rdquo;lidless, wreathed in flame, 2 times&amp;rdquo;は現れる。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Underscore notation:&lt;/strong&gt; &lt;code&gt;_$rootScope_&lt;/code&gt;といったアンダースコアの使い方は、テスト内での変数名をきれいに保つためAngularJSコミュニティ内で広く広がった風習である。
パラメータがマッチングした際に、&lt;code&gt;$injector&lt;/code&gt;がアンダースコアを取り払うのはこれが理由である。
このアンダースコアルールが働くのは名前が一つのアンダースコアで始まり一つのアンダースコアで終わる時のみに限られ、それ以外での置換は起こらない。&lt;/p&gt;

&lt;h4 id=&#34;testing-transclusion-directives:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Transclusion Directives&lt;/h4&gt;

&lt;p&gt;トランスクルージョンを使ったディレクティブはコンパイラに特別に扱われる。
コンパイル関数が呼び出される前に、ディレクティブ要素のコンテンツは取り除かれ、トランスクルージョン関数を通して提供される。
ディレクティブのテンプレートはその際に、ディレクティブ要素に追加され、トランスクルードされたコンテンツをテンプレート内に挿入する。&lt;/p&gt;

&lt;p&gt;コンピレーション前:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;
  Some transcluded content
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トランスクルージョンが引き抜かれる:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンピレーション後:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;
  Some Template
  &amp;lt;span ng-transclude&amp;gt;Some transcluded content&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ディレクティブが&amp;rdquo;要素&amp;rdquo;のトランスクルージョンを利用しているのであれば、コンパイラは実質的にDOMからディレクティブ全体の要素を取り除き、
コメントノードを持ってそれを置き換える。
そしてコンパイラはディレクティブのテンプレートをコメントノードの&lt;strong&gt;後に&lt;/strong&gt;、兄弟として挿入する。&lt;/p&gt;

&lt;p&gt;コンピレーション前:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div element-transclude&amp;gt;
  Some Content
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トランスクルージョンが引き抜かれる:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- elementTransclude --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンピレーション後:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- elementTransclude --&amp;gt;
&amp;lt;div element-transclude&amp;gt;
  Some Template
  &amp;lt;span ng-transclude&amp;gt;Some transcluded content&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要素のトランスクルージョンを使ったディレクティブのテストを書いている時に、このことに気づくことが重要。
もし&lt;code&gt;$compile&lt;/code&gt;へ渡すDOMフラグメントのルート要素にディレクティブを置くのであれば、関連する関数から返されるDOMノードはコメントノードであり、テンプレートとトランスクルードされたコンテンツを繋ぐ能力には負けるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var node = $compile(&#39;&amp;lt;div element-transclude&amp;gt;&amp;lt;/div&amp;gt;&#39;)($rootScope);
expect(node[0].nodeType).toEqual(node.COMMENT_NODE);
expect(node[1]).toBeUndefined();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに対処するためには単純に要素をトランスクルードするディレクティブを&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;のようなエレメントでラップする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var node = $compile(&#39;&amp;lt;div&amp;gt;&amp;lt;div element-transclude&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&#39;)($rootScope);
var contents = node.contents();
expect(contents[0].nodeType).toEqual(node.COMMENT_NODE);
expect(contents[1].nodeType).toEqual(node.ELEMENT_NODE);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;testing-directives-with-external-templates:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Directives With External Templates&lt;/h4&gt;

&lt;p&gt;もぢディレクティブで&lt;code&gt;templateUrl&lt;/code&gt;を使っているのであれば、HTMLテンプレートをプリコンパイルするために&lt;a href=&#34;https://github.com/karma-runner/karma-ng-html2js-preprocessor&#34;&gt;karma-ng-html2js-preprocessor&lt;/a&gt;を使うことを考え、HTTPリクエストを使ってテキストをロードすることは避けること。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>