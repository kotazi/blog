<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on kotazi.com</title>
    <link>http://kotazi.github.io/blog/tags/react/</link>
    <description>Recent content in React on kotazi.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Feb 2016 17:46:23 +0900</lastBuildDate>
    
	<atom:link href="http://kotazi.github.io/blog/tags/react/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【Flux】概要</title>
      <link>http://kotazi.github.io/blog/post/2016/0202_flux/</link>
      <pubDate>Tue, 09 Feb 2016 17:46:23 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0202_flux/</guid>
      <description>Overview|Flux   FluxはFacebookがクライアントサイドのWebアプリケーション構築の際に利用するアプリケーションのアーキテクチャです。 一定方向のデータフローを利用することでReactのビューコンポーネントの構成を補います。 Fluxはフレームワークというよりひとつのパターンなので、新しいコードを必要とすることなくいつでもFluxを使い始めることができます。
Fluxアプリケーションには主要な3つのパーツがあります。ディスパッチャー、ストア、ビュー(Reactコンポーネント)です。 これらをMVCと混同すべきではありません。 コントローラはFluxアプリケーションの中にも存在します。 controller-views-ビューはストアからデータを受け取るヒエラルキーのトップに位置し、受け取ったデータを子へと渡します。 加えて、アクションを生成する— dispatcher helper methods —はアプリケーション内で可能な変更を全て描画するセマンティックなAPIを 描画するサポートに利用します。 それらをFluxの更新サイクルにおける4番目のパートと考えると便利です。
FluxではMVCを避けて一定方向のデータフローを支持しています。 あるユーザーがReactのビューに触れると、そのビューはアプリケーションのデータやロジックを保持した様々なストアへと、中央のディスパッチャーを介してアクションを広め、影響する全てのビューを更新します。 とりわけReactのプログラミングスタイルに良く働き、ステート間でのビューの遷移を細かく支持することなくストアが更新を送れるようになります。
私たちは元々得られたデータを正しく扱います。例として、スレッドのリストを表示するビューに対して、メッセージスレッドの未読数を表示したかったとします。 MVCでは、単一のスレッドをマークし、スレッドモデルと未読数モデルを更新することは難しいです。 これらの依存関係やカスケードの更新は大規模なMVCアプリケーションでしばしば行われ、 データの流れをもつれさせ、予期せぬ結果をもたらします。
ストアが制御をひっくり返します。ストアは外部の何かに更新を依存するのではなく、更新を受け入れ、適切に調和します。 内部でのデータの管理方法をストアに留めれば、心配事がなくなります。 ストアはsetAsRead()といった直接的なセッターメソッドを持ちませんが、代わりに自身のコンテナに新しいデータを取得する手段をもっています。 そのコールバックをディスパッチャーとともに登録します。
 Structure and Data Flow Fluxアプリケーションのデータの流れは一方向です。
一方高のデータの流れはFluxアプリケーションの基本であり、上図はFluxプログラマーにとって主要なメンタルモデルとなります。 ディスパッチャー、ストア、ビューは入力と出力をもった独立したノードです。 アクションは新データとtypeプロパティをもった単純なオブジェクトです。
ビューはユーザーインタラクションが起こるとシステムを通して新しいアクションを伝播します。
ディスパッチャーを介した全てのデータフローはセントラルハブとなります。 ディスパッチャーに提供されるアクションは、ユーザーのインタラクションをきっかけに、たいていはアクション生成メソッドから始まります。 そしてディスパッチャーはストアに登録されたコールバックを発動し、アクションを全てのストアに伝えます。 登録されたコールバック内では、ストアの保持しているステートに関連している全てのアクションに反応します。 そしてストアはデータレイヤーが引き起こした変更のイベントをcontroller-viewsに送信します。 controller-viewsはこれらのイベントをキャッチし、イベントハンドラ内でストアからデータを受け取ります。 controller-viewsは自身のsetState()メソッドを呼び出し、自身と全ての子孫を再度レンダリングします。
この構造によって、関数型リアクティブプログラミング(FRP)、データフロープログラミング(DFP)、フローベースプログラミング(FBP)の理解が容易になり、アプリケーション内のデータの流れが一方向になります。(これは2wayバインディングとは異なります。) アプリケーションのステートはストア内のみに保たれ、アプリケーションの異なる部分をしっかりと分離させることができます。 ストア間での依存関係は、ヒエラルキーにより厳格に保たれ、ディスパッチャーによって更新が同期されます。
2wayデータバインディングではあるオブジェクトが変更されると他のオブジェクトも変更され、たくさんの更新がトリガされます。 アプリケーションが大きくなると、ユーザのインタラクションによって引き起こされる結果として何が変更されるかを予測することが非常に難しくなってシまいます。 シングルラウンド内でデータの変更ができれば、システム全体を予測しやすくなります。
Fluxの様々な部分を見ていきましょう。
 A Single Dispatcher Fluxアプリケーションではディスパッチャーがセントラルハブであり、全てのデータの流れを管理します。 ストアにコールバックを登録することが本質的なところであり、ディスパッチャー自身が実際に知性を持っているわけではありません。 ストアにアクションを割り当てるためのシンプルなmechanismです。 各ストアは自身を登録し、コールバックを提供します。 アクションクリエータが新しいアクションを持ったディスパッチャーを登録すると、アプリケーション内の登録されたすべてのストアがコールバックを通してアクションを受け取ります。
アプリケーションが大きくなると、ディスパッチャーはより活発になり、明確な順番で登録されたコールバックを呼び出すため、ストア間の依存関係を管理するために役立ちます。 ストアは他のストアの更新を待ち、そのあとに自身を更新します。
npmやbowerからFacebookが実際の本番環境で使用しているディスパッチャーが利用可能です。
 Stores ストアにはアプリケーションのステートとロジックが含まれます。 ストアの役割は伝統的なMVCにおけるモデルに似ていますが、ストアはたくさんのオブジェクトのステートを管理します。(ORMのようなシングルレコードを表すわけではありません。) Backboneのコレクションとも違います。 ORMスタイルのコレクションをよりシンプルに管理するもので、ストアはアプリケーション内で特定のドメインのためのアプリケーションステートを管理します。</description>
    </item>
    
    <item>
      <title>ES6とReact試してみた</title>
      <link>http://kotazi.github.io/blog/post/2016/0130_react_calendar/</link>
      <pubDate>Mon, 01 Feb 2016 12:06:51 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0130_react_calendar/</guid>
      <description>FullCalendarとReactとES6を使ったサンプルを作ってみた。
jQueryとReactは相性が悪いと聞いていたが、特に感じられなかった。
See the Pen FullCalendar With React ES6 by Kohei Saeki (@kotazi) on CodePen.</description>
    </item>
    
    <item>
      <title>【訳読】React Tutorial</title>
      <link>http://kotazi.github.io/blog/post/2016/0128_react/</link>
      <pubDate>Thu, 28 Jan 2016 23:08:28 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0128_react/</guid>
      <description>勉強がてらReactチュートリアルを翻訳しました。
 Tutorial シンプルではあるものの、ブログに書ける現実的なコメントボックスを実装していく。 この基本バージョンのリアルタイムコメントはDisqusやLibeFyre、Facebook commentsにオファーをいただいた。
提供する機能:
 全てのコメントのView コメントを送信するためのフォーム バックエンドをカスタムするためのHook  
またこれらの機能もしっかり備えている。
 オプティミスティックコメント: サーバーに保存される前にコメントが表示されるため非常に速い ライブアップデート: 他者のコメントがリアルタイムで反映される Markdown対応: Markdownによる記述が可能   Want to skip all this and just see the source?  GitHub   Running a server チュートリアルを開始するためには、稼働しているサーバーが必要。 あくまでデータの取得と保存に使用するAPIエンドポイントとしてのサーバーだ。
できるだけ簡単にするため、仕様を実現するシンプルなサーバーをいくつかのスクリプト言語で用意した。 開始に必要なものはこちらからインストール可能。
簡潔にするために、実行するサーバーはJSONファイルをデータベースとして利用する。 本番でこんなことはしないが、APIを用いたシュミレーションを行うには簡単でいいだろう。 一度サーバーを起動したら、APIエンドポイントをサポートし、必要なスタティックペーシを出してくれる。
 Getting started このチュートリアルでは、できるだけ簡単なものにしていくつもりである。 サーバーパッケージの中に私たちが動かすHTMLファイルが含まれている。 public/index.htmlを好みのエディタで開いてみてほしい。このようになっているはずだ。
&amp;lt;!-- index.html --&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt; &amp;lt;title&amp;gt;React Tutorial&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.6/react.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.6/react-dom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;https://cdnjs.</description>
    </item>
    
  </channel>
</rss>