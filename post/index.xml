<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on kotazi.com</title>
    <link>http://kotazi.github.io/blog/post/</link>
    <description>Recent content in Posts on kotazi.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Feb 2016 11:40:44 +0900</lastBuildDate>
    <atom:link href="http://kotazi.github.io/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>【読書】ユーザーストーリーマッピング</title>
      <link>http://kotazi.github.io/blog/post/2016/0213_user_story/</link>
      <pubDate>Wed, 17 Feb 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0213_user_story/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4873117321/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4873117321&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;ユーザーストーリーマッピング&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4873117321&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;
を読みました。&lt;/p&gt;

&lt;p&gt;アジャイルUXの第一人者として活躍するジェフ・パットン氏の著書。&lt;br /&gt;
自身が開発した手法について書き下ろされら書籍。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://codezine.jp/article/detail/6404&#34;&gt;良いプロダクトを発見・具現化するために、チームはどう動くべきか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://daipresents.com/2011/jeff-patton%E6%B0%8F%E3%81%AE-%E6%83%85%E7%86%B1%E3%83%97%E3%83%AD%E3%83%80%E3%82%AF%E3%83%88%E3%82%AA%E3%83%BC%E3%83%8A%E3%83%BC%E3%82%B7%E3%83%83%E3%83%97-%E3%81%AB%E5%8F%82%E5%8A%A0%E3%81%97/&#34;&gt;Jeff Patton氏の “情熱プロダクトオーナーシップ” に参加しました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次:2179e5f5f3ee66c47dc4d32c38e661c1&#34;&gt;目次&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;0章 まず最初に読んでください&lt;/li&gt;
&lt;li&gt;1章 全体像&lt;/li&gt;
&lt;li&gt;2章 作るものを減らすためのプラン&lt;/li&gt;
&lt;li&gt;3章 より速く学ぶためのプラン&lt;/li&gt;
&lt;li&gt;4章 時間どおりに終わらせるためのプラン&lt;/li&gt;
&lt;li&gt;5章 あなたはもうやり方を知っている&lt;/li&gt;
&lt;li&gt;6章 ストーリーについての本当のストーリー&lt;/li&gt;
&lt;li&gt;7章 より良いストーリーテリングのために&lt;/li&gt;
&lt;li&gt;8章 カードに書かれていることが全てではない&lt;/li&gt;
&lt;li&gt;9章 カードは始まりにすぎない&lt;/li&gt;
&lt;li&gt;10章 ケーキのようにストーリーを焼く&lt;/li&gt;
&lt;li&gt;11章 岩を砕いていく&lt;/li&gt;
&lt;li&gt;12章 岩を砕く人&lt;/li&gt;
&lt;li&gt;13章 オポチュニティから始める&lt;/li&gt;
&lt;li&gt;14章 ディスカバリーを介して共通理解を築く&lt;/li&gt;
&lt;li&gt;15章 ディスカバリーによる検証された学習&lt;/li&gt;
&lt;li&gt;16章 リファイン、定義、構築&lt;/li&gt;
&lt;li&gt;17章 ストーリーは実際にはアステロイドに似ている&lt;/li&gt;
&lt;li&gt;18章 構築するすべてのものから学ぶ&lt;/li&gt;
&lt;li&gt;19章 終わり？それとも&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;多くの企業がアジャイルやリーンプロセスを取り入れる一環としてストーリーを取り入れている。
しかしその取組の中で、全体像を見失ってしまったり、何が作られているのか分からなくなってしまったり、
共通理解が得られなかったり。そういったチーム開発における悩みをユーザーストーリーマッピングを用いて紐解いていく本。&lt;/p&gt;

&lt;p&gt;ただ、この本の序文を&lt;a href=&#34;http://www.amazon.co.jp/Inspired-%E9%A1%A7%E5%AE%A2%E3%81%AE%E5%BF%83%E3%82%92%E6%8D%89%E3%81%88%E3%82%8B%E8%A3%BD%E5%93%81%E3%81%AE%E5%89%B5%E3%82%8A%E6%96%B9-%E3%83%9E%E3%83%BC%E3%83%86%E3%82%A3-%E3%82%B1%E3%82%A4%E3%82%AC%E3%83%B3-ebook/dp/B00TCM8TB4&#34;&gt;Inspired&lt;/a&gt;の著者マーティケーガンが執筆しており、
&lt;a href=&#34;http://www.amazon.co.jp/HARD-THINGS-%E7%AD%94%E3%81%88%E3%81%8C%E3%81%AA%E3%81%84%E9%9B%A3%E5%95%8F%E3%81%A8%E5%9B%B0%E9%9B%A3%E3%81%AB%E3%81%8D%E3%81%BF%E3%81%AF%E3%81%A9%E3%81%86%E7%AB%8B%E3%81%A1%E5%90%91%E3%81%8B%E3%81%86%E3%81%8B-%E3%83%99%E3%83%B3-%E3%83%9B%E3%83%AD%E3%82%A6%E3%82%A3%E3%83%83%E3%83%84-ebook/dp/B00W535LOU&#34;&gt;HARD THINGS&lt;/a&gt;の著者ベン・ホロヴィッツの
&lt;a href=&#34;https://a16z.files.wordpress.com/2014/08/good-product-manager.pdf&#34;&gt;Good Product Manager/Bad Product Manager&lt;/a&gt;
に倣い、強力な製品開発チームと非力なチームの重要な違いを挙げている。&lt;br /&gt;
それが面白かったので引用したい。&lt;/p&gt;

&lt;p&gt;優れたチームには、使命感といえるほどの情熱を持って追求したくなる圧倒的な魅力のあるビジョンがある。
ダメなチームは報酬しか考えない。&lt;/p&gt;

&lt;p&gt;優れたチームは、リアルな問題を解決するためにスコアカードKPI，顧客の苦闘の状況、顧客が製品を使った時に生成されるデータを良く見て、絶えず新技術を応用するチャンスを探しながら、ヒントやアイディアを掴んでいる。ダメなチームは営業や顧客から要件を集めてくる。&lt;/p&gt;

&lt;p&gt;優れたチームは、もっとも大切なステークホルダーが誰か、そのステークホルダーがどのような制約を抱えているのかを理解し、
ユーザーと顧客のために役立つだけでなく、ビジネスの制約の枠内で作れるソリューションを作り出すことに力を注いでいる。
ダメなチームは、ステークホルダーから要件を集めてくる。&lt;/p&gt;

&lt;p&gt;優れたチームは、そのアイディアが本当に構築に値するのか見極めるために、アイディアをすぐに試せるテクニックを習熟している。
ダメなチームは、優先順位を指定したロードマップを作るために会議を開く。&lt;/p&gt;

&lt;p&gt;優れたチームは、社内各部署の優秀なリーダーを集めたブレーンストーミングを積極的に行う。ダメなチームは、チーム外の誰かが提案してくれても反発する。&lt;/p&gt;

&lt;p&gt;優れたチームは、製品担当、デザイン担当、技術担当が隣同士に座り、機能、ユーザーエクスペリエンス、実現するためのテクノロジーにおける助け合いを推進している。ダメなチームは、それぞれの部門の席に座り、部門の外からのサービスの以来には、文書による以来や会議の日程調整を要求する。&lt;/p&gt;

&lt;p&gt;優れたチームは、イノベーションのためにいつでも新しいアイディアを試そうとするが、収益とブランドはきっちり守る。
ダメなチームはテストの実行許可を待ち続ける。&lt;/p&gt;

&lt;p&gt;優れたチームは、力のあるインタラクションデザインなど、勝てる商品を作るために必要なスキルセットの確保にこだわる。
ダメなチームは、インタラクションデザインがどのような仕事かさえ知らない。&lt;/p&gt;

&lt;p&gt;優れたチームは、エンジニアが毎日ディスカバリープロトタイプを試す時間を持っている。製品をよくするための意見も言える。
ダメなチームは、急ぎの案件の時だけ、見積書を作るためにエンジニアにプロトタイプを見せる。&lt;/p&gt;

&lt;p&gt;優れたチームは、顧客をよりよく理解し、最新のアイディアに対する顧客の反応を見るために毎週、顧客と直接議論する。
ダメなチームは、自分がお客さんだと思っている。&lt;/p&gt;

&lt;p&gt;優れたチームは、自分たちが気に入ったアイディアの多くが顧客の役に立たないことを知っており、役に立つかもしれないものでも、
望ましい成果を挙げるまでには、数回のイテレーションが必要であることを知っている。
ダメなチームは、ロードマップに載ったものを作り、納期と要件を満たしていれば満足してしまう。&lt;/p&gt;

&lt;p&gt;優れたチームは、スピードの重要性を知っていて、イノベーションで鍵を握るのがイテレーションの早さであることを理解している。
ここで言うスピードは、適切なテクニックによって得られるもので、時間労働のようなもので得られるものではないこともわかっている。
ダメなチームは、同僚が働いてくれないからペースが上がらないと不満を言う。&lt;/p&gt;

&lt;p&gt;優れたチームは、顧客からの要望をよく吟味し、顧客と自社の業績に貢献できそうなソリューションだと確信したら、
その実現のために力を注ぐ。
ダメなチームは、営業に振り回される会社だと文句を言う。&lt;/p&gt;

&lt;p&gt;優れたチームは、フィードバックの仕組みを作る。製品がどのように使われているかをすばやく知り、そのデータにもとづいて製品に調整を加える。
ダメなチームは、分析、レポート機能を、あると良い機能だと思っている。&lt;/p&gt;

&lt;p&gt;優れたチームは、コンスタントに小規模なリリースを重ねたほうが顧客に安定したソリューションを提供できることを知っている。
そのために継続的にインテグレーション、リリースを行う。ダメなチームは、苦痛に満ちたインテグレーションのフェーズの
最後にマニュアルでテストを行い、それからすべてをまとめてリリースをする。&lt;/p&gt;

&lt;p&gt;優れたチームは、重要な顧客のことで悩む。
ダメなチームは、競合他社のことで悩む。&lt;/p&gt;

&lt;p&gt;優れたチームは、ビジネスKPIに大きなインパクトを与えられたときに祝杯をあげる。
ダメなチームは、何かをリリース出来たときに祝杯をあげる。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;序文を引用したら長くなってしまった。
とにかく本著の内容は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ストーリーは、要件を形式に落としこむためのものではない。言葉と絵を使いながらストーリーを話すのは、共通理解を築くためのメカニズムだ。&lt;/li&gt;
&lt;li&gt;ストーリーは要件ではない。会社、顧客、ユーザーが抱える問題の解決についての議論であり、何を作るかについての意見を一致に導くものだ。&lt;/li&gt;
&lt;li&gt;あなたがしなければならないことは、より早くより多くのソフトウェアを作ることではない。作ると決めたものから最大限の成果とインパクトを生み出すことだ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということである。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;最後に、もっとも感動した一文。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「本当は、あなたの仕事は世界を変えることだ。」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;素晴らしいアイディアを製品に転化するのであれば、
それを使う人々の世界を少し、あるいは少なからず変えてしまうことになる。&lt;br /&gt;
実際にそうなっていなければ、あなたの取り組みは失敗なのだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】アルゴリズムが世界を支配する</title>
      <link>http://kotazi.github.io/blog/post/2016/0213_algorithm/</link>
      <pubDate>Tue, 16 Feb 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0213_algorithm/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/B00FMI2XIW/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00FMI2XIW&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;アルゴリズムが世界を支配する (角川ＥＰＵＢ選書)&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=B00FMI2XIW&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;
を読みました。&lt;/p&gt;

&lt;p&gt;オンラインスーパーマーケットAisle50の共同設立社、クリストファー・スタイナーの著書。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次:ede789d548135e377784ce81f1ae62ff&#34;&gt;目次&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;第1章 ドミノの最初の一牌目、ウォールストリート&lt;/li&gt;
&lt;li&gt;第2章 人類とアルゴリズムの歴史&lt;/li&gt;
&lt;li&gt;第3章 ボット トップ40&lt;/li&gt;
&lt;li&gt;第4章 ボットの秘密のハイウェイ&lt;/li&gt;
&lt;li&gt;第5章 システムをゲーム化しろ&lt;/li&gt;
&lt;li&gt;第6章 ドクター・ボットを呼べ&lt;/li&gt;
&lt;li&gt;第7章 人類をカテゴライズする&lt;/li&gt;
&lt;li&gt;第8章 ウォールストリート vs シリコンバレー&lt;/li&gt;
&lt;li&gt;第9章 ウォールストリートが損をすれば他のみんなは儲かる&lt;/li&gt;
&lt;li&gt;第10章 未来はアルゴリズムとそのクリエイターのもの&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;ここのところ機械学習やディープラーニングの話題をよく耳にするので買ってみた。&lt;/p&gt;

&lt;p&gt;読んでみると株式取引や音楽を自動生成するアルゴリズムなどがかなり昔から存在することを知った。
近年ではポーカーや医療の場でもアルゴリズムは大きく活躍しており、
これからは本当にデータやアルゴリズムの時代のような気がしてしまった。&lt;/p&gt;

&lt;p&gt;アルゴリズムはすでに我々の言葉をきいて、その本音を読み取ることができるようになっている。
ポーカーや電話の自動オペレーターの話を読んでいると、今まではアルゴリズムは
天才的な人間のモデルを作ることだと思っていたけれど、どうやらそれには少し誤解があるらしかった。&lt;/p&gt;

&lt;p&gt;例えば電話対応の場合、ある電話は情報を得るためにかけられており、ある電話は共感や日常会話を求めてかかってきたものだとする。
最初の電話では、情報を伝えれば相手はすぐに満足するだろうが、雑談をし始めたらイライラするかもしれない。
2つ目の電話の場合、謝罪や誠実で思いやりのある対応が相手を最も満足させる。&lt;/p&gt;

&lt;p&gt;このようにアルゴリズムは相手によって対応を変える必要がある。&lt;br /&gt;
そして元々NASAで宇宙飛行士の相性を調べるために開発されたテービー・ケーラー博士の手法では
人間を以下の6つのタイプに分類するらしい。&lt;/p&gt;

&lt;p&gt;1: 感情重視型の人。課題に取り掛かる前に関係者と人間関係を築く。女性がこのグループの3/4を占める。全体の30%がこのグループ。窮地に陥ると劇的になり過剰反応を起こす&lt;br /&gt;
2: 思考重視型の人。社交辞令や冗談を言わない。現実ジを重視し、意思決定は厳格な現実主義に基づいて行われる。&lt;br /&gt;
3: 行動重視型の人。進捗や行動を望む。常に精力的で押しが強い。魅力的な人間が多い。&lt;br /&gt;
4: 内省重視型の人。温和で想像力が豊か。現実に取り組みよりも、これからどうなるだろうかと考えをめぐらせる。&lt;br /&gt;
5: 意見重視型の人。話し言葉は命令形と断定系が多い。状況の一面しか見ない傾向がある。自分お意見に固執する。政治家の70%はこのグループ。全人口ではったの10%。勤勉であり、問題解決まで粘り強い。&lt;br /&gt;
6: リアクション重視型の人。自発的で独創的。冗談が好きである。物事に対して強い反応を示す。起業家、発明家に多い。&lt;/p&gt;

&lt;p&gt;もちろん複数のタイプを持つこともある。&lt;/p&gt;

&lt;p&gt;この本を読んでアルゴリズムに興味が湧いた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>信頼残高のことを思い出した。</title>
      <link>http://kotazi.github.io/blog/post/2016/0215_trast/</link>
      <pubDate>Mon, 15 Feb 2016 19:27:45 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0215_trast/</guid>
      <description>&lt;p&gt;サイバーエージェントで働いていたころ、しばしば「信頼残高」という言葉を耳にした。(こういう考え方が社内に浸透していることが本当にすごいと今になって思う。)&lt;/p&gt;

&lt;p&gt;仕事というものは信頼の積み重ねで成り立っている。
この信頼の積み重ねこそが、自身の「信頼残高」だ。&lt;/p&gt;

&lt;p&gt;大きな仕事や、期待以上の成果を出せば信頼残高が増えていく。
信頼残高のある人間には、また大きな仕事やチャンスが回ってくる。&lt;/p&gt;

&lt;p&gt;逆につまらないミスなどをすれば信頼残高は減っていってしまう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メールの誤字脱字が多い&lt;/li&gt;
&lt;li&gt;会議に2、3分遅刻してしまう&lt;/li&gt;
&lt;li&gt;二日酔いで出社してくる&lt;/li&gt;
&lt;li&gt;資料のまとめ方が下手&lt;/li&gt;
&lt;li&gt;デスク周りがいつも散らかっている&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こういったことでも信頼残高はどんどん削られていってしまう。
「稼いでいるのに全然貯金が貯まらない人」みたいになってしまう。&lt;/p&gt;

&lt;p&gt;日々の積み重ねをしっかりとやっていこう。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;個人的に思ったのが、NZ内での信頼が積み重ねられていないなと思った。
自分の成果が海を超えて認められるように努力することはもちろんなのだけれど、
各国での評価が一律になるような透明度の高い組織を作っていきたい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails内でのwebpackの使い方</title>
      <link>http://kotazi.github.io/blog/post/2016/0214_rails_webpack/</link>
      <pubDate>Sun, 14 Feb 2016 13:41:03 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0214_rails_webpack/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://clarkdave.net/2015/01/how-to-use-webpack-with-rails/&#34;&gt;&amp;ldquo;How to use webpack with Rails&amp;rdquo;&lt;/a&gt;翻訳記事になります。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;webpackは強力なモジュールバンドラである。主としてフロントエンド開発のために設計されており、
bowerやnpmのJavaScriptモジュールをうまく統合することができる。&lt;/p&gt;

&lt;p&gt;Sproketsやアセットパイプラインを用いればシームレスな挿入をすることが可能だけれども、これには典型的なRailsのJSマネジメントシステムを使うによりいくつか大きな利点がある。残念ながらwebpackのドキュメントはまだ要約することが難しく、特にRailsに統合したいとなればなおさらだ。&lt;/p&gt;

&lt;p&gt;あなたがまだwebpackを使っていないのであれば、ここに何ができるのかを示そう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;npmやbowerを使っている全てのフロントエンドのJS(依存関係も)管理する&lt;/li&gt;
&lt;li&gt;CoffeeScriptやES6を自動で処理する&lt;/li&gt;
&lt;li&gt;最小の力で全てのソースマップを出力する&lt;/li&gt;
&lt;li&gt;難しい部分でのJSの分離に役に立つ。&amp;rdquo;common&amp;rdquo;モジュールが自動的に全てのページに渡ってシェアしてくれる&lt;/li&gt;
&lt;li&gt;大きなモジュールを複数のファイルに分割し、必要なファイルのみをダウンロードする(&lt;code&gt;require.ensure&lt;/code&gt;を用いる)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いいなと思ったら、これらを既存のRailsアプリ、もしくは新たなRailsアプリでどのように利用するか呼んでみるといい。
ちなみに、これはRails中心に書かれているけれども、Railsでなくともそのようなフレームワークにwebpackを導入したいのであればきっと役に立つだろう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;getting-started:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Getting Started&lt;/h3&gt;

&lt;h4 id=&#34;is-webpack-right-for-your-app:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Is webpack right for your app?&lt;/h4&gt;

&lt;p&gt;webpackは本当にパワフルで素晴らしいツールである。
けれども本当に効果的に利用するには、あなたが&amp;rdquo;モジュールとしてのJS&amp;rdquo;という哲学をしっかりと信じる必要がある。
jQueryやBackboneといった人気のライブラリを使っているなら簡単なことだ。
けれども、特に大きなアプリをwebpackを用いてコンバートしているのなら、いくつかの問題につまづくであろうことを知っておくべきだ。&lt;/p&gt;

&lt;p&gt;典型的な問題:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;モジュールにはちゃんと定義されてエントリーポイントがない(webpackはあなたが要求したときに何を含むべきか知らない)&lt;/li&gt;
&lt;li&gt;モジュールに&lt;code&gt;package.json&lt;/code&gt;や&lt;code&gt;bower.json&lt;/code&gt;は無効である&lt;/li&gt;
&lt;li&gt;modules which simply stick something on window and call it a day&lt;/li&gt;
&lt;li&gt;modules which add something to jQuery, instead of exporting anything&lt;/li&gt;
&lt;li&gt;modules which, by default, give you a gigantic kitchen sink you don’t need&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;幸運にもこれらの問題に対処するための様々なメソッドがあるため、webpackで全て解決できる。
さっきも述べたようにwebpackのドキュメントは量が多いので、私が上記についてはカバーする。&lt;/p&gt;

&lt;p&gt;あなたのアプリに向いているか？&lt;/p&gt;

&lt;h4 id=&#34;新しいrailsアプリを作っているところ:78a84d7a250550b9fca3451f0818ba23&#34;&gt;新しいRailsアプリを作っているところ&lt;/h4&gt;

&lt;p&gt;大量のJSコードを使うのなら絶対に。試さない理由がない。&lt;/p&gt;

&lt;h4 id=&#34;アプリは大きいがjsはそこまで量がない:78a84d7a250550b9fca3451f0818ba23&#34;&gt;アプリは大きいがJSはそこまで量がない&lt;/h4&gt;

&lt;p&gt;多分価値が無いかも。webpackはたくさんのモジュールを使っていたり、たくさんのJSコードを書いているときに
本当に輝く。そんなにJSがないのであれば、大きなメリットはないだろう。&lt;/p&gt;

&lt;h4 id=&#34;アプリは大きいが-jsはよく整備されており-特に問題がない:78a84d7a250550b9fca3451f0818ba23&#34;&gt;アプリは大きいが、JSはよく整備されており、特に問題がない&lt;/h4&gt;

&lt;p&gt;全てをwebpackに移行することはそれなりに労力がかかるため、多分やる価値はない。&lt;/p&gt;

&lt;h4 id=&#34;アプリは大きく-大量のスパゲッティコード-jsファイルは800kbを超えている:78a84d7a250550b9fca3451f0818ba23&#34;&gt;アプリは大きく、大量のスパゲッティコード、jsファイルは800kbを超えている&lt;/h4&gt;

&lt;p&gt;きっとwebpackを使ったほうがいい！少々大変だが、知るべきことはこのガイドで伝える。&lt;/p&gt;

&lt;p&gt;始める準備ができたら、Railsアプリをwebpackに移行しよう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;preparing-rails-for-webpack:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Preparing Rails for webpack&lt;/h3&gt;

&lt;p&gt;Railsにwebpackを統合するベストプラクティスは存在しないため、多くは意見である。
もしディレクトリの置き場所が気に食わなければ、好きな場所においてもらって構わない。&lt;/p&gt;

&lt;h4 id=&#34;untangling-sprockets:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Untangling Sprockets&lt;/h4&gt;

&lt;p&gt;最初にすることは&lt;code&gt;app/assets/javascripts&lt;/code&gt;を空にすることだ。
webpackの設定を個々にすると、Sprocketsに拾われてしまう。
全てのJSコードを他の場所に移そう。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt;にこれを追加しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/app/assets/javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これには2つの理由がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;生成されるバンドルは大きくなりがちだったり変更されがちだったりで、ただのgitのスパムを生成することになる&lt;/li&gt;
&lt;li&gt;We’ll be integrating webpack with our deloy process later, which will build a production version of the bundles and placing them here. So, even if you checked in the bundles, you’d be replacing them during deploy anyway.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記のアドバイスはあなたが全てをwebpackに移行するものとしてのことだ。
もちろんSprocketsのJSバンドラとwebpackを併用することもできる。
その場合は、&lt;code&gt;.gitignore&lt;/code&gt;を&lt;code&gt;/app/assets/javascripts/bundle-*&lt;/code&gt;みたいに生成されたJSのみを無視するように修正する。&lt;/p&gt;

&lt;h4 id=&#34;a-new-home-for-your-javascript:78a84d7a250550b9fca3451f0818ba23&#34;&gt;A new home for your JavaScript&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;app/assets/javascripts&lt;/code&gt;は生成されたバンドラのためのものなので、実際のJSのために新しいホームを生成する必要がある。
私は新しいフォルダを作成するが、もちろん他の場所においてもいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/frontend/javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ディレクトリ内部に&lt;code&gt;entry.js&lt;/code&gt;というファイルを作成しよう。
またあとで説明するので、とりあえず追加してくれ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var _ = require(&#39;lodash&#39;);
_.times(5, function(i) {
  console.log(i);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;installing-webpack-bower:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Installing webpack &amp;amp; Bower&lt;/h3&gt;

&lt;h4 id=&#34;installing-webpack:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Installing webpack&lt;/h4&gt;

&lt;p&gt;webpackはnode.jsのアプリケーションのため、&lt;code&gt;package.json&lt;/code&gt;がRailsルートの中に必要だ。&lt;br /&gt;
シンプルであるために、webpackとwebpackのモジュールを管理するためだけに使っている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;my-rails-app&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;my-rails-app&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;webpack&amp;quot;: &amp;quot;~1.4.13&amp;quot;,
    &amp;quot;expose-loader&amp;quot;: &amp;quot;~0.6.0&amp;quot;,
    &amp;quot;imports-loader&amp;quot;: &amp;quot;~0.6.3&amp;quot;,
    &amp;quot;exports-loader&amp;quot;: &amp;quot;~0.6.2&amp;quot;,
    &amp;quot;lodash&amp;quot;: &amp;quot;~2.4.1&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依存関係に&lt;code&gt;webpack&lt;/code&gt;があることが見えるだろう。それと多分必要であろういくつかwebpackのローダーを追加した(後で説明する)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install&lt;/code&gt;をして&lt;code&gt;node_modules&lt;/code&gt;を確認しよう。
すでにnode.jsはインストール済み？まだだったらインストールしよう！&lt;/p&gt;

&lt;p&gt;続いて&lt;code&gt;webpack&lt;/code&gt;グローバルにインストールし、コマンドラインツールで使えるようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;installing-bower-optional:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Installing Bower (optional)&lt;/h4&gt;

&lt;p&gt;webpackのいいところのひとつは利用するパッケージ管理ツールを強要しないところだ。
デフォルトはたくさんのフロントエンドモジュールをもったnpmだ。
けれどもBowerというweb用に設計された別のパッケージ管理ツールでしか利用できないフロントエンドライブラリもたくさんある。&lt;/p&gt;

&lt;p&gt;jQueryやunderscore、lodashといった人気で整備されているライブラリのみを使う予定なのであればBowerは必要ない。
これらはnpmで十分だ。&lt;code&gt;package.json&lt;/code&gt;はnpmを使って簡単に追加できる。&lt;/p&gt;

&lt;p&gt;しかしながら、もし多くのライブラリを使う必要があったり、単にBowerが好きならセットアップは簡単にできる。
まずは&lt;code&gt;bower&lt;/code&gt;コマンドをインストールしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g bower
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてRailsルートに&lt;code&gt;bower.json&lt;/code&gt;を作成しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;my-rails-app&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;my-rails-app&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;jquery&amp;quot;: &amp;quot;~1.11.0&amp;quot;,
    &amp;quot;lodash&amp;quot;: &amp;quot;~2.4.1&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではjQueryとlodashを依存関係に持った最小限の&lt;code&gt;bower.json&lt;/code&gt;を作成した。
Railsルートで&lt;code&gt;bower install&lt;/code&gt;を実行すると、bowerはこれらのライブラリを依存関係に沿って&lt;code&gt;bower_components&lt;/code&gt;にインストールする。&lt;/p&gt;

&lt;p&gt;覚えておいて欲しいのが、npmと違いbowerは、フラットな階層で依存関係を解消する。
だからもし、あなたがjQueryの1.x系を指定しながら、別の依存関係では最低のjQueryバージョンを2.x以上と指定していたのであれば、
これを自分自身で解消する必要がある。&lt;/p&gt;

&lt;h3 id=&#34;using-bower-and-npm-together:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Using bower and npm together&lt;/h3&gt;

&lt;p&gt;webpack内でnpmとbowerを一緒に使うことを止めるものはいない。
たとえばもしjQueryとBackboneをnpmから、人気のないモジュールをBowerからといったように。
事実、&lt;a href=&#34;https://webpack.github.io/docs/usage-with-bower.html#prefer-modules-from-npm-over-bower&#34;&gt;webpackのドキュメント&lt;/a&gt;にも書かれている。&lt;/p&gt;

&lt;p&gt;In a nutshell, npm (CommonJS-style) modules are typically cleaner and easier for webpack to optimise, which will result in smaller bundles and faster compile times.&lt;/p&gt;

&lt;p&gt;In practice, this might not make a huge difference. In the case of large modules like &lt;code&gt;React&lt;/code&gt;, it may be worth including it as a one-off from npm so webpack can optimise it a little better, but for almost everything else I recommend sticking with Bower so you have one place for all your dependencies.&lt;/p&gt;

&lt;h3 id=&#34;configuring-webpack:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Configuring webpack&lt;/h3&gt;

&lt;p&gt;たくさんの引数を用いて完全にコマンドラインからwebpackを実行することもできるが、複雑になってしまうので、コンフィグファイルを用いて始めよう。&lt;/p&gt;

&lt;p&gt;Railsルートに&lt;code&gt;webpack.config.js&lt;/code&gt;を作成しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var path = require(&#39;path&#39;);
var webpack = require(&#39;webpack&#39;);

var config = module.exports = {
  // the base path which will be used to resolve entry points
  context: __dirname,
  // the main entry point for our application&#39;s frontend JS
  // メインとなるエントリーポイント
  entry: &#39;./app/frontend/javascripts/entry.js&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最終的に非常に複雑なファイルになるので、最小限のところから始めて、説明をしながら加えていこう。
ガイドを通してたくさんのことをフィルについかしていくことになる。
&lt;a href=&#34;https://webpack.github.io/docs/configuration.html&#34;&gt;webpackドキュメント&lt;/a&gt;にも設定用プロパティの概要については書かれている。&lt;/p&gt;

&lt;p&gt;現在ひとつのエントリーファイルを持っているが、配列やオブジェクトを設定することも可能だ。(後に説明)
注意すべき重要な事は、このエントリーファイルがJSのコアとなるということだ。
ここでファイルを指定しなければコンパイルが完了することはない。&lt;/p&gt;

&lt;p&gt;次は&lt;code&gt;output&lt;/code&gt;を追加しよう。コンパイルされたバンドルの場所を占めるものだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.output = {
  // this is our app/assets/javascripts directory, which is part of the Sprockets pipeline
  // app/assets/javascriptsディレクトリのこと。Sprocketsの一部となる。
  path: path.join(__dirname, &#39;app&#39;, &#39;assets&#39;, &#39;javascripts&#39;),
  // the filename of the compiled bundle, e.g. app/assets/javascripts/bundle.js
  // コンパイルされらバンドラのファイル名。
  filename: &#39;bundle.js&#39;,
  // if the webpack code-splitting feature is enabled, this is the path it&#39;ll use to download bundles
  // webpackの&amp;quot;code-splitting&amp;quot;機能を使う場合。
  publicPath: &#39;/assets&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いて&lt;code&gt;resolve&lt;/code&gt;を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.resolve = {
  // tell webpack which extensions to auto search when it resolves modules. With this,
  // you&#39;ll be able to do `require(&#39;./utils&#39;)` instead of `require(&#39;./utils.js&#39;)`
  // 自動補完をwebpackに伝える。
  // この場合`require(&#39;./utils.js&#39;)`の代わりに`require(&#39;./utils&#39;)`とすることができる
  extensions: [&#39;&#39;, &#39;.js&#39;],
  // by default, webpack will search in `web_modules` and `node_modules`. Because we&#39;re using
  // Bower, we want it to look in there too
  // デフォルトでは`web_module`と`node_modules`を探す。今回はBowerを使うので下記になる
  modulesDirectories: [ &#39;node_modules&#39;, &#39;bower_components&#39; ],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に&lt;code&gt;plugins&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.plugins = [
  // we need this plugin to teach webpack how to find module entry points for bower files,
  // as these may not have a package.json file
  new webpack.ResolverPlugin([
    new webpack.ResolverPlugin.DirectoryDescriptionFilePlugin(&#39;.bower.json&#39;, [&#39;main&#39;])
  ])
];
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;running-webpack:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Running webpack&lt;/h3&gt;

&lt;p&gt;webpackを実行する前に、Bowerの依存関係をインストールしよう。
NPMだけなら&lt;code&gt;npm install&lt;/code&gt;を実行すればいい。Bower依存関係をインストールするには:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bower install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;jquery&lt;/code&gt;と&lt;code&gt;lodash&lt;/code&gt;の入った&lt;code&gt;bower_components/&lt;/code&gt;ディレクトリがあることだろう。&lt;/p&gt;

&lt;p&gt;それが終わればwebpackをRailsルートから実行しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ webpack -d --display-reasons --display-chunks --progress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドはwebpackをdevelopmentモードで実行し、何を実行しているかを表示するようになる。
ゆくゆくはこのコマンドを自動化する。
すべてが上手く行けば、このような出力が確認できるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hash: cfee07d10692c4ab1eeb
Version: webpack 1.4.14
Time: 548ms
        Asset    Size  Chunks             Chunk Names
    bundle.js  254088       0  [emitted]  main
bundle.js.map  299596       0  [emitted]  main
chunk    {0} bundle.js, bundle.js.map (main) 244421 [rendered]
    [0] ./app/frontend/javascripts/entry.js 73 {0} [built]
     + 2 hidden modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この出力には、&lt;code&gt;bundle.js&lt;/code&gt;という&amp;rdquo;チャンク&amp;rdquo;が作成されたことと、sourcemapが作成されたことが書かれている。
チャンクはJSの分割方法についてだ。
いまはただ、エントリーポイントにつき一つのチャンクを作成しただけだ。
けれどももし、エントリーポイント間にたくさんのモジュールがあったり、code-splitting機能を使っているのであれば、
webpackは&lt;code&gt;1.1-bundle.js&lt;/code&gt;といった名前でたくさんのチャンクを作成する。&lt;/p&gt;

&lt;h4 id=&#34;the-compiled-webpack-bundle:78a84d7a250550b9fca3451f0818ba23&#34;&gt;The compiled webpack bundle&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;app/assets/javascripts/bundle.js&lt;/code&gt;ファイルを開いてみると、コンパイルされたJavaScriptが確認できる。
このファイルでは、標準のJavaScriptは持っていない機能である依存関係の&lt;code&gt;require&lt;/code&gt;機能を全てのモジュールに提供するwebpackローダーを含んでいる。(数バイト)&lt;/p&gt;

&lt;p&gt;webpackが実際に行っていることは下記のコードを見て呼び出しを&lt;code&gt;require(&#39;lodash&#39;)&lt;/code&gt;に変えてみるといい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var _ = __webpack_require__(/*! lodash */ 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全てのモジュールに注入される&lt;code&gt;__webpack_require__&lt;/code&gt;関数は要求された依存関係をロードすることができる。
サンプル通りにやっているのであれば、50行目は下記のようになっているはずである。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* 0 */
/*!*******************************************!*\
  !*** ./app/frontend/javascripts/entry.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

  var _ = __webpack_require__(/*! lodash */ 1);
  _.times(5, function(i) {
    console.log(i);
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;including-webpack-bundles-in-rails-views:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Including webpack bundles in Rails views&lt;/h4&gt;

&lt;p&gt;思っている通りで、コンパイルされtらJSバンドラは普通に含めることができる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;%= javascript_include_tag &#39;bundle&#39;  %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基礎はこれで完了。
あとは大きなアプリケーションで必要になりそうなことをカバーしていく。&lt;/p&gt;

&lt;h3 id=&#34;exposing-global-modules-e-g-jquery:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Exposing global modules (e.g. jQuery)&lt;/h3&gt;

&lt;p&gt;特定のモジュールでjQueryを使いたければ下記のように書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ = require(&#39;jquery&#39;);
$(&#39;p&#39;).show();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;けれどもきっとこのようなことがしたいだろう:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自動で全てのモジュールにjQueryを使えるようにし、毎回&lt;code&gt;$ = require(&#39;jquery&#39;)&lt;/code&gt;のようなことは書く必要がない&lt;/li&gt;
&lt;li&gt;モジュールの外側でも使えるように、&lt;code&gt;window.$&lt;/code&gt;のようにグローバルオブジェクトにする。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;webpackでどちらも可能だ。&lt;code&gt;ProvidePlugin&lt;/code&gt;を使う。webpackのコンフィグにプラグインの配列を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new webpack.ProvidePlugin({
  $: &#39;jquery&#39;,
  jQuery: &#39;jquery&#39;,
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで自動的に&lt;code&gt;$&lt;/code&gt;と&lt;code&gt;jQuery&lt;/code&gt;を注入するようになり、全てのモジュールに&lt;code&gt;require&lt;/code&gt;を追加する必要はもはやなくなる。&lt;/p&gt;

&lt;p&gt;次のステップとして&lt;code&gt;window&lt;/code&gt;オブジェクトの追加だ。&lt;a href=&#34;https://webpack.github.io/docs/loaders.html&#34;&gt;loader&lt;/a&gt;
を追加する。loaders apply some kind of transformation on a file. For example, later we’ll show how to use a loader to transform CoffeeScript files into JavaScript.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;expose&lt;/code&gt;ローダーはモジュールからエクスポートし、それをグローバルに追加する。今回の場合&lt;code&gt;window&lt;/code&gt;だ。
ou can configure loaders in the webpack config, which makes sense for transformations like CoffeeScript, but you can also specify them when you require a module, which I think makes more sense for the expose loader as it expresses the intent in your code.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;entry.js&lt;/code&gt;のトップに書きを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require(&#39;expose?$!expose?jQuery!jquery&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この書式がアホらしいことは分かっている。&lt;code&gt;window.$&lt;/code&gt;と&lt;code&gt;window.jQuery&lt;/code&gt;にjQueryを追加するために、&lt;code&gt;expose&lt;/code&gt;ローダーを２回呼び出している。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require(expose?&amp;lt;libraryName&amp;gt;!&amp;lt;moduleName&amp;gt;)&lt;/code&gt;のように書いている。
&lt;code&gt;&amp;lt;libraryName&amp;gt;&lt;/code&gt;は&lt;code&gt;window.libraryName&lt;/code&gt;となり、&lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt;とは含むモジュールのこと。
このケースでは&lt;code&gt;jquery&lt;/code&gt;だ。&lt;code&gt;!&lt;/code&gt;を使って上記に書いたようにチェインすることが可能。&lt;/p&gt;

&lt;p&gt;さきほどと同じコマンドを使って、再度webpackを実行すると、&lt;code&gt;$&lt;/code&gt;と&lt;code&gt;jQuery&lt;/code&gt;にグローバルアクセスできることが分かるだろう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;source-maps:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Source maps&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;bundle.js.map&lt;/code&gt;が出力先のディレクトリに作成されていることに気付いただろう。
このソースマップはwebpackの働きによって生成されている。
The source maps generated by webpack work extremely well. You get to download a single bundle (instead of 10+ individual files, which can get slow) but can view errors inside individual files, as they exist on your file system. And of course, if you’re using CoffeeScript and friends, you can view errors in the context of the actual CoffeeScript file.&lt;/p&gt;

&lt;p&gt;However, by default Sprockets will break the source maps by appending a semi-colon to them, so browsers can’t parse them. You can fix this with the following configuration option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Rails.application.config.assets.configure do |env|
  env.unregister_postprocessor &#39;application/javascript&#39;, Sprockets::SafetyColons
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this to your &lt;code&gt;config/initializers/assets.rb&lt;/code&gt; (or directly in &lt;code&gt;config/application.rb&lt;/code&gt; for older versions of Rails). Then clear your Sprockets cache: $ rm -r tmp/cache`&lt;/p&gt;

&lt;p&gt;Now when you get errors, or view loaded sources in a browser, you’ll see the actual file (e.g. entry.js) instead of the giant bundled file.&lt;/p&gt;

&lt;h4 id=&#34;virtual-source-paths:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Virtual source paths&lt;/h4&gt;

&lt;p&gt;In Chrome, by default the source map generated by webpack will put everything in a &amp;lsquo;pseudo path’, &lt;code&gt;webpack://&lt;/code&gt;, when you view it in the inspector’s Sources tab. You can make this a bit nicer by adding the following to your webpack &lt;code&gt;config.output&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;devtoolModuleFilenameTemplate: &#39;[resourcePath]&#39;,
devtoolFallbackModuleFilenameTemplate: &#39;[resourcePath]?[hash]&#39;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now your &amp;lsquo;virtual’ source files will appear under the &lt;code&gt;domain &amp;gt; assets&lt;/code&gt; directory in the Sources tab.&lt;/p&gt;

&lt;h4 id=&#34;sprockets-cache-and-source-maps:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Sprockets cache and source maps&lt;/h4&gt;

&lt;p&gt;In my experience, Sprockets can be very aggressive at caching source maps. If they ever start acting weird, make sure to clear the sprockets cache in &lt;code&gt;tmp/cache&lt;/code&gt; first.&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;loading-coffeescript-and-other-transpiled-languages:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Loading CoffeeScript and other transpiled languages&lt;/h3&gt;

&lt;p&gt;CoffeeScriptやその類で書かれたモジュールをローダーを使って自動でトランスパイルすることができる。
&lt;code&gt;expose&lt;/code&gt;ローダーのように、&lt;code&gt;require&lt;/code&gt;ステートメントの内部で実行されるが、webpackのコンフィグに記述することがよいとは言えないので、
CoffeeScriptモジュールをrequireする。&lt;/p&gt;

&lt;p&gt;はじめに、書きのように&lt;code&gt;package.json&lt;/code&gt;に&lt;code&gt;coffee-loader&lt;/code&gt;をインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install coffee-loader@0.7.2 --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpackのコンフィグで、&lt;code&gt;config.resolve.extensions&lt;/code&gt;も書いておく。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.coffee&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後に、ローダーを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config.module = {
  loaders: [
    { test: /\.coffee$/, loader: &#39;coffee-loader&#39; },
  ],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;app/frontend/javascripts/app.coffee&lt;/code&gt;を作成する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_ = require(&#39;lodash&#39;)

module.exports = class App
  start: -&amp;gt;
    _.times 3, (i) -&amp;gt; console.log(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既存の&lt;code&gt;entry.js&lt;/code&gt;を更新する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require(&#39;expose?$!expose?jQuery!jquery&#39;);
var App = require(&#39;./app&#39;);

var app = new App();
app.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再度webpackを実行して、ブラウザで予想通りに動作していることが確認できる。&lt;/p&gt;

&lt;h3 id=&#34;code-splitting-and-lazily-loading-modules:78a84d7a250550b9fca3451f0818ba23&#34;&gt;Code splitting and lazily loading modules&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>【プログラミング言語Ruby】3章-データ型とオブジェクト</title>
      <link>http://kotazi.github.io/blog/post/2016/0212_ruby/</link>
      <pubDate>Sat, 13 Feb 2016 20:34:06 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0212_ruby/</guid>
      <description>

&lt;h3 id=&#34;数値:1999afa650d3f1ac291df7d051f99de9&#34;&gt;数値&lt;/h3&gt;

&lt;p&gt;Rubyは数値を表現する5種類の組み込みクラスを持っており、
標準ライブラリにはさらに3種類の役に立ち数値クラスが含まれている。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.evernote.com/l/AHWcSL7aQflDHarJQfPcwzy2xDWCtDv8WdUB/image.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Rubyの全ての数値オブジェクトは&lt;code&gt;Numeric&lt;/code&gt;のインスタンスになっている。
全ての整数は&lt;code&gt;Integer&lt;/code&gt;のインスタンスである。31ビット幅に収まる整数値は&lt;code&gt;Fixnum&lt;/code&gt;のインスタンスであり、
そうでなければ&lt;code&gt;Bignum&lt;/code&gt;のインスタンスである。
Rubyでは実数値を&lt;code&gt;Float&lt;/code&gt;クラスで近似的に表現する。&lt;code&gt;Float&lt;/code&gt;クラスは
プラットフォーム固有の浮動小数点表現を使う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Complex&lt;/code&gt;クラスは複素数を表現する。
&lt;code&gt;BigDecimal&lt;/code&gt;クラスは10進数表現を使って任意の制度の実数を表現する。
&lt;code&gt;Rational&lt;/code&gt;クラスは有理数、すなわち整数を別の整数で除算した値を表現する。&lt;/p&gt;

&lt;p&gt;また、全ての数値オブジェクトはイミュータブルである。&lt;/p&gt;

&lt;h3 id=&#34;文字列:1999afa650d3f1ac291df7d051f99de9&#34;&gt;文字列&lt;/h3&gt;

&lt;p&gt;文字列は&lt;code&gt;String&lt;/code&gt;クラスによって表現する。ミュータブルなオブジェクトである。
パターンは&lt;code&gt;Regexp&lt;/code&gt;オブジェクトとして表現される。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%q&lt;/code&gt;、&lt;code&gt;%Q&lt;/code&gt;はStringリテラル。&lt;/p&gt;

&lt;h3 id=&#34;配列:1999afa650d3f1ac291df7d051f99de9&#34;&gt;配列&lt;/h3&gt;

&lt;p&gt;配列とは、値の列で、列の中の位置(添字)によって値にアクセスできるようになっているものである。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%w&lt;/code&gt;、&lt;code&gt;%W&lt;/code&gt;は配列リテラル。&lt;/p&gt;

&lt;p&gt;配列は&lt;code&gt;Array.new&lt;/code&gt;コンストラクタでも作成できる。&lt;/p&gt;

&lt;h3 id=&#34;ハッシュ:1999afa650d3f1ac291df7d051f99de9&#34;&gt;ハッシュ&lt;/h3&gt;

&lt;p&gt;ハッシュとはキーと呼ばれるオブジェクトの集合を保持し、ここのキーに値を対応付けているデータ構造である。
キーを値にマッピングするので、ハッシュはマップとも呼ばれる。
個々のキーから値を連想するように導き出すので、連想配列とも呼ばれることもあるし、
添字が整数ではなく任意のオブジェクトになった配列と考え得ることもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numbers = Hash.new
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;ハッシュリテラル:1999afa650d3f1ac291df7d051f99de9&#34;&gt;ハッシュリテラル&lt;/h4&gt;

&lt;p&gt;ハッシュリテラルは全体が中括弧で囲まれ、カンマで区切られたキー/値の対という形で記述される。
キーと値は&lt;code&gt;=&amp;gt;&lt;/code&gt;という2文字の矢印で区切られる。先ほど作成したHashオブジェクトは次のリテラルでも作成できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numbers = { &amp;quot;one&amp;quot; =&amp;gt; 1, &amp;quot;two&amp;quot; =&amp;gt; 2, &amp;quot;three&amp;quot; =&amp;gt; 3 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般に、ハッシュキーとしては文字列よりも&lt;code&gt;Symbol&lt;/code&gt;オブジェクトの方が効率的に使える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numbers = { :one =&amp;gt; 1, :two =&amp;gt; 2, :three =&amp;gt; 3 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Symbol&lt;/code&gt;とはinternされたイミュータブルな文字列で、プレフィックスとしてコロンが付けられた識別子という形で記述される。&lt;/p&gt;

&lt;p&gt;Rubyのハッシュは、ハッシュテーブルというデータ構造を使って実装されている。
ハッシュのキーとして使えるオブジェクトは、キーのハッシュ値となるFixnumを返すhashという名前のメソッドを保つ必要がある。&lt;/p&gt;

&lt;h3 id=&#34;範囲:1999afa650d3f1ac291df7d051f99de9&#34;&gt;範囲&lt;/h3&gt;

&lt;p&gt;Rangeオブジェクトは先頭の値から末尾の値までのすべての値を表す。範囲リテラルは、先頭の値と末尾の値の間に2個または3子のドットを入れて記述する。
ドットが２個なら範囲は包含的で、末尾の値も範囲の一部となる。
ドットが３個なら、範囲は排他的で、末尾の値は範囲に含まれない。&lt;/p&gt;

&lt;p&gt;範囲には暗黙的に順序がある。
Stringクラスにはsuccメソッド定義されており、&lt;code&gt;&#39;a&#39;.succ&lt;/code&gt;が&amp;rsquo;b&amp;rsquo;、&lt;code&gt;&#39;b&#39;.succ&lt;/code&gt;が&amp;rsquo;c&amp;rsquo;である。
このように反復処理できる範囲を離散範囲(discrete range)という。短点がsuccメソッドを定義していない範囲は反復処理できないので
連続範囲(continuous range)という。
短点が整数になっている範囲は離散範囲だが、浮動小数点になっている範囲は連続範囲である。&lt;/p&gt;

&lt;h3 id=&#34;シンボル:1999afa650d3f1ac291df7d051f99de9&#34;&gt;シンボル&lt;/h3&gt;

&lt;p&gt;Rubyの一般的な実装は、実装が把握しているすべてのクラス、メソッド、変数の名前を格納するシンボルテーブルを管理している。
シンボルテーブルがあるおかげで、インタープリタは文字列の比較をほとんどせずに済ませられる。
たとえばメソッド名は、このシンボルテーブル内でのメソッド名の位置によって参照する。
こうすることにより、比較的コストの高い文字列の処理がコストの低い整数処理に変わる。&lt;br /&gt;
これらのシンボルは、純粋にインタープリタの内部構造としてしまい込まれているわけではなく、Rubyプログラムからも使えるようになっている。
Symbolオブジェクトは、シンボルを参照しているのである。シンボルリテラルは、コロンをプレフィックスとする識別子や文字列という形で書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:symbol       # Symbolのリテラル
:&amp;quot;symbol&amp;quot;     # 全く同じリテラル
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2個の文字列では、同じ内容を持ちつつ、全く異なるオブジェクトという場合があるが、シンボルではそのようなことは決して起きない。
同じ内容を持つ2個の文字列をシンボルに変換すると、全く同じSymbolオブジェクトになる。2つの異なるSymbolオブジェクトは、必ず異なる内容を持つ。&lt;/p&gt;

&lt;p&gt;文字列の内容のためではなく、一種の固有な識別子として文字列を扱うコードを書こうとしているときには、シンボルを使うことを検討すると良い。
たとえば、引数として&amp;rdquo;AM&amp;rdquo;または&amp;rdquo;PM&amp;rdquo;という文字列を受け付けるメソッドを書くのではなく、:AMか:PMというシンボルを受け付けるようにするのである。
2つの文字列が等しいかどうかを比較するよりも、2つのSymbolオブジェクトが等しいかどうかを検討する方が、はるかに速い。
同じ理由から、ハッシュキーとしては一般に文字列を使うよりもシンボルを使ったほうがよい。&lt;/p&gt;

&lt;h3 id=&#34;true-false-nil:1999afa650d3f1ac291df7d051f99de9&#34;&gt;true、false、nil&lt;/h3&gt;

&lt;p&gt;true、false、nilはRubyのキーワードとなっており、予約された特別な値である。
これらのキーワードを評価すると、専用のオブジェクトになる。
trueを評価すると、&lt;code&gt;TrueClass&lt;/code&gt;のシングルトンインスタンスのオブジェクトになる。
同様に、falseとnilは&lt;code&gt;FalseClass&lt;/code&gt;、&lt;code&gt;NilClass&lt;/code&gt;のシングルトンインスタンスである。
Booleanクラスがないことに注意。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;o == nil
o.nil?
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;オブジェクト:1999afa650d3f1ac291df7d051f99de9&#34;&gt;オブジェクト&lt;/h3&gt;

&lt;p&gt;Rubyはオブジェクト指向言語として非常に純度が高い。
すべての値はオブジェクトであり、他の多くの言事は異なり、原始型と呼べるようなものはない。
Rubyでは、すべてのオブジェクトはObjectだという名前のクラスの敬称をシており、&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【プログラミング言語Ruby】2章-Rubyプログラムの構造と実行</title>
      <link>http://kotazi.github.io/blog/post/2016/0211_ruby/</link>
      <pubDate>Fri, 12 Feb 2016 20:34:06 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0211_ruby/</guid>
      <description>

&lt;p&gt;Rubyインタープリタは、トークンの連続としてプログタムを解析する。
トークンは、コメント、リテラル、記号類、識別子、キーワードである。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;コメントは&lt;code&gt;#&lt;/code&gt;。
複数行コメントは&lt;code&gt;=begin&lt;/code&gt;に始まり、&lt;code&gt;=end&lt;/code&gt;で終わる&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;リテラルはRubyソースコードに直接現れる値。数値、文字列、正規表現の3種類がある。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;識別子とは単純に名前のことである。Rubyは変数、メソッド、クラスなどに名前を与えるために識別子を使っている。&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id=&#34;識別子の中の記号類:5cf09527adc08d8c661f06f43d913565&#34;&gt;▼ 識別子の中の記号類&lt;/h4&gt;

&lt;p&gt;|記号|意味|
|===|===|
|$|グローバル変数にプレフィックスとして付ける。|
|@|インスタンス変数に付ける。クラス変数には２つつける|
|?|役に立つ慣習として、論理値を返すメソッドの末尾に疑問符を付ける|
|!|注意が必要なことを示すときに付ける|
|=|末尾が統合になっているメソッド式は、代入演算子のサ変で東道なしのメソッド名を置くだけで実行できる|&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Rubyの構文の基本単位は式である。Rubyインタープリタは式を評価して値を生成する。&lt;/p&gt;

&lt;p&gt;Rubyはオブジェクト指向なので、メソッドという言葉を使う。&lt;/p&gt;

&lt;p&gt;相互作用するように作られたメソッドのグループはクラスにまとめることができる。
そして、関連するクラスとクラスを持たないメソッドはモジュールにまとめることができる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【プログラミング言語Ruby】1章-イントロダクション</title>
      <link>http://kotazi.github.io/blog/post/2016/0210_ruby/</link>
      <pubDate>Thu, 11 Feb 2016 20:34:06 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0210_ruby/</guid>
      <description>&lt;p&gt;Rubyは完全なオブジェクト指向言語。
すべての値は、単純な数値リテラルやbooleanなども含めてオブジェクトである。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Rubyでは関数やメソッド軌道のための括弧が多くの場合省略可能である。
メソッド呼び出しで括弧が省略されているためオブジェクトの名前付きフィールドか名前付き変数のように見える。
オブジェクトの外からオブジェクトの内部状態にアクセスすることはできない、カプセル化については厳格な言語である。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;ブロックとイテレータは繰り返し処理でよく使われるが、
ブロックを一度しか実行しないメソッドでも役に立つ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;File.open(&amp;quot;data.txt&amp;quot;) do |f|
  line = f.readline
end
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;Rubyのメソッド名は疑問符や感嘆符で終わることもできる。
通常感嘆符のないメソッドは元のオブジェクトのコピーに変更を加えて返してくるが、
感嘆符付きのメソッドはオブジェクトをその場で書き換えるミューテータ(mutator)メソッドである。&lt;/p&gt;

&lt;p&gt;グローバル変数には&lt;code&gt;$&lt;/code&gt;、インスタンス変数には&lt;code&gt;@&lt;/code&gt;、クラス変数には&lt;code&gt;@@&lt;/code&gt;というプレフィックスをつける。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;クラスとはオブジェクトの状態を操作する関連メソッドのコレクションである。
オブジェクトの状態は、インスタンス変数によって管理されている。
インスタンス変数とは名前の先頭が&lt;code&gt;@&lt;/code&gt;で、オブジェクトごとに異なる値を持てる変数のことである。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【Flux】概要</title>
      <link>http://kotazi.github.io/blog/post/2016/0202_flux/</link>
      <pubDate>Tue, 09 Feb 2016 17:46:23 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0202_flux/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://facebook.github.io/flux/docs/overview.html#content&#34;&gt;Overview|Flux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;FluxはFacebookがクライアントサイドのWebアプリケーション構築の際に利用するアプリケーションのアーキテクチャです。
一定方向のデータフローを利用することでReactのビューコンポーネントの構成を補います。
Fluxはフレームワークというよりひとつのパターンなので、新しいコードを必要とすることなくいつでもFluxを使い始めることができます。&lt;/p&gt;

&lt;p&gt;Fluxアプリケーションには主要な3つのパーツがあります。ディスパッチャー、ストア、ビュー(Reactコンポーネント)です。
これらをMVCと混同すべきではありません。
コントローラはFluxアプリケーションの中にも存在します。
&lt;code&gt;controller-views&lt;/code&gt;-ビューはストアからデータを受け取るヒエラルキーのトップに位置し、受け取ったデータを子へと渡します。
加えて、アクションを生成する— dispatcher helper methods —はアプリケーション内で可能な変更を全て描画するセマンティックなAPIを
描画するサポートに利用します。
それらをFluxの更新サイクルにおける4番目のパートと考えると便利です。&lt;/p&gt;

&lt;p&gt;FluxではMVCを避けて一定方向のデータフローを支持しています。
あるユーザーがReactのビューに触れると、そのビューはアプリケーションのデータやロジックを保持した様々なストアへと、中央のディスパッチャーを介してアクションを広め、影響する全てのビューを更新します。
とりわけReactのプログラミングスタイルに良く働き、ステート間でのビューの遷移を細かく支持することなくストアが更新を送れるようになります。&lt;/p&gt;

&lt;p&gt;私たちは元々得られたデータを正しく扱います。例として、スレッドのリストを表示するビューに対して、メッセージスレッドの未読数を表示したかったとします。
MVCでは、単一のスレッドをマークし、スレッドモデルと未読数モデルを更新することは難しいです。
これらの依存関係やカスケードの更新は大規模なMVCアプリケーションでしばしば行われ、
データの流れをもつれさせ、予期せぬ結果をもたらします。&lt;/p&gt;

&lt;p&gt;ストアが制御をひっくり返します。ストアは外部の何かに更新を依存するのではなく、更新を受け入れ、適切に調和します。
内部でのデータの管理方法をストアに留めれば、心配事がなくなります。
ストアは&lt;code&gt;setAsRead()&lt;/code&gt;といった直接的なセッターメソッドを持ちませんが、代わりに自身のコンテナに新しいデータを取得する手段をもっています。
そのコールバックをディスパッチャーとともに登録します。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;structure-and-data-flow:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Structure and Data Flow&lt;/h3&gt;

&lt;p&gt;Fluxアプリケーションのデータの流れは一方向です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一方高のデータの流れはFluxアプリケーションの基本であり、上図はFluxプログラマーにとって主要なメンタルモデルとなります。
ディスパッチャー、ストア、ビューは入力と出力をもった独立したノードです。
アクションは新データと&lt;code&gt;type&lt;/code&gt;プロパティをもった単純なオブジェクトです。&lt;/p&gt;

&lt;p&gt;ビューはユーザーインタラクションが起こるとシステムを通して新しいアクションを伝播します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ディスパッチャーを介した全てのデータフローはセントラルハブとなります。
ディスパッチャーに提供されるアクションは、ユーザーのインタラクションをきっかけに、たいていはアクション生成メソッドから始まります。
そしてディスパッチャーはストアに登録されたコールバックを発動し、アクションを全てのストアに伝えます。
登録されたコールバック内では、ストアの保持しているステートに関連している全てのアクションに反応します。
そしてストアはデータレイヤーが引き起こした変更のイベントをcontroller-viewsに送信します。
controller-viewsはこれらのイベントをキャッチし、イベントハンドラ内でストアからデータを受け取ります。
controller-viewsは自身の&lt;code&gt;setState()&lt;/code&gt;メソッドを呼び出し、自身と全ての子孫を再度レンダリングします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-explained-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;この構造によって、関数型リアクティブプログラミング(FRP)、データフロープログラミング(DFP)、フローベースプログラミング(FBP)の理解が容易になり、アプリケーション内のデータの流れが一方向になります。(これは2wayバインディングとは異なります。)
アプリケーションのステートはストア内のみに保たれ、アプリケーションの異なる部分をしっかりと分離させることができます。
ストア間での依存関係は、ヒエラルキーにより厳格に保たれ、ディスパッチャーによって更新が同期されます。&lt;/p&gt;

&lt;p&gt;2wayデータバインディングではあるオブジェクトが変更されると他のオブジェクトも変更され、たくさんの更新がトリガされます。
アプリケーションが大きくなると、ユーザのインタラクションによって引き起こされる結果として何が変更されるかを予測することが非常に難しくなってシまいます。
シングルラウンド内でデータの変更ができれば、システム全体を予測しやすくなります。&lt;/p&gt;

&lt;p&gt;Fluxの様々な部分を見ていきましょう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;a-single-dispatcher:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;A Single Dispatcher&lt;/h3&gt;

&lt;p&gt;Fluxアプリケーションではディスパッチャーがセントラルハブであり、全てのデータの流れを管理します。
ストアにコールバックを登録することが本質的なところであり、ディスパッチャー自身が実際に知性を持っているわけではありません。
ストアにアクションを割り当てるためのシンプルなmechanismです。
各ストアは自身を登録し、コールバックを提供します。
アクションクリエータが新しいアクションを持ったディスパッチャーを登録すると、アプリケーション内の登録されたすべてのストアがコールバックを通してアクションを受け取ります。&lt;/p&gt;

&lt;p&gt;アプリケーションが大きくなると、ディスパッチャーはより活発になり、明確な順番で登録されたコールバックを呼び出すため、ストア間の依存関係を管理するために役立ちます。
ストアは他のストアの更新を待ち、そのあとに自身を更新します。&lt;/p&gt;

&lt;p&gt;npmやbowerからFacebookが実際の本番環境で使用しているディスパッチャーが利用可能です。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;stores:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Stores&lt;/h3&gt;

&lt;p&gt;ストアにはアプリケーションのステートとロジックが含まれます。
ストアの役割は伝統的なMVCにおけるモデルに似ていますが、ストアはたくさんのオブジェクトのステートを管理します。(ORMのようなシングルレコードを表すわけではありません。)
Backboneのコレクションとも違います。
ORMスタイルのコレクションをよりシンプルに管理するもので、ストアはアプリケーション内で特定のドメインのためのアプリケーションステートを管理します。&lt;/p&gt;

&lt;p&gt;例としてFacebookのLookback Video Editorは&amp;rdquo;TimeStore&amp;rdquo;を利用して、プレイバックタイムの位置とステートのトラックを保ちます。
一方で、同アプリケーションの&amp;rdquo;ImageStore&amp;rdquo;はToDoリストの管理に似ています。ストアはモデルのコレクションとシングルトンとしての特徴を持ち合わせています。&lt;/p&gt;

&lt;p&gt;上記で言及したように、ストアは自身にディスパッチャーを登録し、コールバックをもったディスパッチャーを提供します。
このコールバックはアクションをparameterとして受け取ります。
ストアに登録されたコールバックの内部では、アクションタイプに基づいたステートのスイッチはアクションを解釈し、固有のフックをストア内部のメソッドに提供するために使われます。
こうしてアクションはディスパッチャーを介してストアのステートを更新します。
ストアが更新された後、ステートが変更されたことを宣言するイベントをブロードキャストします。
そしてビューがステートと更新を確認します。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;views-and-controller-views:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Views and Controller-Views&lt;/h3&gt;

&lt;p&gt;Reactは私たちがビューレイヤーに必要としていた構成可能かつ自由で再レンダリングが可能なビューを提供します。
ビューヒエラルキーのトップに位置するビューは依存するストアにブロードキャストされたイベントを受け取る特別なビューです。
これらをcontroller-viewと呼び、ストアからデータを取得し、取得したデータを子孫に渡すようなグルーコードを提供します。&lt;/p&gt;

&lt;p&gt;controller-viewがストアからイベントを受け取ると、ストアのゲッターメソッドを通して必要な新しいデータを要求します。
自身の&lt;code&gt;setState()&lt;/code&gt;もしくは&lt;code&gt;forceUpdate()&lt;/code&gt;関数を呼び出し、自身の&lt;code&gt;render()&lt;/code&gt;メソッドと、子孫の&lt;code&gt;render()&lt;/code&gt;メソッドを引き起こします。&lt;/p&gt;

&lt;p&gt;シングルオブジェクト内のストアの全体のステートを子のビューに下ろすことで、異なる子孫が使えるようになります。
トップ階層でコントローラのような振る舞いを保つことで、このビューを機能的に保つことが可能になり、管理しなければならないプロパティの数を減らすことができます。&lt;/p&gt;

&lt;p&gt;時々、コンポーネントをシンプルに保つために、追加でcontroller-viewsを付け足す必要が出てくるかもしれません。
特定のデータドメインに関連するセクションのヒエラルキーを要約することに役立ちます。
しかし、controller-viewsを深くすることで一方向のデータフローを破ってしまう可能性があることに注意してください。
controller-viewを深い位置に追加するのであれば、異なる点でのヒエラルキーにおいてシンプルなコンポーネントとデータ更新のフローの複雑性にバランスをとってください。
こういった複雑なデータの更新は、Reactのレンダリングメソッドを繰り返し発動させてしまう恐れがあり、潜在的にデバッグを難しくしてしまいます。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;actions:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Actions&lt;/h3&gt;

&lt;p&gt;ディスパッチャーはストアとデータに対してのディスパッチをトリガするメソッドを提供し、
アクションの生成はディスパッチャーにアクションを送るセマンティックなヘルパーメソッドにラップされます。
例えば、ToDoリストアプリケーションのToDoアイテムのテキストを変更したかったとします。
&lt;code&gt;TodoActions&lt;/code&gt;モジュール内で&lt;code&gt;updateText(todoId, newText)&lt;/code&gt;関数を生成します。
このメソッドはビューのイベントハンドラから呼び出され、ユーザーインタラクションによって呼び出すことができます。
このアクションを生成するメソッドはアクションに&lt;code&gt;type&lt;/code&gt;を持たせるため、ストア内で解釈され、適切に反応することができます。
例として、&lt;code&gt;type&lt;/code&gt;を&lt;code&gt;TODO_UPDATE_TEXT&lt;/code&gt;のように名づけます。&lt;/p&gt;

&lt;p&gt;アクションはサーバーなど別の場所から来ることもあるかもしれません。
例えば、データ初期化時などにおこります。
サーバーがエラーコードを返した時や、アプリケーションをアップデートしたときに起こります。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;what-about-that-dispatcher:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;What About that Dispatcher?&lt;/h3&gt;

&lt;p&gt;以前に言及したように、ディスパッチャーはストア間の依存関係を管理します。
ディスパッチャークラスの&lt;code&gt;waitFor()&lt;/code&gt;関数を通して利用可能です。
極めてシンプルなTodoアプリなどで使用する必要はありませんが、より複雑で大きなアプリケーションでは活発になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TodoStore&lt;/code&gt;に登録されたコールバックが他の依存関係の更新を待っている様子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case &#39;TODO_CREATE&#39;:
  Dispatcher.waitFor([
    PrependedTextStore.dispatchToken,
    YetAnotherStore.dispatchToken
  ]);

  TodoStore.create(PrependedTextStore.getText() + &#39; &#39; + action.text);
  break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;waitFor()&lt;/code&gt;は登録したディスパッチャーの配列を一つ引数として受け、&lt;code&gt;dispatch token&lt;/code&gt;と呼ばれます。
このように&lt;code&gt;waitFor()&lt;/code&gt;を発動するストアはどのように自身のステートを更新するかを通知するために別のストアのステートに依存します。&lt;/p&gt;

&lt;p&gt;ディスパッチャーのコールバックが登録された時に&lt;code&gt;register()&lt;/code&gt;が&lt;code&gt;dispatch token&lt;/code&gt;を返します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PrependedTextStore.dispatchToken = Dispatcher.register(function (payload) {
  // ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;より&lt;code&gt;waitFor()&lt;/code&gt;やアクションクリエータ、ディスパッチャーについてしりたければ&lt;a href=&#34;http://facebook.github.io/react/blog/2014/07/30/flux-actions-and-the-dispatcher.html&#34;&gt;こちら&lt;/a&gt;です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【Angular】ユニットテスト</title>
      <link>http://kotazi.github.io/blog/post/2016/0202_angular_unit/</link>
      <pubDate>Mon, 08 Feb 2016 18:45:53 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0202_angular_unit/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.angularjs.org/guide/unit-testing&#34;&gt;Unit Testing|AngularJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;JavaScriptは強い式の力を持った動的型付け言語であり、コンパイラの助けを得ることがない。
そのため、JavaScriptのコードにはしっかりしたテストが必要である。
Angularには、Angularアプリケーションのテストを用意にするための機能がたくさん組み込まれている。
Angularにおいて、テストをしないということはありえない。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;separation-of-concerns:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Separation of Concerns&lt;/h3&gt;

&lt;p&gt;ユニットテストという名前から示されるように、これは独立した単体のコードのテストのことである。
ユニットテストは「そのロジックは正しく動くだろうか」、「ソート関数が並び替えたリストは正しい順番だろうか」
といった質問に回答しようとするものだ。&lt;/p&gt;

&lt;p&gt;テストにおいてこのような質問に答えるためには、単体のコードを孤立させることがとても重要である。
ソート関数のテストをしている時に、関連するDOM要素を生成したり、ソートデータをフェッチするためにXHRを呼び出すといったことをしたくないため。&lt;/p&gt;

&lt;p&gt;これは明らかなことなのに、典型的なプロジェクトでは独立した関数を呼び出すことはとてもむずかしい。
これは開発者がしばしば全てのことをするコードを混合させてしまうことに原因があり、
XHRを生成するもの、受け取ったデータをソートするもの、そしてDOMを操作するもの、である。&lt;/p&gt;

&lt;p&gt;Angularを用いて、あなたが正しくことを行うことを簡単にした。
XHRのために依存性注入を提供するので、リクエストをシミュレーションすることが可能になり、
レスポンスデータをソートすることができ、DOMを操作することができる。
DOMを生成したり、状態を監視したりXHRリクエストのレスポンスデータを待ったりすることなく、
データのソートをテストすることができる。
単独のソート関数を分離してテストすることができる。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;with-great-power-comes-great-responsibility:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;With great power comes great responsibility&lt;/h3&gt;

&lt;p&gt;Angularはテストしやすいことを念頭に書かれているが、それでもまだ
正しい書き方をする必要がある。
書き方が簡単になるよう努めたものの、ガイドラインを無視すれば
アンテスタブルなアプリケーションになってしまう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;dependency-injection:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Dependency Injection&lt;/h3&gt;

&lt;p&gt;Angularは&lt;a href=&#34;https://docs.angularjs.org/guide/di&#34;&gt;依存性注入&lt;/a&gt;のビルトインからなっており、
それはテストのコンポーネント化するため、思いどおりにコンポーネント間での依存関係やスタブ、モックをテストすることが可能。&lt;/p&gt;

&lt;p&gt;コンポーネントに依存性注入をすればテストのモックが簡単になり、
グローバル汚染もなくなりうっかり別のテストに影響してしまうこともなくなる。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;additional-tools-for-testing-angular-applications:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Additional tools for testing Angular applications&lt;/h3&gt;

&lt;p&gt;Angularアプリケーションのテストでは、テストをより簡単にセットアップし実行するために使うべきツールがある。&lt;/p&gt;

&lt;h4 id=&#34;karma:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Karma&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://karma-runner.github.io/&#34;&gt;Karma&lt;/a&gt;はコマンドラインツールである。
アプリケーションのコードを読み込み、実行するWebサーバーを用意する。
アプリケーションがサポートする全てのブラウザにで操作することをテストするために、ブラウザの数分に対してKarmaを実行するように設定することができる。
Karmaをコマンドライン上で実行すると、ブラウザでのテスト実行結果をコマンドライン上にすぐに表示する。&lt;/p&gt;

&lt;p&gt;KarmaはNodeJS製のアプリケーションであり、npmでインストールする。
インストールガイドについては&lt;a href=&#34;http://karma-runner.github.io/0.12/intro/installation.html&#34;&gt;Karmaのサイト&lt;/a&gt;が役に立つ。&lt;/p&gt;

&lt;h4 id=&#34;jasmine:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Jasmine&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html&#34;&gt;Jasmin&lt;/a&gt;はビヘイビア駆動開発のJavaScriptフレームワークであり、
Angularアプリケーションをテストするうえで最も人気のフレームワークである。
テストに構造をもたせ、アサーションを作成するための関数を提供する。
テストが大きくなっても構造的であり、ドキュメント性を保ちながら、アーカイブしてく。&lt;/p&gt;

&lt;p&gt;テストをグループ化するためには&lt;code&gt;describe&lt;/code&gt;を利用する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&amp;quot;sorting the list of users&amp;quot;, function() {
  // individual tests go here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;個々のテストは&lt;code&gt;it&lt;/code&gt;関数の中に定義される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;sorting the list of users&#39;, function() {
  it(&#39;sorts in descending order by default&#39;, function() {
    // your test assertion goes here
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関連するテストを&lt;code&gt;describe&lt;/code&gt;ブロックでグルーピングし、個々のテストは&lt;code&gt;it&lt;/code&gt;関数内に記述することで
テストをドキュメントとして保ち続けることが可能になる。&lt;/p&gt;

&lt;p&gt;最後に、Jasmineは作成するアサーションのマッチャーを提供する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;sorting the list of users&#39;, function() {
  it(&#39;sorts in descending order by default&#39;, function() {
    var users = [&#39;jack&#39;, &#39;igor&#39;, &#39;jeff&#39;];
    var sorted = sortUsers(users);
    expect(sorted).toEqual([&#39;jeff&#39;, &#39;jack&#39;, &#39;igor&#39;]);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jasminは様々なアサーションを作成するためのたくさんのマッチャーから成っている。
マッチャーについては&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html#section-Matchers&#34;&gt;こちらの記事&lt;/a&gt;を読むこと。
KarmaとJasminを使うために、&lt;a href=&#34;https://github.com/karma-runner/karma-jasmine&#34;&gt;karma-jasmin&lt;/a&gt;を利用する。&lt;/p&gt;

&lt;h4 id=&#34;angular-mocks:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;angular-mocks&lt;/h4&gt;

&lt;p&gt;Angularはテスト用のモックを提供する&lt;code&gt;ngMock&lt;/code&gt;というものを用意している。
ユニットテスト内でのAngularサービスをモックしたりインジェクトするために用いられる。
加えて、別のモジュールを拡張できるので、同期的だ。
テストを同期することで明確に保ち、簡単に動作させることができる。
もっとも便利なうちのひとつが&lt;code&gt;$httpBackend&lt;/code&gt;だ。
テストでXHRリクエストのモックを行うことができ、代わりにサンプルのデータを返す。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-a-controller:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing a Controller&lt;/h3&gt;

&lt;p&gt;Angularのビューレイヤーはロジックから切り離されているので、コントローラを簡単にテストすることができる。
下記でコントローラをどのようにテストしているか見ていこう。
パスワードの長さに基づいてスコープのプロパティをセットする&lt;code&gt;$scope.grade&lt;/code&gt;を提供している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.module(&#39;app&#39;, [])
.controller(&#39;PasswordController&#39;, function PasswordController($scope) {
  $scope.password = &#39;&#39;;
  $scope.grade = function() {
    var size = $scope.password.length;
    if (size &amp;gt; 8) {
      $scope.strength = &#39;strong&#39;;
    } else if (size &amp;gt; 3) {
      $scope.strength = &#39;medium&#39;;
    } else {
      $scope.strength = &#39;weak&#39;;
    }
  };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コントローラはグローバルスコープでは利用できないため、
はじめに&lt;code&gt;angular.mock.inject&lt;/code&gt;を使ってコントローラをインジェクトする必要がある。
最初のステップは、angular-mocksが提供する&lt;code&gt;module&lt;/code&gt;関数を使うことだ。
この関数は与えられたモジュールを読み込み、読み込まれたモジュールはテスト内で利用う可能となる。
これをJasminの提供する関数であり、各テストの前にコードを実行できる&lt;code&gt;beforeEach&lt;/code&gt;に渡す。
そしてコントローラのインスタンス化に責任を持つサービス&lt;code&gt;$controller&lt;/code&gt;にアクセスするために&lt;code&gt;inject&lt;/code&gt;を用いる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ネストした&lt;code&gt;describe&lt;/code&gt;の呼び出しや、文字列を用いて呼び出す時の描写でテストが明確になっていることに注目する。
何をテストしているかハッキリと記し、何が起きているかを簡単に理解できる。
では3文字以下のパスワードを追加して、&lt;code&gt;$scope.strength&lt;/code&gt;が&amp;rdquo;weak&amp;rdquo;であるか見ていこう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });

    it(&#39;sets the strength to &amp;quot;weak&amp;quot; if the password length &amp;lt;3 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;a&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;weak&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在２つのテストがあるが、テストが重複していることに気付いて欲しい。
両方で&lt;code&gt;$scope&lt;/code&gt;を作成しており、コントローラを生成している。
テストを重複するならこの重複は良くない。
ありがたいことにJasminには&lt;code&gt;beforeEach&lt;/code&gt;がある。
個々のテストの前に関数を実行してくれる。
どのようにテストをセットするか確認しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    var $scope, controller;

    beforeEach(function() {
      $scope = {};
      controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
    });

    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });

    it(&#39;sets the strength to &amp;quot;weak&amp;quot; if the password length &amp;lt;3 chars&#39;, function() {
      $scope.password = &#39;a&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;weak&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重複部分を外へ出し、&lt;code&gt;beforeEach&lt;/code&gt;ブロックへ移動した。
これで個々のテストには特有のコードだけになり、全体に入っているようなコードはなくなった。
テストを拡張するうえで、テストをきちんとするためにどこで&lt;code&gt;beforeEach&lt;/code&gt;を使えるか目を見張ることだ。
Jasminが提供するのは&lt;code&gt;beforeEach&lt;/code&gt;だけじゃない。&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html#section-Setup_and_Teardown&#34;&gt;こちら&lt;/a&gt;も見てみること。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-filters:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Filters&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.angularjs.org/api/ng/provider/$filterProvider&#34;&gt;フィルタ&lt;/a&gt;はデータをユーザが読みやすいフォーマットに変換する。
これはフォーマットの責任をアプリケーションロジックから取り除くことになるのでとても重要なこと。さらにはアプリケーションロジックを単純にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myModule.filter(&#39;length&#39;, function() {
  return function(text) {
    return (&#39;&#39; + (text || &#39;&#39;)).length;
  }
});

describe(&#39;length filter&#39;, function() {

  var $filter;

  beforeEach(inject(function(_$filter_){
    $filter = _$filter_;
  }));

  it(&#39;returns 0 when given null&#39;, function() {
    var length = $filter(&#39;length&#39;);
    expect(length(null)).toEqual(0);
  });

  it(&#39;returns the correct value when given a string of chars&#39;, function() {
    var length = $filter(&#39;length&#39;);
    expect(length(&#39;abc&#39;)).toEqual(3);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-directives:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Directives&lt;/h3&gt;

&lt;p&gt;AngularのディレクティブはカスタムHTMLタグや属性、クラス、コメントと複雑な機能に責任を持っている。
ディレクティブを使って生成したコンポーネントがさまざまな背景で思った通りに使われているかのテストになるので、
ディレクティブのユニットテストはとても重要です。&lt;/p&gt;

&lt;h4 id=&#34;simple-html-element-directive:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Simple HTML Element Directive&lt;/h4&gt;

&lt;p&gt;依存関係のないAngularアプリで始める。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = angular.module(&#39;myApp&#39;, []);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アプリにディレクティブを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.directive(&#39;aGreatEye&#39;, function () {
    return {
        restrict: &#39;E&#39;,
        replace: true,
        template: &#39;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&#39;
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&lt;/code&gt;といったタグでこのディレクティブは利用する。
タグごと&lt;code&gt;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&lt;/code&gt;テンプレートを置き換えるものだ。
その機能を確認するためのJasminテストを書いていく。
レンダリングされると&lt;code&gt;{{1 + 1}}&lt;/code&gt;式が評価されることに注意する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;Unit testing great quotes&#39;, function() {
  var $compile,
      $rootScope;

  // ディレクティブを含んだmyAppモジュールを読み込む
  beforeEach(module(&#39;myApp&#39;));

  // $rootScopeと$compileへの参照を保持する
  // このdescribeブロックにおいて全てのテストで利用可能になる
  beforeEach(inject(function(_$compile_, _$rootScope_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $compile = _$compile_;
    $rootScope = _$rootScope_;
  }));

  it(&#39;Replaces the element with the appropriate content&#39;, function() {
    // ディレクティブのHTMLをコンパイルする
    var element = $compile(&amp;quot;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&amp;quot;)($rootScope);
    // ウォッチャーを発火させ、式を評価する
    $rootScope.$digest();
    // コンパイルされた要素がテンプレートの中身を含んでいることを確認する
    expect(element.html()).toContain(&amp;quot;lidless, wreathed in flame, 2 times&amp;quot;);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$compile&lt;/code&gt;サービスと&lt;code&gt;$rootScope&lt;/code&gt;をJasminテストの前にインジェクトする。
&lt;code&gt;$compile&lt;/code&gt;サービスはaGreatEyeディレクティブをレンダリングするために利用する。
レンダリング後に、&amp;rdquo;lidless, wreathed in flame, 2 times&amp;rdquo;は現れる。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Underscore notation:&lt;/strong&gt; &lt;code&gt;_$rootScope_&lt;/code&gt;といったアンダースコアの使い方は、テスト内での変数名をきれいに保つためAngularJSコミュニティ内で広く広がった風習である。
パラメータがマッチングした際に、&lt;code&gt;$injector&lt;/code&gt;がアンダースコアを取り払うのはこれが理由である。
このアンダースコアルールが働くのは名前が一つのアンダースコアで始まり一つのアンダースコアで終わる時のみに限られ、それ以外での置換は起こらない。&lt;/p&gt;

&lt;h4 id=&#34;testing-transclusion-directives:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Transclusion Directives&lt;/h4&gt;

&lt;p&gt;トランスクルージョンを使ったディレクティブはコンパイラに特別に扱われる。
コンパイル関数が呼び出される前に、ディレクティブ要素のコンテンツは取り除かれ、トランスクルージョン関数を通して提供される。
ディレクティブのテンプレートはその際に、ディレクティブ要素に追加され、トランスクルードされたコンテンツをテンプレート内に挿入する。&lt;/p&gt;

&lt;p&gt;コンピレーション前:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;
  Some transcluded content
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トランスクルージョンが引き抜かれる:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンピレーション後:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;
  Some Template
  &amp;lt;span ng-transclude&amp;gt;Some transcluded content&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ディレクティブが&amp;rdquo;要素&amp;rdquo;のトランスクルージョンを利用しているのであれば、コンパイラは実質的にDOMからディレクティブ全体の要素を取り除き、
コメントノードを持ってそれを置き換える。
そしてコンパイラはディレクティブのテンプレートをコメントノードの&lt;strong&gt;後に&lt;/strong&gt;、兄弟として挿入する。&lt;/p&gt;

&lt;p&gt;コンピレーション前:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div element-transclude&amp;gt;
  Some Content
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トランスクルージョンが引き抜かれる:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- elementTransclude --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンピレーション後:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- elementTransclude --&amp;gt;
&amp;lt;div element-transclude&amp;gt;
  Some Template
  &amp;lt;span ng-transclude&amp;gt;Some transcluded content&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要素のトランスクルージョンを使ったディレクティブのテストを書いている時に、このことに気づくことが重要。
もし&lt;code&gt;$compile&lt;/code&gt;へ渡すDOMフラグメントのルート要素にディレクティブを置くのであれば、関連する関数から返されるDOMノードはコメントノードであり、テンプレートとトランスクルードされたコンテンツを繋ぐ能力には負けるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var node = $compile(&#39;&amp;lt;div element-transclude&amp;gt;&amp;lt;/div&amp;gt;&#39;)($rootScope);
expect(node[0].nodeType).toEqual(node.COMMENT_NODE);
expect(node[1]).toBeUndefined();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに対処するためには単純に要素をトランスクルードするディレクティブを&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;のようなエレメントでラップする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var node = $compile(&#39;&amp;lt;div&amp;gt;&amp;lt;div element-transclude&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&#39;)($rootScope);
var contents = node.contents();
expect(contents[0].nodeType).toEqual(node.COMMENT_NODE);
expect(contents[1].nodeType).toEqual(node.ELEMENT_NODE);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;testing-directives-with-external-templates:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Directives With External Templates&lt;/h4&gt;

&lt;p&gt;もぢディレクティブで&lt;code&gt;templateUrl&lt;/code&gt;を使っているのであれば、HTMLテンプレートをプリコンパイルするために&lt;a href=&#34;https://github.com/karma-runner/karma-ng-html2js-preprocessor&#34;&gt;karma-ng-html2js-preprocessor&lt;/a&gt;を使うことを考え、HTTPリクエストを使ってテキストをロードすることは避けること。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ES6とReact試してみた</title>
      <link>http://kotazi.github.io/blog/post/2016/0130_react_calendar/</link>
      <pubDate>Mon, 01 Feb 2016 12:06:51 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0130_react_calendar/</guid>
      <description>&lt;p&gt;FullCalendarとReactとES6を使ったサンプルを作ってみた。&lt;/p&gt;

&lt;p&gt;jQueryとReactは相性が悪いと聞いていたが、特に感じられなかった。&lt;/p&gt;

&lt;p&gt;&lt;p data-height=&#34;266&#34; data-theme-id=&#34;15717&#34; data-slug-hash=&#34;KVoXob&#34; data-default-tab=&#34;result&#34; data-user=&#34;kotazi&#34; class=&#39;codepen&#39;&gt;See the Pen &lt;a href=&#39;http://codepen.io/kotazi/pen/KVoXob/&#39;&gt;FullCalendar With React ES6&lt;/a&gt; by Kohei  Saeki (&lt;a href=&#39;http://codepen.io/kotazi&#39;&gt;@kotazi&lt;/a&gt;) on &lt;a href=&#39;http://codepen.io&#39;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;script async src=&#34;//assets.codepen.io/assets/embed/ei.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【訳読】React Tutorial</title>
      <link>http://kotazi.github.io/blog/post/2016/0128_react/</link>
      <pubDate>Thu, 28 Jan 2016 23:08:28 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0128_react/</guid>
      <description>

&lt;p&gt;勉強がてら&lt;a href=&#34;https://facebook.github.io/react/docs/tutorial.html&#34;&gt;Reactチュートリアル&lt;/a&gt;を翻訳しました。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&#34;tutorial:c4edc588c83982a0e8967944828e886f&#34;&gt;Tutorial&lt;/h2&gt;

&lt;p&gt;シンプルではあるものの、ブログに書ける現実的なコメントボックスを実装していく。
この基本バージョンのリアルタイムコメントはDisqusやLibeFyre、Facebook commentsにオファーをいただいた。&lt;/p&gt;

&lt;p&gt;提供する機能:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全てのコメントのView&lt;/li&gt;
&lt;li&gt;コメントを送信するためのフォーム&lt;/li&gt;
&lt;li&gt;バックエンドをカスタムするためのHook&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;またこれらの機能もしっかり備えている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;オプティミスティックコメント&lt;/strong&gt;: サーバーに保存される前にコメントが表示されるため非常に速い&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ライブアップデート&lt;/strong&gt;: 他者のコメントがリアルタイムで反映される&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Markdown対応&lt;/strong&gt;: Markdownによる記述が可能&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;want-to-skip-all-this-and-just-see-the-source:c4edc588c83982a0e8967944828e886f&#34;&gt;Want to skip all this and just see the source?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/react-tutorial&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;running-a-server:c4edc588c83982a0e8967944828e886f&#34;&gt;Running a server&lt;/h3&gt;

&lt;p&gt;チュートリアルを開始するためには、稼働しているサーバーが必要。
あくまでデータの取得と保存に使用するAPIエンドポイントとしてのサーバーだ。&lt;/p&gt;

&lt;p&gt;できるだけ簡単にするため、仕様を実現するシンプルなサーバーをいくつかのスクリプト言語で用意した。
開始に必要なものは&lt;a href=&#34;https://github.com/reactjs/react-tutorial/&#34;&gt;こちら&lt;/a&gt;からインストール可能。&lt;/p&gt;

&lt;p&gt;簡潔にするために、実行するサーバーはJSONファイルをデータベースとして利用する。
本番でこんなことはしないが、APIを用いたシュミレーションを行うには簡単でいいだろう。
一度サーバーを起動したら、APIエンドポイントをサポートし、必要なスタティックペーシを出してくれる。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;getting-started:c4edc588c83982a0e8967944828e886f&#34;&gt;Getting started&lt;/h3&gt;

&lt;p&gt;このチュートリアルでは、できるだけ簡単なものにしていくつもりである。
サーバーパッケージの中に私たちが動かすHTMLファイルが含まれている。
&lt;code&gt;public/index.html&lt;/code&gt;を好みのエディタで開いてみてほしい。このようになっているはずだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;React Tutorial&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.6/react.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.6/react-dom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/babel&amp;quot; src=&amp;quot;scripts/example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt;
      // To get started with this tutorial running your own code, simply remove
      // the script tag loading scripts/example.js and start writing code here.
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このチュートリアルのリマインダーとして、このスクリプトタグの中にコードを記述している。
ライブリロードは備えていないので、ファイルを更新した際はブラウザをリロードすること。
(サーバー起動後、)ブラウザで&lt;code&gt;http://localhost:3000&lt;/code&gt;を開けば進捗が確認できる。
このファイルをそのまま開けば、完成したプロダクトを確認することができる。
準備ができたら&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグを削除して続けよう。&lt;/p&gt;

&lt;p&gt;注意: ajax呼び出しをシンプルに記述するため、jQueryを含んでいるが必ずしも必要なわけではない。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;your-first-component:c4edc588c83982a0e8967944828e886f&#34;&gt;Your first component&lt;/h3&gt;

&lt;p&gt;Reactは要するにmodular, composable componentsである。
コメントボックスのサンプルとして、次のようなコンポーネント構造を持つことにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- CommentBox
  - CommentList
    - Comment
  - CommentForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シンプルに&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;を使って、&lt;code&gt;CommentBox&lt;/code&gt;コンポーネントを作成しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial1.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        Hello, world! I am a CommentBox.
      &amp;lt;/div&amp;gt;
    );
  }
});
ReactDOM.render(
  &amp;lt;CommentBox /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ネイティブのHTMLエレメント名が小文字で綴られていることに注意。
Reactクラスは大文字で始まっている。&lt;/p&gt;

&lt;h5 id=&#34;jsx-syntax:c4edc588c83982a0e8967944828e886f&#34;&gt;JSX Syntax&lt;/h5&gt;

&lt;p&gt;JSがXMLのような構文だったことに気づかれただろう。
シンタックスシュガーをピュアJSに変換するシンプルなプリコンパイラを備えている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial1-raw.js
var CommentBox = React.createClass({displayName: &#39;CommentBox&#39;,
  render: function() {
    return (
      React.createElement(&#39;div&#39;, {className: &amp;quot;commentBox&amp;quot;},
        &amp;quot;Hello, world! I am a CommentBox.&amp;quot;
      )
    );
  }
});
ReactDOM.render(
  React.createElement(CommentBox, null),
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任意ではあるがJSXシンタックスを使ったほうがかんだんだ。
JSXについては&lt;a href=&#34;https://facebook.github.io/react/docs/jsx-in-depth.html&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;what-s-going-on:c4edc588c83982a0e8967944828e886f&#34;&gt;What&amp;rsquo;s going on&lt;/h5&gt;

&lt;p&gt;新しいReactコンポーネントを作成するために、&lt;code&gt;React.createClass()&lt;/code&gt;にいくつかのメソッドを持ったJSオブジェクトを渡した。
これらのメソッドの中で最も重要なものが&lt;code&gt;render&lt;/code&gt;メソッドだ。
Reactコンポーネントのツリー構造を返り値にし、ゆくゆくはHTMLにレンダリングするメソッドだ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;タグは実際のDOMノードではない。Reactの&lt;code&gt;div&lt;/code&gt;コンポーネントのインスタンスである。
これらのことはReactの操作方法を知るデータの欠片や印と思ってくれていい。
Reactは安全だ。
HTML文字列を生成しないため、XSS対策をデフォルトでしていることになる。&lt;/p&gt;

&lt;p&gt;基本的なHTMLを返す必要はない。あなた(もしくは誰か)の組み立てたコンポーネントのツリーを返せばいい。
これがReactをcomposableにしてくれる。フロントエンドを保守するキーとなる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;はルートコンポーネントをインスタンス化し、骨組みを作る。
そしてマークアップ部分を生のDOMへ注入し、ふたつ目の引数として提供される。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReactDOM&lt;/code&gt;モジュールはDOM特有のメソッドを提供する。
&lt;code&gt;React&lt;/code&gt;は&lt;a href=&#34;http://facebook.github.io/react-native/&#34;&gt;React Native&lt;/a&gt;といったことなるプラットフォーム上で共有されるコアのツールを持つ。
&lt;code&gt;ReactDOM.render&lt;/code&gt;がこのチュートリアルのスクリプトの最下部にとどまることは重要な事だ。
&lt;code&gt;ReactDOM.render&lt;/code&gt;は複合的なコンポーネントが定義された後に呼び出されるべきだからである。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;composing-components:c4edc588c83982a0e8967944828e886f&#34;&gt;Composing components&lt;/h3&gt;

&lt;p&gt;それでは再びシンプルな&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;を使って&lt;code&gt;CommentList&lt;/code&gt;と&lt;code&gt;CommentForm&lt;/code&gt;の骨組みを作成しよう。
ファイルに２つのコンポーネントを作成し、&lt;code&gt;CommentBox&lt;/code&gt;宣言を保ったうえで&lt;code&gt;ReactDOM.render&lt;/code&gt;を呼び出す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial2.js
var CommentList = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        Hello, world! I am a CommentList.
      &amp;lt;/div&amp;gt;
    );
  }
});

var CommentForm = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentForm&amp;quot;&amp;gt;
        Hello, world! I am a CommentForm.
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いて&lt;code&gt;CommentBox&lt;/code&gt;コンポーネントを更新し、新しいコンポーネントを利用する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial3.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どのようにしてHTMLタグと作成したコンポーネントを混在させるかに注意すること。
HTMLコンポーネントは通常Reactコンポーネントであり、ひとつの違いはあるが、あなたが定義したもののようだ。
JSXコンパイラは自動的にHTMLタグを&lt;code&gt;React.createElement(tagName)&lt;/code&gt;式に書き直し、全てを孤独にする。
これが名前名前汚染を防ぐことになる。&lt;/p&gt;

&lt;h4 id=&#34;using-props:c4edc588c83982a0e8967944828e886f&#34;&gt;Using props&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Comment&lt;/code&gt;コンポーネントを作成しよう。親から渡されたデータに依存するものになる。
親コンポーネントから渡されたデータは子コンポーネントの&lt;code&gt;property&lt;/code&gt;として利用可能だ。
これらのプロパティには&lt;code&gt;this.props&lt;/code&gt;を使ってアクセスする。&lt;code&gt;props&lt;/code&gt;を使えば、&lt;code&gt;CommentList&lt;/code&gt;から渡された&lt;code&gt;Comment&lt;/code&gt;を読むことができ、レンダリングも可能だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial4.js
var Comment = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        {this.props.children}
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSXの中のJavaScript式を取り囲むことで、ツリー内にReactコンポーネントを書くことができる。
コンポーネントの属性やネストされた要素に&lt;code&gt;this.props&lt;/code&gt;や&lt;code&gt;this.props.children&lt;/code&gt;を用いてアクセスする。&lt;/p&gt;

&lt;h4 id=&#34;component-properties:c4edc588c83982a0e8967944828e886f&#34;&gt;Component Properties&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Comment&lt;/code&gt;コンポーネントの定義が完了したところで、コンポーネントに名前とコメント分を渡していきたい。
各ユニークなコメントに対して同じコードの再利用が可能になる。
&lt;code&gt;CommentList&lt;/code&gt;にコメントを追加してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial5.js
var CommentList = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        &amp;lt;Comment author=&amp;quot;Pete Hunt&amp;quot;&amp;gt;This is one comment&amp;lt;/Comment&amp;gt;
        &amp;lt;Comment author=&amp;quot;Jordan Walke&amp;quot;&amp;gt;This is *another* comment&amp;lt;/Comment&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;親の&lt;code&gt;CommentList&lt;/code&gt;コンポーネントから子の&lt;code&gt;Comment&lt;/code&gt;コンポーネントにデータを渡していることに注目。
たとえば、属性をお通して&amp;rdquo;Pete Hunt&amp;rdquo;、XMLのような子ノードで&amp;rdquo;This is one comment&amp;rdquo;を渡している。
さらに、&lt;code&gt;Comment&lt;/code&gt;コンポーネントはこれらのプロパティに&lt;code&gt;this.props.author&lt;/code&gt;や&lt;code&gt;this.props.children&lt;/code&gt;を通してアクセスしている。&lt;/p&gt;

&lt;h4 id=&#34;adding-markdown:c4edc588c83982a0e8967944828e886f&#34;&gt;Adding Markdown&lt;/h4&gt;

&lt;p&gt;Markdownはテキストをシンプルに記述するためのフォーマットだ。
例えばテキストをアスタリスクで囲めば、テキストを強調させる。&lt;/p&gt;

&lt;p&gt;このチュートリアルでは、受け取ったMarkdownを生のHTMLにコンバートするサードパーティライブラリである*marked*を利用する。既にこのライブラリは読み込んであるので、もう使いはじめることができる。コメント文のMarkdownをコンバートして出力しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial6.js
var Comment = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        {marked(this.props.children.toString())}
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではmarkedライブラリの呼び出しを行っているだけだ。&lt;code&gt;this.props.children&lt;/code&gt;をReactのラッパーテキストからmarkedが理解できるように生の文字列にコンバートする必要があるため&lt;code&gt;toString()&lt;/code&gt;を呼び出している。&lt;/p&gt;

&lt;p&gt;けれども問題がひとつ！レンダリングされたコメントが&lt;code&gt;&amp;lt;p&amp;gt;This is &amp;lt;em&amp;gt;another&amp;lt;/em&amp;gt; comment&amp;lt;/p&amp;gt;&lt;/code&gt;のようになっている。
タグを実際のHTMLとしてレンダリングしたいのに。&lt;/p&gt;

&lt;p&gt;これは&lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-site_scripting&#34;&gt;XSS攻撃&lt;/a&gt;からの防御手段となる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial7.js
var Comment = React.createClass({
  rawMarkup: function() {
    var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
    return { __html: rawMarkup };
  },

  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        &amp;lt;span dangerouslySetInnerHTML={this.rawMarkup()} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特別なAPIを使って故意に生HTMLの挿入を難しくしているが、markedにとってはメリットとなる。&lt;/p&gt;

&lt;p&gt;こうすることでmarkedの安全性に信頼を置くことができる。このケースでは、&lt;code&gt;sanitize: true&lt;/code&gt;を渡してmarkedにそのまま渡すのではなくソース内のどんなHTMLでもエスケープするように伝えた。&lt;/p&gt;

&lt;h4 id=&#34;hook-up-the-data-model:c4edc588c83982a0e8967944828e886f&#34;&gt;Hook up the data model&lt;/h4&gt;

&lt;p&gt;これまで私たちはコメントをソースコード内に直接挿入してきた。
代わりにJSONデータの塊をコメントリストにレンダリングしてみよう。
ゆくゆくはサーバーから受け取るデータだが、ここではコード内に記述しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial8.js
var data = [
  {id: 1, author: &amp;quot;Pete Hunt&amp;quot;, text: &amp;quot;This is one comment&amp;quot;},
  {id: 2, author: &amp;quot;Jordan Walke&amp;quot;, text: &amp;quot;This is *another* comment&amp;quot;}
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;データをモジュール方式に&lt;code&gt;CommentList&lt;/code&gt;に入れる必要がある。
&lt;code&gt;CommentBox&lt;/code&gt;を修正し、このデータをプロパティを通して&lt;code&gt;CommentList&lt;/code&gt;に入れるために&lt;code&gt;ReactDom.render()&lt;/code&gt;を呼び出す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial9.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.props.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});

ReactDOM.render(
  &amp;lt;CommentBox data={data} /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでデータが&lt;code&gt;CommentList&lt;/code&gt;内で利用可能になる、コメントをレンダリングしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial10.js
var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (
        &amp;lt;Comment author={comment.author} key={comment.id}&amp;gt;
          {comment.text}
        &amp;lt;/Comment&amp;gt;
      );
    });
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        {commentNodes}
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;fetching-from-the-server:c4edc588c83982a0e8967944828e886f&#34;&gt;Fetching from the server&lt;/h4&gt;

&lt;p&gt;ハードコーディングしてあるデータをサーバーから受け取るように書き換えよう。
データプロパティを取り除き、フェッチするURLに置き換える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial11.js
ReactDOM.render(
  &amp;lt;CommentBox url=&amp;quot;/api/comments&amp;quot; /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコンポーネントは先ほどまでのコンポーネントとは異なる。なぜなら自身で再度レンダリングする必要があるからだ。
コンポーネントにはサーバーからのリクエストが返ってくるまで何もデータがなく、返ってきたら新しいコメントをレンダリングする必要がある。&lt;/p&gt;

&lt;h4 id=&#34;reactive-state:c4edc588c83982a0e8967944828e886f&#34;&gt;Reactive state&lt;/h4&gt;

&lt;p&gt;これまではプロパティに基づいて各コンポーネントは1回だけレンダリングをしてきた。
&lt;code&gt;props&lt;/code&gt;は不変のものだったのだ。親からもらったり、自身で所持していたり。
インタラクションを実装するために、コンポーネントにmutable(変わりやすい)stateを紹介する。
&lt;code&gt;this.state&lt;/code&gt;はprovateであり、&lt;code&gt;this.setState()&lt;/code&gt;を呼び出すことで変更される。
ステートが更新されると、コンポーネントは自身を再レンダリングする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;render()&lt;/code&gt;メソッドは&lt;code&gt;this.props&lt;/code&gt;と&lt;code&gt;this.state&lt;/code&gt;の関数の宣言的に記述されている。
フレームワークはUIが常に入力に対して安定していることを保証する。&lt;/p&gt;

&lt;p&gt;サーバーがデータをフェッチすると、所持しているコメントデータを変更する必要がある。
&lt;code&gt;CommentBox&lt;/code&gt;コンポーネントに自身のステートとしてコメントデータの配列を追加しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial12.js
var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getInitialState()&lt;/code&gt;はコンポーネントのライフサイクルの中で正確に一度だけ実行され、コンポーネントの初期ステートをセットアップする。&lt;/p&gt;

&lt;h4 id=&#34;updating-state:c4edc588c83982a0e8967944828e886f&#34;&gt;Updating state&lt;/h4&gt;

&lt;p&gt;コンポーネントが最初に作成されたら、サーバーからJSONをGETし、最新のデータを反映させるためにステートを更新したい。
サーバーへの非同期通信を行い、必要なデータを手早くフェッチするためにjQueryを使うつもりだ。
起動しているサーバーの中には既にデータが含まれている。(&lt;code&gt;comments.json&lt;/code&gt;)
なので一度フェッチして、&lt;code&gt;this.state.date&lt;/code&gt;を見ていこう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {&amp;quot;author&amp;quot;: &amp;quot;Pete Hunt&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;This is one comment&amp;quot;},
  {&amp;quot;author&amp;quot;: &amp;quot;Jordan Walke&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;This is *another* comment&amp;quot;}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// tutorial13.js
var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;componentDidMount&lt;/code&gt;メソッドはコンポーネントが最初にレンダリングされた際にReactから自動的に呼び出されるメソッドである。
ダイナミックな更新のキーとなっているのが&lt;code&gt;this.setState()&lt;/code&gt;の呼び出しである。
古いコメントの配列をサーバーから取得した新しい物に置き換え、UIを自動的に更新する。
このリアクティブ性のために、小さな変更を加えライブアップデートを実現する。
ここではシンプルなポーリングを行うが、WebSocketやその他のテクノロジーを使うため簡単にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial14.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});

ReactDOM.render(
  &amp;lt;CommentBox url=&amp;quot;/api/comments&amp;quot; pollInterval={2000} /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この変更で行ったことはAJAX呼び出しのメソッドを分割して移動し、そのメソッドをコンポーネントの初期読み込み時とその後毎2秒おきに呼び出すというものだ。試しにブラウザで実行し&lt;code&gt;comments.json&lt;/code&gt;を変更してみよう。
2秒以内に変更が反映されるはずだ！&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;adding-new-comments:c4edc588c83982a0e8967944828e886f&#34;&gt;Adding new comments&lt;/h3&gt;

&lt;p&gt;ここではフォームを組み立てよう。&lt;code&gt;CommentForm&lt;/code&gt;コンポーネントはユーザーに名前とコメントテキストを求め、コメントを保存するためにサーバーへ送信する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial15.js
var CommentForm = React.createClass({
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Your name&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Say something...&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;controlled-components:c4edc588c83982a0e8967944828e886f&#34;&gt;Controlled components&lt;/h4&gt;

&lt;p&gt;伝統的なDOMでは、&lt;code&gt;input&lt;/code&gt;要素はレンダリングされ、ブラウザはステートを管理する。
その結果、実際のDOMのステートとコンポーネントのステートの間に差分が生じる。
ビューのステートがコンポーネントのステートを異なるのは理想的ではない。
Reactの場合、初期化の時だけでなくコンポーネントは常にビューのステートを表す。&lt;/p&gt;

&lt;p&gt;それゆえに、入力されたユーザーのインプットを保存するには&lt;code&gt;this.state&lt;/code&gt;を用いる。
私たちは初期の&lt;code&gt;state&lt;/code&gt;を２つのプロパティ、&lt;code&gt;author&lt;/code&gt;と&lt;code&gt;text&lt;/code&gt;で定義し、それらに空の文字列を入れた。
Reactの&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;要素では、コンポーネントの&lt;code&gt;state&lt;/code&gt;を反映させるための&lt;code&gt;value&lt;/code&gt;プロパティをセットし、&lt;code&gt;onChange&lt;/code&gt;ハンドラをつけた。これらの&lt;code&gt;value&lt;/code&gt;つきの&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;要素は&amp;rdquo;controlled components&amp;rdquo;と呼ばれる。
より詳しく知りければ&lt;a href=&#34;https://facebook.github.io/react/docs/forms.html#controlled-components&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot;&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;events:c4edc588c83982a0e8967944828e886f&#34;&gt;Events&lt;/h4&gt;

&lt;p&gt;Reactではコンポーネントにイベントハンドラを付けるときにキャメルケースを使う。
私たちは２つの&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;要素に&lt;code&gt;onChange&lt;/code&gt;というイベントハンドラをつけた。
ここで、ユーザーが&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;フィールドにテキストを入力した場合、&lt;code&gt;onChange&lt;/code&gt;コールバックは発火し、コンポーネントの&lt;code&gt;state&lt;/code&gt;が変更される。&lt;/p&gt;

&lt;p&gt;その後&lt;code&gt;input&lt;/code&gt;要素のレンダリングされた値は現在のコンポーネントの&lt;code&gt;state&lt;/code&gt;を反映するために更新される。&lt;/p&gt;

&lt;h4 id=&#34;submitting-the-form:c4edc588c83982a0e8967944828e886f&#34;&gt;Submitting the form&lt;/h4&gt;

&lt;p&gt;インタラクティブなフォームを作成しよう！
ユーザーがフォームを送信する時、それらをクリアする必要があり、リクエストをサーバーに送信し、そしてコメントのリストをリフレッシュする。
はじめに、フォームの送信イベントをキャッチしてクリアしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial17.js
var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    // TODO: send request to the server
    this.setState({author: &#39;&#39;, text: &#39;&#39;});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot; onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しい入力でフォームが送信された時はフォームをクリアするような&lt;code&gt;onSubmit&lt;/code&gt;ハンドラを追加した。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;preventDefault()&lt;/code&gt;を呼び出してブラウザのデフォルトのフォーム送信アクションを妨げる。&lt;/p&gt;

&lt;h4 id=&#34;callbacks-as-props:c4edc588c83982a0e8967944828e886f&#34;&gt;Callbacks as props&lt;/h4&gt;

&lt;p&gt;ユーザーがコメントを送信したら、新しいコメントを追加した状態でリストをリフレッシュ留守必要がある。
この全てのロジックを&lt;code&gt;CommentBox&lt;/code&gt;内で行うので、&lt;code&gt;CommentBox&lt;/code&gt;はコメントリストに相応するステートを所有する。&lt;/p&gt;

&lt;p&gt;子コンポーネントから親コンポーネントにデータを渡す必要がある。それを親の&lt;code&gt;render&lt;/code&gt;メソッド内で子に新しいコールバック(&lt;code&gt;handleCommentSubmit&lt;/code&gt;)を渡し、それを子の&lt;code&gt;onCommentSubmit&lt;/code&gt;にバインドすることで実行する。
イベントがトリガーされた時は、コールバックが発動する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial18.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    // TODO: submit to the server and refresh the list
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ユーザがフォームを送信した時は&lt;code&gt;CommentForm&lt;/code&gt;からコールバックを呼びだそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial19.js
var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    this.props.onCommentSubmit({author: author, text: text});
    this.setState({author: &#39;&#39;, text: &#39;&#39;});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot; onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コールバックについて平たく言えば、サーバーに送信してリストをリフレッシュするんだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial20.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;optimization-optimistic-updates:c4edc588c83982a0e8967944828e886f&#34;&gt;Optimization: optimistic updates&lt;/h3&gt;

&lt;p&gt;このアプリケーションについて機能は完璧であるが、コメントが表示されるまでリクエストが完了するのを待たなければならないため遅いように感じる。
アプリがより早く感じられるようにコメントをリストに追加することが可能だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial21.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    var comments = this.state.data;
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now();
    var newComments = comments.concat([comment]);
    this.setState({data: newComments});
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        this.setState({data: comments});
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;congrats:c4edc588c83982a0e8967944828e886f&#34;&gt;Congrats!&lt;/h3&gt;

&lt;p&gt;いくつかのシンプルなステップとを押してコメントボックスを作成することができた。
&lt;a href=&#34;https://facebook.github.io/react/docs/why-react.html&#34;&gt;何故Reactを使うのか&lt;/a&gt;、もしくは&lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html&#34;&gt;APIリファレンス&lt;/a&gt;について学び開発を始めよう！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】コンピュータはなぜ動くのか</title>
      <link>http://kotazi.github.io/blog/post/2016/0127_why_computer/</link>
      <pubDate>Wed, 27 Jan 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0127_why_computer/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4822281655/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4822281655&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;コンピュータはなぜ動くのか～知っておきたいハードウエア＆ソフトウエアの基礎知識～&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4822281655&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;を読んだ。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;本の構成:5107f846ab8915f5eb5dfb42a6814246&#34;&gt;本の構成&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;【第1章】コンピュータの3大原則とは&lt;/li&gt;
&lt;li&gt;【第2章】コンピュータを作ってみよう&lt;/li&gt;
&lt;li&gt;【第3章】一度は体験してほしいハンド・アセンブル&lt;/li&gt;
&lt;li&gt;【第4章】川の流れのようにプログラムは流れる&lt;/li&gt;
&lt;li&gt;【第5章】アルゴリズムと仲良くなる7つのポイント&lt;/li&gt;
&lt;li&gt;【第6章】データ構造と仲良くなる7つのポイント&lt;/li&gt;
&lt;li&gt;【第7章】オブジェクト指向プログラミングを語れるようになろう&lt;/li&gt;
&lt;li&gt;【第8章】作れば分かるデータベース&lt;/li&gt;
&lt;li&gt;【第9章】簡単な実験7つでTCP/IPネットワークを理解する&lt;/li&gt;
&lt;li&gt;【第10章】データを暗号化してみよう&lt;/li&gt;
&lt;li&gt;【第11章】そもそもXMLって何だっけ&lt;/li&gt;
&lt;li&gt;【第12章】SEはコンピュータ・システム構築の現場監督&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;2003年に執筆された本。今から13年も前になるので内容としては古い。
ただ入力・演算・出力から始まり、ハードウェアとソフトウェア、プログラミング、データベース、ネットワークなど、コンピュータの初等教育で扱われる内容をほぼひととおり網羅している。&lt;/p&gt;

&lt;p&gt;現場に役に立つ知識ではないが、間違ったことがかかれているわけでもない。
自分の知らない分野について少し知るという意味ではいい。
特にコンピュータのハードウェア的な動作についてやアセンブルについてはとても勉強になった。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;以下、メモ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コンピュータは「入力、演算、出力」を行う装置である&lt;/li&gt;
&lt;li&gt;プログラムは命令とデータの集合体である&lt;/li&gt;
&lt;li&gt;コンピュータの都合は人間の感覚と異なる場合がある&lt;/li&gt;
&lt;li&gt;コンピュータのハードウェアはたくさん「IC」から構成され、ICには数多くのピンがついている&lt;/li&gt;
&lt;li&gt;ピンは入力用、出力用のいずれか&lt;/li&gt;
&lt;li&gt;CPUは内部で演算を行い、メモリとI/Oを制御&lt;/li&gt;
&lt;li&gt;メモリは命令とデータを記憶&lt;/li&gt;
&lt;li&gt;I/Oは周辺機器と接続し、データの受け渡しを可能にする&lt;/li&gt;
&lt;li&gt;CPUを動作させるためには「クロック信号」という電気信号が必要&lt;/li&gt;
&lt;li&gt;クロック信号を出力する部品を「クロックジェネレータ」と呼ぶ&lt;/li&gt;
&lt;li&gt;レジスタはCPU及びI/Oの中で、データを記憶する部分&lt;/li&gt;
&lt;li&gt;0と1の羅列にニックネームを付けてプログラムする手法を「ニーモニック」と呼ぶ&lt;/li&gt;
&lt;li&gt;「ニーモニック」を使う言語が「アセンブリ言語」&lt;/li&gt;
&lt;li&gt;アセンブリの文法は1行に「ラベル」と「オペコード(命令)」と「オペランド(対象)」を記述するだけ&lt;/li&gt;
&lt;li&gt;アセンブリ言語ではオペランドにレジスタの名前を指定する&lt;/li&gt;
&lt;li&gt;CPU資料を見ればアセンブリ言語を手作業でマシン語に変換でき、それを「ハンドアセンブル」という&lt;/li&gt;
&lt;li&gt;ユークリッドの互除法: 最大公約数を求める&lt;/li&gt;
&lt;li&gt;エラトステネスのふるい: 素数を求める&lt;/li&gt;
&lt;li&gt;線形探索: データを探索&lt;/li&gt;
&lt;li&gt;2分探索: データを探索&lt;/li&gt;
&lt;li&gt;ハッシュ法: データを探索&lt;/li&gt;
&lt;li&gt;バブルソート: データを整列&lt;/li&gt;
&lt;li&gt;クイックソート: データを整列&lt;/li&gt;
&lt;li&gt;スタック: データを山のように積み上げる&lt;/li&gt;
&lt;li&gt;キュー: データを行列のように並ばせる&lt;/li&gt;
&lt;li&gt;LIFO: Last In First Out&lt;/li&gt;
&lt;li&gt;FIFO: First in First Out&lt;/li&gt;
&lt;li&gt;キーはテーブル間のリレーションシップを設定するもの&lt;/li&gt;
&lt;li&gt;インデックスはデータの検索速度を向上させる&lt;/li&gt;
&lt;li&gt;テーブルに登録される1行のデータのまとまりを「レコード」「ロウ」「行」と呼ぶ&lt;/li&gt;
&lt;li&gt;レコードを構成する項目を「フィールド」「カラム」「列」と呼ぶ&lt;/li&gt;
&lt;li&gt;正規化とは、テーブルを複数に分け、個々のテーブルのリレーションシップを設定して、データベースの構造を整理すること&lt;/li&gt;
&lt;li&gt;リレーションシップを設定するためにはテーブルとテーブルを関連ふけるためのフィールドが必要。それを「キー」と呼ぶ&lt;/li&gt;
&lt;li&gt;↑自分から見たら「主キー」、逆から見たら「外部キー」&lt;/li&gt;
&lt;li&gt;トランザクションはトラブルが発生した時にロールバックする&lt;/li&gt;
&lt;li&gt;TCPは送受信者が確認を取りながらデータを受け渡すプロトコル。&lt;/li&gt;
&lt;li&gt;↑このようなデータの送信方式が「ハンドシェイク」&lt;/li&gt;
&lt;li&gt;TCPでは大きなデータはパケット単位に分割する&lt;/li&gt;
&lt;li&gt;あらゆるデータは数値なので、形式が違っても暗号手法は基本的に同じ&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;ざっくりそんな感じ。書き出してみると為になったことけっこうあった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【訳読】JSX</title>
      <link>http://kotazi.github.io/blog/post/2016/0126_jsx/</link>
      <pubDate>Tue, 26 Jan 2016 21:47:07 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0126_jsx/</guid>
      <description>

&lt;p&gt;勉強がてら&lt;a href=&#34;https://jsx.github.io/doc/tutorial.html&#34;&gt;JSXのTutorial&lt;/a&gt;を翻訳しました。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;background:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;JSXはJavaScriptへのコンパイルが可能な、静的型付けかつオブジェクト指向のプログラミング言語です。
JavaScriptよりも頑丈なプログラミング言語が必要だったためにJSXは開発されました。
とはいえ、JSXはとりわけ文や式など、そこそこJavaScriptに近いように作られています。&lt;/p&gt;

&lt;p&gt;ミスタイポや変数名や関数の定義忘れなどをコンパイル時に検知可能のため、静的型付け言語は頑丈なプログラミング言語といえます。
これは特に多くのエンジニアが携わる中規模から大規模のプロジェクトにおいて重要なことです。&lt;/p&gt;

&lt;p&gt;それゆえに、JSXは静的型付け言語として設計されました。
全ての値と変数には静的な型があり、適切な方の値のみを代入することができます。
加えて、全ての関数はパラメータと返り値によって決定されたクロージャーに含まれます。
引数の型が間違っていると代入することはできません。&lt;/p&gt;

&lt;p&gt;またJSXを開発した別の重要な理由として、JSのパフォーマンスを引き上げつことがありました。
JavaScript自身が遅いということはないのですが、大規模開発になると抽象的なレイヤーが肥大化しがちです。
例えば代用的なクラスやアクセサメソッドのことであり、これらはしばしばパフォーマンスにネガティブな影響を与えます。
JSZでは&amp;rdquo;inline expansion&amp;rdquo;によってパフォーマンスを引き上げています。
これはコンパイル時に関数呼び出しが決定したものを、関数本体を呼び出し元の方へ拡張することです。
静的型付け言語のパフォーマンスのちからになります。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;run-hello-world:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Run &amp;ldquo;Hello, World!&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;JSXのプログタムを実行してみましょう。&lt;code&gt;jsx&lt;/code&gt;コマンドを使い、JSXをJavaScriptにコンパイルします。&lt;/p&gt;

&lt;p&gt;まずはnpmでjsxをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたら下記のコードで&lt;code&gt;hello.jsx&lt;/code&gt;を作成しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class _Main {
    static function main(args : string[]) : void {
        log &amp;quot;Hello, world!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下記のコマンドでJSXを実行することができ、&amp;rdquo;Hello, world&amp;rdquo;がコンソール上に出力されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jsx --run hello.jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のセクションではhello.jsxについて詳しく見ていきましょう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;program-structure:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Program Structure&lt;/h3&gt;

&lt;p&gt;ここでは&amp;rdquo;Hello world!&amp;ldquo;サンプルであるhello.jsxについて取り扱っていきます。
このプログラムに名前や静的型付け、クラス構造といったいくつかのJSXの機能を見ることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class _Main {
    static function main(args : string[]) : void {
        log &amp;quot;Hello, world!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_Main&lt;/code&gt;クラスは&lt;code&gt;main&lt;/code&gt;という名前の静的メンバ関数を持ちます。&lt;code&gt;main&lt;/code&gt;関数は文字列型の配列を引数に取り、返り値はありません。
&lt;code&gt;_Main.main(:string[]):&lt;/code&gt;はJSXアプリケーションのエントリーポイントであり、ユーザーがコマンドラインからアプリケーションを実行した時に呼び出されるものです。JSXはJavaのように、トップレベルに文や関数を置くことを許しません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;log&lt;/code&gt;文はJavaScriptの&lt;code&gt;console.log()&lt;/code&gt;をマップしたものです。&lt;/p&gt;

&lt;p&gt;続いて、別の典型的なライブラリのクラスを見ていきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Point {
    var x = 0;
    var y = 0;

    function constructor() {
    }

    function constructor(x : number, y : number) {
        this.set(x, y);
    }

    function constructor(other : Point) {
        this.set(other);
    }

    function set(x : number, y : number) : void {
        this.x = x;
        this.y = y;
    }

    function set(other : Point) : void {
        this.set(other.x, other.y);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見て分かる通り、Pointのメンバ変数であるxとyは型なしで宣言されています。
けれどもそれらの方は初期値からnumber型であることが分かります。&lt;/p&gt;

&lt;p&gt;複数のconstructorsに驚いたかもしれません。
ひとつはパラメータをとらず、他のものはとります。
パラメータの型が重複しています。
あなたが&lt;code&gt;new Point()&lt;/code&gt;を用いてクラスを生成する場合、最初のコンストラクタは引数無しで呼びだされます。
ふたつ目のコンストラクタは、&lt;code&gt;new Point(2, 3)&lt;/code&gt;といったように２つの引数を必要とします。３つめはコピーのコンストラクタとしてひとつ引数にとります。
&lt;code&gt;new Point(42)&lt;/code&gt;や&lt;code&gt;new Point(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;)&lt;/code&gt;といったその他の方法では、コンパイル時にエラーが起きます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Point#set()&lt;/code&gt;関数もまた重複しており、コンパイラは正しい引数の取り方を知っています。&lt;/p&gt;

&lt;Hr&gt;

&lt;h3 id=&#34;static-typing:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Static Typing&lt;/h3&gt;

&lt;p&gt;基本的な型の概要についてはこの章で述べます。プリミティブ型やオブジェクト型、Variant型、Null型がJSZには存在します。&lt;/p&gt;

&lt;h4 id=&#34;pritimive-types:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Pritimive Types&lt;/h4&gt;

&lt;p&gt;JSXには3つのプリミティブ型が存在します。&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;です。
これらの3つはNull型にはならず、不変の型です。&lt;/p&gt;

&lt;p&gt;下の例文では&lt;code&gt;s&lt;/code&gt;、&lt;code&gt;n&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;の変数を型とともに宣言しています。&lt;code&gt;:&lt;/code&gt;マークを使って変数名の右側に記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s : string;
var n : number;
var b : boolean;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型宣言は初期値を代入することで省略することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s = &amp;quot;hello&amp;quot;;  // s is string, initialized as &amp;quot;hello&amp;quot;
var n = 42;       // n is number, initialized as 42
var b = true;     // b is boolean, initialized as true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;object-types:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Object Types&lt;/h4&gt;

&lt;p&gt;オブジェクト型はクラスのインスタンスオブジェクトに参照を持つ方になります。
例えば、関数、文字列配列、Dateオブジェクトは全てオブジェクト型になります。
型が変わりやすいかは各クラスの定義に依存しいます。&lt;/p&gt;

&lt;p&gt;大半のオブジェクトは&lt;code&gt;new&lt;/code&gt;演算子を用いて生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var d = new Date();            // instantiate an object of class Date
var a = new Array.&amp;lt;string&amp;gt;();  // instantiate an array of string
var m = new Map.&amp;lt;number&amp;gt;();    // instantiate an associative map of strings to numbers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayとMapについては初期化式を用いたイニシャライズが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a1 = [] : Array.&amp;lt;string&amp;gt;;  // a1 is Array.&amp;lt;string&amp;gt;, and is empty
var a2 = [ 1, 2, 3 ];          // a2 is Array.&amp;lt;number&amp;gt; with three elements

var m1 : {} : Map.&amp;lt;number&amp;gt;;    // m1 is Map.&amp;lt;number&amp;gt;
var m2 = {                     // m2 is Map.&amp;lt;string&amp;gt;
  en: &amp;quot;Good morning&amp;quot;,
  de: &amp;quot;Guten Morgen&amp;quot;,
  ja: &amp;quot;ãã¯ãããããã¾ã&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Functionクラスの変数のみ、静的関数として生成することや、またfunction式やfunction文を使って生成することが可能です。&lt;/p&gt;

&lt;h4 id=&#34;the-variant-type:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;The Variant Type&lt;/h4&gt;

&lt;p&gt;Variant型は&amp;rdquo;静的型情報がない&amp;rdquo;という意味です。既存のJavaScriptAPIに役立ちます。
バリアント変数を返すJavaScriptライブラリもあるかもしれません。これらの型はコンパイル時に決定することができません。
バリアントの値に対してできることは、variantのあたいかそうでない値かをチェックすることだけです。&lt;/p&gt;

&lt;p&gt;何かする前に値に対してチェックをする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function guessTheType(v : variant) : void {
    if (typeof v == &amp;quot;string&amp;quot;) {
        log &amp;quot;v is string and the value is:&amp;quot; + v as string;
    } else {
        log &amp;quot;v is not string&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nullable-types:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Nullable Types&lt;/h4&gt;

&lt;p&gt;Nullable型はメタ型です。値がnullかもしれないことを示します。
primitive型にnullを代入することは禁止されています。(Object型はデフォルトではnullです。)
Nullable型はこのような目的で使われます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s1 : string;
s1 = &amp;quot;abc&amp;quot;;       // ok
s1 = null;        // compile error!  cannot assign null to string

var s2 : Nullable.&amp;lt;string&amp;gt;;
s2 = &amp;quot;abc&amp;quot;;       // ok
s2 = null;        // ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nullable型の最も特出した使い方は、配列との使い方です。
ある配列の数より多い値にアクセスするとnullを返します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = [ 1, 2, 3 ]; // creates Array.&amp;lt;number&amp;gt; with three elements
a[3];                // out-of-bounds access, returns null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nullableを返すAPIが他にも存在します。例えば&lt;code&gt;&amp;lt;string&amp;gt;#shift() is Nullable.&amp;lt;string&amp;gt;&lt;/code&gt;。
Nullableな値を使った時、その値がnullでないか確認する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function shiftOrReturnEmptyString(args : string[]) : string {
    if (args.length &amp;gt; 0)
        return args.shift();
    else
        return &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードがデバッグモードでコンパイルされる時(デフォルト値です。)、コンパイラは実行時に型の確認コードを埋め込みます。
null値の誤用が検知されると例外が発生します。
ランタイム型確認では&lt;code&gt;--release&lt;/code&gt;オプションでコンパイルを生着することができます。&lt;/p&gt;

&lt;p&gt;より詳しく知るためには&lt;a href=&#34;https://jsx.github.io/doc/typeref.html&#34;&gt;Types&lt;/a&gt;セクションを参照してください。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;expressions:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Expressions&lt;/h3&gt;

&lt;p&gt;JSXにおける演算子の定義はほとんどJavaScriptと同じです。しかしながら違う点もあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;算術演算子は非演算子に数字のみをとります&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var a = 3;
a + 1;      // OK, returns 4
a * a;      // OK, returns 9
a + &amp;quot;abc&amp;quot;;  // compile error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意: 連結演算子(+)による文字列の結合は存在します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ドット演算子によるプロパティアクセスは定義されたプロパティのみになります&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class Point {
    var x : number;
    var y : number;
    function print() : void {
        log this.z;             // compile error! no property named z
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;プロパティではMapかvariantのみにアクセスできます&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var m = {            // m is Map.&amp;lt;string&amp;gt;
    hello: &amp;quot;world!&amp;quot;
};
log m[&amp;quot;hello&amp;quot;];      // OK
log m.hello;         // compile error!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;as&lt;/code&gt;演算子を導入します。型変換に用いられます&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var n = 123;
var s = &amp;quot;value of n is &amp;quot; + (n as string);
log s;               // print &amp;quot;value of n is 123&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;, ||&lt;/code&gt;演算子はBooleanを返します。&lt;code&gt;?:&lt;/code&gt;を導入します。これは&lt;code&gt;||&lt;/code&gt;と等価です。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;https://jsx.github.io/doc/operatorref.html&#34;&gt;Operator Reference&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;h4 id=&#34;statements:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Statements&lt;/h4&gt;

&lt;p&gt;JSXではJavaScriptで提供される多くの構文をサポートします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;log statement&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;log &amp;quot;hello, world&amp;quot;;    // log strings to console, can turned off with compile option: --release
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;assert statement&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var n = 123;
assert n != 0;         // assertions.  also can be turned off with --release
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;try-catch-finally statement&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;try {
    ...
} catch (e : TypeError) {
    // got TypeError
} catch (e : Error) {
    // got Error, which is not TypeError
} catch (e : variant) {
    // applications may throw any kind of value
} finally {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;try-catch-finally statement&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;https://jsx.github.io/doc/statementref.html&#34;&gt;Statement Reference&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;classes-and-interfaces:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Classes and Interfaces&lt;/h3&gt;

&lt;p&gt;JSXはクラスベースのオブジェクト指向言語です。クラスモデルはJavaに似ています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クラスを別のクラスに拡張できる&lt;/li&gt;
&lt;li&gt;クラスは福通のインターフェイスやミックスインを実装する&lt;/li&gt;
&lt;li&gt;すべてのクラスはひとつのルートクラスをシェアする: Objectクラス&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;all classes share a single root class: the Object class
interface Flyable {
    abstract function fly() : void;
}

abstract class Animal {
    function eat() : void {
      log &amp;quot;An animal is eating!&amp;quot;;
    }
}

class Bat extends Animal implements Flyable {
    override function fly() : void {
        log &amp;quot;A bat is flying!&amp;quot;;
    }
}

abstract class Insect {
}

class Bee extends Insect implements Flyable {
    override function fly() : void {
        log &amp;quot;A bee is flying!&amp;quot;;
    }
}

class _Main {

    static function main(args : string[]) : void {
        // fo bar
        var bat = new Bat();

        var animal : Animal = bat; // OK. A bat is an animal.
        animal.eat();

        var flyable : Flyable = bat; // OK. A bat can fly
        flyable.fly();

        // for Bee
        var bee = new Bee();

        flyable = bee; // A bee is also flyable
        flyable.fly();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例において、BatクラスはAnimalクラスを拡張したものであり、&lt;code&gt;Animal#eat()&lt;/code&gt;というメンバ関数を継承しています。そしてAnimal型に変数に代入することも可能です。
BatクラスはまたFlyableクラスの&lt;code&gt;Flyable#fly()&lt;/code&gt;メンバ関数をオーバーライドして実装しています。そのため、Flyableの変数に代入することも可能です。
また、別のflyableクラスがありいます。Beeクラスです。
Flyableインターフェイスを使うことで、例えbeeとbatが完全に異なる組織だったとしても、両方のクラスに対応することができます。&lt;/p&gt;

&lt;p&gt;メンバ関数をオーバーライドした時に、&lt;code&gt;override&lt;/code&gt;キーワードの使用は委任されます。
それにも関わらず、コンパイラはエラーを発生させます。言い換えれば、やっかいなエラーを出す代わりに、予期せぬベースクラスのインターフェイスの変更による編集エラーからあなたを救っています。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;functions-and-closures:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Functions and Closures&lt;/h3&gt;

&lt;p&gt;JSXでは、関数が最初のクラスオブジェクトであり、静的な型をもっています。
&lt;code&gt;var f : function(arg : number) : number&lt;/code&gt;といった関数型の変数を宣言することができます。
関数は引数にnumberを取り、別のnumberを返すといったように。(同じ値を返すかもしれませんがここでは重要ではありません。)
その変数&lt;code&gt;f&lt;/code&gt;は&lt;code&gt;f(42)&lt;/code&gt;といって呼び出しをされ、数値を返しいます。&lt;/p&gt;

&lt;p&gt;function式やfunction文を使ってクロージャーを定義することができあmす。
典型的な方法でGUIプログラミングで人気のイベントリスナやコールバックを実装します。
クロージャーはJavaScriptの&lt;code&gt;this&lt;/code&gt;に似ています。メンバ関数内でクロージャーが出意義された時、メンバ関数のレシーバーを参照します。下記のサンプルを見てください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class _Main {
    var foo = 42;

    function constructor() {
        var f = function() : void {
            log this.foo;
        };

        f(); // says 42
    }

    static function main(args : string[]) : void {
        var o = new _Main();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;function式やfunction文のアノテーションはコンパイラに推測された場合に省略されるかもしれません。
下記の例では、引数のnも式の返り値も&lt;code&gt;Array#map&lt;/code&gt;の定義からnumberになることが推測されます。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;modules:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Modules&lt;/h3&gt;

&lt;p&gt;JSXはモジュールシステムを持ちます。&lt;code&gt;import&lt;/code&gt;式を使ってJSXのクラスライブラリを利用することができます。
例えば、下記のプログラムでは&lt;code&gt;timer.jsx&lt;/code&gt;モジュールを使用し、Timerクラスをエクスポートしています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;timer.jsx&amp;quot;;

class _Main {

    static function main(args : string[]) : void {
        Timer.setTimeout(function() : void {
            log &amp;quot;Hello, world!&amp;quot;;
        }, 1000);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モジュールは複数のクラスをエクスポートしますが、インポートするモジュールを指定したり、インポートしたモジュールにネームスペースをつけたりすることができます。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;interface-to-web-browsers:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Interface to Web Browsers&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;js/web.jsx&lt;/code&gt;モジュールはWebブラウザへのインターフェイスを提供します。
下記のサンプルではどのように挿入するかを見せます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// hello.jsx
import &amp;quot;js/web.jsx&amp;quot;;

class _Main {

    static function main(args : string[]) : void {
        var document = dom.window.document;

        var text = document.createTextNode(&amp;quot;Hello, world!&amp;quot;);
        document.getElementById(&amp;quot;hello&amp;quot;).appendChild(text);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hello, world!&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;hello.jsx.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;p id=&amp;quot;hello&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以前コマンドからコンパイルした&lt;code&gt;hello.jsx&lt;/code&gt;を用いて、アクセスしたHTMLで&amp;rdquo;Hello, world!&amp;ldquo;を確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bin/jsx --executable web --output hello.jsx.js hello.jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;further-learning:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Further Learning&lt;/h3&gt;

&lt;p&gt;より詳しいドキュメントは&lt;a href=&#34;https://github.com/jsx/JSX/wiki&#34;&gt;wiki&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;p&gt;サンプルを探しているのであれば、&lt;a href=&#34;https://jsx.github.io/#examples&#34;&gt;example&lt;/a&gt;を参照してください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【FullCalendar】Current Date</title>
      <link>http://kotazi.github.io/blog/post/2016/0125_calendar/</link>
      <pubDate>Mon, 25 Jan 2016 22:53:46 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0125_calendar/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fullcalendar.io/docs/current_date/&#34;&gt;Current Date&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;agendaWeek&lt;/code&gt;と&lt;code&gt;agendaDay&lt;/code&gt;用のオプションです。&lt;/p&gt;

&lt;hr&gt;

&lt;h5 id=&#34;defaultdate-http-fullcalendar-io-docs-current-date-defaultdate:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/defaultDate&#34;&gt;defaultDate&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;最初の読み込み時に表示する日時。&lt;/p&gt;

&lt;h5 id=&#34;nowindicator-http-fullcalendar-io-docs-current-date-nowindicator:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/nowIndicator&#34;&gt;nowIndicator&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;現在時刻にマーカーを引くかどうか。&lt;/p&gt;

&lt;h5 id=&#34;prev-method-http-fullcalendar-io-docs-current-date-prev:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/prev&#34;&gt;prev (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;前に戻るためのメソッド。&lt;/p&gt;

&lt;h5 id=&#34;next-method-http-fullcalendar-io-docs-current-date-next:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/next&#34;&gt;next (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;次に進むためのメソッド。&lt;/p&gt;

&lt;h5 id=&#34;prevyear-method-http-fullcalendar-io-docs-current-date-prevyear:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/prevYear&#34;&gt;prevYear (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;前年に戻る。&lt;/p&gt;

&lt;h5 id=&#34;nextyear-method-http-fullcalendar-io-docs-current-date-nextyear:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/nextYear&#34;&gt;nextYear (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;翌年に進む。&lt;/p&gt;

&lt;h5 id=&#34;today-method-http-fullcalendar-io-docs-current-date-today:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/today&#34;&gt;today(method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;今日を表示する。&lt;/p&gt;

&lt;h5 id=&#34;gotodate-method-http-fullcalendar-io-docs-current-date-gotodate:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/gotoDate&#34;&gt;gotoDate(method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;指定日へ移動する。&lt;/p&gt;

&lt;h5 id=&#34;incrementdate-method-http-fullcalendar-io-docs-current-date-incrementdate:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/incrementDate&#34;&gt;incrementDate(method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;指定日時分だけ移動する。&lt;/p&gt;

&lt;h5 id=&#34;getdate-method-http-fullcalendar-io-docs-current-date-getdate:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/getDate&#34;&gt;getDate(method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;日付を取得する。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】How Google Works</title>
      <link>http://kotazi.github.io/blog/post/2016/0129_google/</link>
      <pubDate>Sun, 24 Jan 2016 18:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0129_google/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4532319552/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4532319552&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;How Google Works (ハウ・グーグル・ワークス)  ―私たちの働き方とマネジメント&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4532319552&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;を読んだ。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;ラリー・ペイジとセルゲイ・ブリンによって創業された企業「Google」。&lt;br /&gt;
そのGoogleの働き方について書かれた本である。著者は元CEOのエリック・シュミット。&lt;/p&gt;

&lt;p&gt;この本は次の各章から構成される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;はじめに&lt;/li&gt;
&lt;li&gt;文化&lt;/li&gt;
&lt;li&gt;戦略&lt;/li&gt;
&lt;li&gt;人材&lt;/li&gt;
&lt;li&gt;意思決定&lt;/li&gt;
&lt;li&gt;コミュニケーション&lt;/li&gt;
&lt;li&gt;イノベーション&lt;/li&gt;
&lt;li&gt;おわりに&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;文化や人材、イノベーションといった様々な分野からGoogleという企業について語られる。
非常に学びどころの多い本であったが、ひとつ大事なキーワードを挙げるとすれば、
「スマート・クリエイティブ」だろう。&lt;/p&gt;

&lt;p&gt;1998年にGoogleを創業した当時、ラリーとセルゲイは経営の知識もなければ経験もなかった。
「ユーザーを中心に考えること」を重要視し、最高のサービスを生み出せばお金は後からついてくると信じていた。
成功し壮大な野望を成し遂げるためにはとびきり優秀なエンジニアを惹きつけ、引っ張っていくしかないと感じていた。&lt;/p&gt;

&lt;p&gt;実際業務プロセスも適当で、壮大な志を遂げられるような会社を作る戦術はなかったのだ。
ただ一つはっきりしていた経営戦術は、「私たちが20世紀に学んだことのほとんどは間違っており、それを根本から見直すべき時期がきている。」ということだけだった。&lt;/p&gt;

&lt;p&gt;技術成長に伴う時代の変化の結果、いまや企業の成功に最も重要な要素はプロダクトの優位性になった。
アマゾン創業者兼CEOのジェフ・ベゾスも次のように述べている。&lt;br /&gt;
「古い世界では持てる時間の30%を優れたプロダクトの開発に、70%をそれがどれほど素晴らしいプロダクトか吹聴してまわるのに充てていた。それが新たな世界では逆転した」&lt;/p&gt;

&lt;p&gt;また優位性が重要視されるようになるのに伴い、新たな試みをし失敗するコストが大幅に低下した。
プロダクト開発はより柔軟でスピードが求められるプロセスになった。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;スマート-クリエイティブ:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;スマート・クリエイティブ&lt;/h3&gt;

&lt;p&gt;実験のコストや失敗のコストは大幅に低下し、希少だったデータやPCも簡単に手に入るようになった。
そして、突如して「ひとり」のプレイヤー、マネージャー、経営者がとほうもないインパクトを生み出せるようになった。&lt;/p&gt;

&lt;p&gt;こんにち成功している企業の際立った特色は、最高のプロダクトを生み出し続ける能力だ。
それを手に入れる唯一の道は、スマートクリエイティブを惹きつけ、彼らが偉業を成し遂げられるような環境を作り出すことだ。&lt;/p&gt;

&lt;p&gt;スマート・クリエイティブはどのような人間か。
彼らは自分の”商売道具”を使いこなすための高度な専門知識を持っており経験値も高い。分析力とビジネス感覚にも優れており、競争心も好奇心も旺盛だ。
ユーザーのこともよく分かっている。リスクをいとわない。自発的である。あらゆる可能性にオープンであり、コミュニケーション能力も高い。
すべてのスマート・クリエイティブがこうした特徴を全て備えているわけではなくむしろ稀である。&lt;/p&gt;

&lt;p&gt;共通して持っているものは「努力をいとわず、これまでの常識的方法に疑問を持ち、新しいやり方を試すことに積極的であること」だ。
これがスマート・クリエイティブが大きな影響を持ちうる理由である。&lt;/p&gt;

&lt;p&gt;2003年ごろのGoogleが課題にしていたことは、こうしたスマート・クリエイティブな社員たちが真価を発揮できるような新たな労働環境を生み出し、維持することだった。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;文化:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;文化&lt;/h3&gt;

&lt;p&gt;企業を立ち上げるときに、最初にどんな文化を作りたいか考え、明確にしておくほうが懸命だ。
文化を生み出すのは創業者だが、それを最もよく反映するのは、会社を立ち上げる時に集まった、創業者が信頼を置くチームである。
「ぼくらにとって大切なことは何か」「信念は何か」「どんな存在になりたいのか」「会社の行動や意思決定の方法はどうあるべきか」
成功する会社とそうでない会社の違いは、従業員がこうした文言を信じているかどうかにある。&lt;/p&gt;

&lt;p&gt;PMについて良い文章があったので引用する。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;インタ-ネット世紀のプロダクトマネジャーの役割は、最高のプロダクトの設計、エンジニアリング、開発を担う人々とともに働くことだ。
そのなかには、プロダクトのライフサイクルを管理し、プロダクトのロードマップを決定し、消費者の声を代弁し、そうした事柄をチームや経営陣に伝えるといった従来型の管理業務も含まれる。だが、スマート・クリエイティブ型のプロダクト・マネジャーに何より求められるのは、プロダクトをさらに良くするための技術的ヒントを見つけることだ。それは消費者のプロダクトの使い方(そして技術の進歩とともにそのパターンがどのように変化するか)を把握すること、データの理解や分析、技術のトレンドやそれが業界に及ぼす影響を見きわめることによって得られる。そのためにプロダクト・マネジャーはチームのエンジニア(あるいは化学者、生物学者、デザイナーなど、プロダクトの設計や開発のために採用されたスマート・クリエイティブ)と仕事も食事も生活もともにする必要がある。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;能力主義を浸透させるには:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 能力主義を浸透させるには&lt;/h5&gt;

&lt;p&gt;能力主義を浸透させるには、「異議を唱える義務」を重視する文化が必要。ある考え方に問題があると思った人は、懸念を表明しなければならない。そうしなければ最高とはいえない考え方が通り、懸念を口にしなかったものも共同責任を負うことになる。&lt;/p&gt;

&lt;h5 id=&#34;優れた仕事は楽しくなければならない:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 優れた仕事は楽しくなければならない&lt;/h5&gt;

&lt;p&gt;あなたが死ぬほど働いているのに、ちっとも楽しくないという場合、おそらく何か間違っている。
楽しい理由の一つは、将来の成功の予感かもしれない。だが、一番大きいのは、同僚と一緒に笑ったり、ジョークを言い合ったり、ともに仕事をする楽しさのはずだ。&lt;/p&gt;

&lt;h5 id=&#34;戦略会議:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 戦略会議&lt;/h5&gt;

&lt;p&gt;正しい先着にはある種の美しさがある、多くの人やアイディアが成功のためにひとつになっている感覚。
まずは「5年後はどうなっているか」と尋ねるところから始めよう。
自身が挑戦者である場合、アイディアを軸にプロダクトを開発し、事業を構築しなければならない。
成功している大企業は例外なく次の点から出発している。&lt;/p&gt;

&lt;p&gt;① 問題をまったく新しい方法で解決する&lt;br /&gt;
② その方法を活かして急速に成長・拡大する&lt;br /&gt;
③ 成功の最大の要因はプロダクトである&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;人材:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;人材&lt;/h3&gt;

&lt;h5 id=&#34;ラーニングアニマルを採用する:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ ラーニングアニマルを採用する&lt;/h5&gt;

&lt;p&gt;ヘンリー・フォードは「人は学習を辞めたとき老いる。20歳の老人もいれば、80歳の若者もいる。学びつづける者は若さを失わない。人生で何よりすばらしいのは、自分の心の若さを保つことだ」と言った。
自分の能力は変わらないと考えていると、その自己イメージを維持するために「到達目標」を設定する。一方で人は変われる、適応できると考えている人は「学習目標」を設定する。&lt;/p&gt;

&lt;h5 id=&#34;laxテスト:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ LAXテスト&lt;/h5&gt;

&lt;p&gt;Googleでは「LAXテスト（LAX＝ロサンゼルス国際空港で6時間足止めをくらったとして、それでも一緒にいたいと思う人材かどうかで判断すること）」を採用している。
採用候補者に欠かせない資質として、情熱、知力、ラーニングアニマルのマインドセットを述べた。
もう一つの重要な要素が人格。
単に親切で信頼感があるかというだけでなく、多才で、世界と深く関わっている人間、つまり「おもしろい」人間。&lt;/p&gt;

&lt;h5 id=&#34;google-採用のおきて:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ Google「採用のおきて」&lt;/h5&gt;

&lt;p&gt;Googleの採用のおきてを引用する。
採用だけでなく、自分の仕事ぶりを振り返るいい指標にもなる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自分より優秀で博識な人物を採用せよ。学ぶもののない、あるいは手強いと感じない人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;プロダクトと企業文化に付加価値をもたらしそうな人物を採用せよ。問題について考えるだけの人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;仕事を成し遂げる人物を採用せよ。仕事がほしいだけの人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;熱意があり、自発的で、情熱的な人物を採用せよ。仕事がほしいだけの人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;周囲に刺激を与え、協力できる人物を採用せよ。ひとりで仕事をしたがる人物を採用してはならない。&lt;/li&gt;
&lt;li&gt;チームや会社とともに成長しそうな人物を採用せよ。スキルセットや興味の幅が狭い人間は採用してはならない。&lt;/li&gt;
&lt;li&gt;多才で、ユニークな興味や才能を持っている人物を採用せよ。仕事しか能がない人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;倫理観があり、素直に意思を伝える人物を採用せよ。駆け引きをシたり、他人を操ろうとする人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;最高の候補者を見つけた場合のみ採用せよ。一切の妥協は許されない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;キャリア計画:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ キャリア計画&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;トム・レーラー「人生は下水管のようなものだ。何が出てくるかは、何を入れるかで決まる。」&lt;/li&gt;
&lt;li&gt;ヨギ・ベラ「目的地がどこかわからないときは、注意したほうがいい。おそらくそこには辿り着けないから」&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;意思決定:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;意思決定&lt;/h3&gt;

&lt;h5 id=&#34;正しい意思決定:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 正しい意思決定&lt;/h5&gt;

&lt;p&gt;正しい選択をすることだけに集中してはいけない。判断に到達するプロセス、タイミング、判断を実行に移す方法も、判断の内容そのものと同じくらいに重要。
どれか一つでも欠ければまずい結果になりかねない。意思決定すべき事柄は次々と出てくるので、そのプロセスに問題があると弊害はとめどなく広がっていく。&lt;/p&gt;

&lt;h5 id=&#34;行動志向:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 行動志向&lt;/h5&gt;

&lt;p&gt;「とにかく、”何か”行動を起こすんだ。間違っていたっていい」&lt;br /&gt;
トム・ピーターズはこのような考え方を「行動志向」と呼んだ。
「デザイン的思考の中核的マインドセット」である。
行動志向は、実践的で試行錯誤をいとわない考え方である。
ある行動をとることが正しいか確信が持てないなら、一番いいのは実際にやってみて軌道修正することだ。&lt;/p&gt;

&lt;h5 id=&#34;すべての会議には-オーナー-が必要:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ すべての会議には&amp;rdquo;オーナー&amp;rdquo;が必要。&lt;/h5&gt;

&lt;p&gt;意思決定の舞台はたいてい会議。エリックの作り上げた会議のルール。&lt;/p&gt;

&lt;p&gt;会議には単一の意思決定者、すなわち&amp;rdquo;オーナー&amp;rdquo;を置く。意思決定に責任を持つ人物である。
そしてその意思決定者は自ら動くこと。会議の目的が意思決定でない場合でも(情報共有やブレストでも)必ずオーナーを決めること。
参加者の顔ぶれが適切であること、議題が明確であること。必要な準備がきちんとなされていること。こういったことに責任を持つ。
会議は簡単に廃止できるようにする。運営しやすい規模に留める。時間管理は重要。締めくくりには結論と行動計画をおさらいする。
会議に出るのならまじめにでること。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;イノベーション:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;イノベーション&lt;/h3&gt;

&lt;h5 id=&#34;新しいプロジェクトに取り組むか決める時:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 新しいプロジェクトに取り組むか決める時&lt;/h5&gt;

&lt;p&gt;Googleチームではベン図を使う。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数百万人、数十億人に影響をおよぼすような大きな問題あるいはチャンスか&lt;/li&gt;
&lt;li&gt;すでに市場に存在するものとは根本的に異なる解決策のアイディアはあるか&lt;/li&gt;
&lt;li&gt;根本的に異なる解決策を世に送り出すための画期的な技術は存在しているのか&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;イノベーションを生む環境:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ イノベーションを生む環境&lt;/h5&gt;

&lt;p&gt;イノベーションがうまれるにはふさわしい環境が必要。
たいてい急速に成長しており、たくさんの競合がひしめく市場。
からっぽの市場にひとりぼっち、というのは避けること。
イノベーションに取り組む舞台には、大きなあるいは今後大きくなりそうな市場を選ぶべき。
未開の地を夢見てしまう起業家は多い。&lt;/p&gt;

&lt;h5 id=&#34;世に出てから手直しする:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 世に出てから手直しする&lt;/h5&gt;

&lt;p&gt;新しいアイディアが初めから完璧であることはありえない。完璧になるまで待っている時間はない。
プロダクトを作り、出荷し、市場の反応を見てから、改善策を考え実践し、再び出荷する。
勝つのはこのプロセスを最も速く繰り返すことにできる企業。&lt;/p&gt;

&lt;h5 id=&#34;良い失敗をする:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 良い失敗をする&lt;/h5&gt;

&lt;p&gt;イノベーションを生み出すには、良い失敗のしかたを身につけなければならない。
失敗から学ぶのだ。どんな失敗プロジェクトからも、次の試みに役に立つような技術、ユーザー、市場への理解が得られるはず。&lt;/p&gt;

&lt;p&gt;経営者の仕事はリスクを最小限に抑えたり、失敗を防ぐことではない。
リスクを取り、避けられない失敗に耐えうる組織をつくること。&lt;/p&gt;

&lt;p&gt;おそらく、最も難しいのは失敗のタイミングを見極めること。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Googleという企業の取り組んできたさまざまなプロジェクトや、乗り越えてきたたくさんの困難を通して
多くの実践的な考えを学びながらGoogleという企業について知ることができた。良書。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>