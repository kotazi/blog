<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kotazi.com</title>
    <link>http://kotazi.github.io/blog/</link>
    <description>Recent content on kotazi.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Feb 2016 17:46:23 +0900</lastBuildDate>
    <atom:link href="http://kotazi.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>【Flux】概要</title>
      <link>http://kotazi.github.io/blog/post/2016/0202_flux/</link>
      <pubDate>Tue, 09 Feb 2016 17:46:23 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0202_flux/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://facebook.github.io/flux/docs/overview.html#content&#34;&gt;Overview|Flux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;FluxはFacebookがクライアントサイドのWebアプリケーション構築の際に利用するアプリケーションのアーキテクチャです。
一定方向のデータフローを利用することでReactのビューコンポーネントの構成を補います。
Fluxはフレームワークというよりひとつのパターンなので、新しいコードを必要とすることなくいつでもFluxを使い始めることができます。&lt;/p&gt;

&lt;p&gt;Fluxアプリケーションには主要な3つのパーツがあります。ディスパッチャー、ストア、ビュー(Reactコンポーネント)です。
これらをMVCと混同すべきではありません。
コントローラはFluxアプリケーションの中にも存在します。
&lt;code&gt;controller-views&lt;/code&gt;-ビューはストアからデータを受け取るヒエラルキーのトップに位置し、受け取ったデータを子へと渡します。
加えて、アクションを生成する— dispatcher helper methods —はアプリケーション内で可能な変更を全て描画するセマンティックなAPIを
描画するサポートに利用します。
それらをFluxの更新サイクルにおける4番目のパートと考えると便利です。&lt;/p&gt;

&lt;p&gt;FluxではMVCを避けて一定方向のデータフローを支持しています。
あるユーザーがReactのビューに触れると、そのビューはアプリケーションのデータやロジックを保持した様々なストアへと、中央のディスパッチャーを介してアクションを広め、影響する全てのビューを更新します。
とりわけReactのプログラミングスタイルに良く働き、ステート間でのビューの遷移を細かく支持することなくストアが更新を送れるようになります。&lt;/p&gt;

&lt;p&gt;私たちは元々得られたデータを正しく扱います。例として、スレッドのリストを表示するビューに対して、メッセージスレッドの未読数を表示したかったとします。
MVCでは、単一のスレッドをマークし、スレッドモデルと未読数モデルを更新することは難しいです。
これらの依存関係やカスケードの更新は大規模なMVCアプリケーションでしばしば行われ、
データの流れをもつれさせ、予期せぬ結果をもたらします。&lt;/p&gt;

&lt;p&gt;ストアが制御をひっくり返します。ストアは外部の何かに更新を依存するのではなく、更新を受け入れ、適切に調和します。
内部でのデータの管理方法をストアに留めれば、心配事がなくなります。
ストアは&lt;code&gt;setAsRead()&lt;/code&gt;といった直接的なセッターメソッドを持ちませんが、代わりに自身のコンテナに新しいデータを取得する手段をもっています。
そのコールバックをディスパッチャーとともに登録します。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;structure-and-data-flow:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Structure and Data Flow&lt;/h3&gt;

&lt;p&gt;Fluxアプリケーションのデータの流れは一方向です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一方高のデータの流れはFluxアプリケーションの基本であり、上図はFluxプログラマーにとって主要なメンタルモデルとなります。
ディスパッチャー、ストア、ビューは入力と出力をもった独立したノードです。
アクションは新データと&lt;code&gt;type&lt;/code&gt;プロパティをもった単純なオブジェクトです。&lt;/p&gt;

&lt;p&gt;ビューはユーザーインタラクションが起こるとシステムを通して新しいアクションを伝播します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ディスパッチャーを介した全てのデータフローはセントラルハブとなります。
ディスパッチャーに提供されるアクションは、ユーザーのインタラクションをきっかけに、たいていはアクション生成メソッドから始まります。
そしてディスパッチャーはストアに登録されたコールバックを発動し、アクションを全てのストアに伝えます。
登録されたコールバック内では、ストアの保持しているステートに関連している全てのアクションに反応します。
そしてストアはデータレイヤーが引き起こした変更のイベントをcontroller-viewsに送信します。
controller-viewsはこれらのイベントをキャッチし、イベントハンドラ内でストアからデータを受け取ります。
controller-viewsは自身の&lt;code&gt;setState()&lt;/code&gt;メソッドを呼び出し、自身と全ての子孫を再度レンダリングします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://facebook.github.io/flux/img/flux-simple-f8-diagram-explained-1300w.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;この構造によって、関数型リアクティブプログラミング(FRP)、データフロープログラミング(DFP)、フローベースプログラミング(FBP)の理解が容易になり、アプリケーション内のデータの流れが一方向になります。(これは2wayバインディングとは異なります。)
アプリケーションのステートはストア内のみに保たれ、アプリケーションの異なる部分をしっかりと分離させることができます。
ストア間での依存関係は、ヒエラルキーにより厳格に保たれ、ディスパッチャーによって更新が同期されます。&lt;/p&gt;

&lt;p&gt;2wayデータバインディングではあるオブジェクトが変更されると他のオブジェクトも変更され、たくさんの更新がトリガされます。
アプリケーションが大きくなると、ユーザのインタラクションによって引き起こされる結果として何が変更されるかを予測することが非常に難しくなってシまいます。
シングルラウンド内でデータの変更ができれば、システム全体を予測しやすくなります。&lt;/p&gt;

&lt;p&gt;Fluxの様々な部分を見ていきましょう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;a-single-dispatcher:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;A Single Dispatcher&lt;/h3&gt;

&lt;p&gt;Fluxアプリケーションではディスパッチャーがセントラルハブであり、全てのデータの流れを管理します。
ストアにコールバックを登録することが本質的なところであり、ディスパッチャー自身が実際に知性を持っているわけではありません。
ストアにアクションを割り当てるためのシンプルなmechanismです。
各ストアは自身を登録し、コールバックを提供します。
アクションクリエータが新しいアクションを持ったディスパッチャーを登録すると、アプリケーション内の登録されたすべてのストアがコールバックを通してアクションを受け取ります。&lt;/p&gt;

&lt;p&gt;アプリケーションが大きくなると、ディスパッチャーはより活発になり、明確な順番で登録されたコールバックを呼び出すため、ストア間の依存関係を管理するために役立ちます。
ストアは他のストアの更新を待ち、そのあとに自身を更新します。&lt;/p&gt;

&lt;p&gt;npmやbowerからFacebookが実際の本番環境で使用しているディスパッチャーが利用可能です。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;stores:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Stores&lt;/h3&gt;

&lt;p&gt;ストアにはアプリケーションのステートとロジックが含まれます。
ストアの役割は伝統的なMVCにおけるモデルに似ていますが、ストアはたくさんのオブジェクトのステートを管理します。(ORMのようなシングルレコードを表すわけではありません。)
Backboneのコレクションとも違います。
ORMスタイルのコレクションをよりシンプルに管理するもので、ストアはアプリケーション内で特定のドメインのためのアプリケーションステートを管理します。&lt;/p&gt;

&lt;p&gt;例としてFacebookのLookback Video Editorは&amp;rdquo;TimeStore&amp;rdquo;を利用して、プレイバックタイムの位置とステートのトラックを保ちます。
一方で、同アプリケーションの&amp;rdquo;ImageStore&amp;rdquo;はToDoリストの管理に似ています。ストアはモデルのコレクションとシングルトンとしての特徴を持ち合わせています。&lt;/p&gt;

&lt;p&gt;上記で言及したように、ストアは自身にディスパッチャーを登録し、コールバックをもったディスパッチャーを提供します。
このコールバックはアクションをparameterとして受け取ります。
ストアに登録されたコールバックの内部では、アクションタイプに基づいたステートのスイッチはアクションを解釈し、固有のフックをストア内部のメソッドに提供するために使われます。
こうしてアクションはディスパッチャーを介してストアのステートを更新します。
ストアが更新された後、ステートが変更されたことを宣言するイベントをブロードキャストします。
そしてビューがステートと更新を確認します。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;views-and-controller-views:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Views and Controller-Views&lt;/h3&gt;

&lt;p&gt;Reactは私たちがビューレイヤーに必要としていた構成可能かつ自由で再レンダリングが可能なビューを提供します。
ビューヒエラルキーのトップに位置するビューは依存するストアにブロードキャストされたイベントを受け取る特別なビューです。
これらをcontroller-viewと呼び、ストアからデータを取得し、取得したデータを子孫に渡すようなグルーコードを提供します。&lt;/p&gt;

&lt;p&gt;controller-viewがストアからイベントを受け取ると、ストアのゲッターメソッドを通して必要な新しいデータを要求します。
自身の&lt;code&gt;setState()&lt;/code&gt;もしくは&lt;code&gt;forceUpdate()&lt;/code&gt;関数を呼び出し、自身の&lt;code&gt;render()&lt;/code&gt;メソッドと、子孫の&lt;code&gt;render()&lt;/code&gt;メソッドを引き起こします。&lt;/p&gt;

&lt;p&gt;シングルオブジェクト内のストアの全体のステートを子のビューに下ろすことで、異なる子孫が使えるようになります。
トップ階層でコントローラのような振る舞いを保つことで、このビューを機能的に保つことが可能になり、管理しなければならないプロパティの数を減らすことができます。&lt;/p&gt;

&lt;p&gt;時々、コンポーネントをシンプルに保つために、追加でcontroller-viewsを付け足す必要が出てくるかもしれません。
特定のデータドメインに関連するセクションのヒエラルキーを要約することに役立ちます。
しかし、controller-viewsを深くすることで一方向のデータフローを破ってしまう可能性があることに注意してください。
controller-viewを深い位置に追加するのであれば、異なる点でのヒエラルキーにおいてシンプルなコンポーネントとデータ更新のフローの複雑性にバランスをとってください。
こういった複雑なデータの更新は、Reactのレンダリングメソッドを繰り返し発動させてしまう恐れがあり、潜在的にデバッグを難しくしてしまいます。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;actions:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;Actions&lt;/h3&gt;

&lt;p&gt;ディスパッチャーはストアとデータに対してのディスパッチをトリガするメソッドを提供し、
アクションの生成はディスパッチャーにアクションを送るセマンティックなヘルパーメソッドにラップされます。
例えば、ToDoリストアプリケーションのToDoアイテムのテキストを変更したかったとします。
&lt;code&gt;TodoActions&lt;/code&gt;モジュール内で&lt;code&gt;updateText(todoId, newText)&lt;/code&gt;関数を生成します。
このメソッドはビューのイベントハンドラから呼び出され、ユーザーインタラクションによって呼び出すことができます。
このアクションを生成するメソッドはアクションに&lt;code&gt;type&lt;/code&gt;を持たせるため、ストア内で解釈され、適切に反応することができます。
例として、&lt;code&gt;type&lt;/code&gt;を&lt;code&gt;TODO_UPDATE_TEXT&lt;/code&gt;のように名づけます。&lt;/p&gt;

&lt;p&gt;アクションはサーバーなど別の場所から来ることもあるかもしれません。
例えば、データ初期化時などにおこります。
サーバーがエラーコードを返した時や、アプリケーションをアップデートしたときに起こります。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;what-about-that-dispatcher:0cfbdc0fe96d51285b80a2daaffddeb1&#34;&gt;What About that Dispatcher?&lt;/h3&gt;

&lt;p&gt;以前に言及したように、ディスパッチャーはストア間の依存関係を管理します。
ディスパッチャークラスの&lt;code&gt;waitFor()&lt;/code&gt;関数を通して利用可能です。
極めてシンプルなTodoアプリなどで使用する必要はありませんが、より複雑で大きなアプリケーションでは活発になります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TodoStore&lt;/code&gt;に登録されたコールバックが他の依存関係の更新を待っている様子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case &#39;TODO_CREATE&#39;:
  Dispatcher.waitFor([
    PrependedTextStore.dispatchToken,
    YetAnotherStore.dispatchToken
  ]);

  TodoStore.create(PrependedTextStore.getText() + &#39; &#39; + action.text);
  break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;waitFor()&lt;/code&gt;は登録したディスパッチャーの配列を一つ引数として受け、&lt;code&gt;dispatch token&lt;/code&gt;と呼ばれます。
このように&lt;code&gt;waitFor()&lt;/code&gt;を発動するストアはどのように自身のステートを更新するかを通知するために別のストアのステートに依存します。&lt;/p&gt;

&lt;p&gt;ディスパッチャーのコールバックが登録された時に&lt;code&gt;register()&lt;/code&gt;が&lt;code&gt;dispatch token&lt;/code&gt;を返します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PrependedTextStore.dispatchToken = Dispatcher.register(function (payload) {
  // ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;より&lt;code&gt;waitFor()&lt;/code&gt;やアクションクリエータ、ディスパッチャーについてしりたければ&lt;a href=&#34;http://facebook.github.io/react/blog/2014/07/30/flux-actions-and-the-dispatcher.html&#34;&gt;こちら&lt;/a&gt;です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【Angular】ユニットテスト</title>
      <link>http://kotazi.github.io/blog/post/2016/0202_angular_unit/</link>
      <pubDate>Mon, 08 Feb 2016 18:45:53 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0202_angular_unit/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;[Unit Testing|AngularJS]&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;JavaScriptは強い式の力を持った動的型付け言語であり、コンパイラの助けを得ることがない。
そのため、JavaScriptのコードにはしっかりしたテストが必要である。
Angularには、Angularアプリケーションのテストを用意にするための機能がたくさん組み込まれている。
Angularにおいて、テストをしないということはありえない。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;separation-of-concerns:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Separation of Concerns&lt;/h3&gt;

&lt;p&gt;ユニットテストという名前から示されるように、これは独立した単体のコードのテストのことである。
ユニットテストは「そのロジックは正しく動くだろうか」、「ソート関数が並び替えたリストは正しい順番だろうか」
といった質問に回答しようとするものだ。&lt;/p&gt;

&lt;p&gt;テストにおいてこのような質問に答えるためには、単体のコードを孤立させることがとても重要である。
ソート関数のテストをしている時に、関連するDOM要素を生成したり、ソートデータをフェッチするためにXHRを呼び出すといったことをしたくないため。&lt;/p&gt;

&lt;p&gt;これは明らかなことなのに、典型的なプロジェクトでは独立した関数を呼び出すことはとてもむずかしい。
これは開発者がしばしば全てのことをするコードを混合させてしまうことに原因があり、
XHRを生成するもの、受け取ったデータをソートするもの、そしてDOMを操作するもの、である。&lt;/p&gt;

&lt;p&gt;Angularを用いて、あなたが正しくことを行うことを簡単にした。
XHRのために依存性注入を提供するので、リクエストをシミュレーションすることが可能になり、
レスポンスデータをソートすることができ、DOMを操作することができる。
DOMを生成したり、状態を監視したりXHRリクエストのレスポンスデータを待ったりすることなく、
データのソートをテストすることができる。
単独のソート関数を分離してテストすることができる。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;with-great-power-comes-great-responsibility:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;With great power comes great responsibility&lt;/h3&gt;

&lt;p&gt;Angularはテストしやすいことを念頭に書かれているが、それでもまだ
正しい書き方をする必要がある。
書き方が簡単になるよう努めたものの、ガイドラインを無視すれば
アンテスタブルなアプリケーションになってしまう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;dependency-injection:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Dependency Injection&lt;/h3&gt;

&lt;p&gt;Angularは&lt;a href=&#34;https://docs.angularjs.org/guide/di&#34;&gt;依存性注入&lt;/a&gt;のビルトインからなっており、
それはテストのコンポーネント化するため、思いどおりにコンポーネント間での依存関係やスタブ、モックをテストすることが可能。&lt;/p&gt;

&lt;p&gt;コンポーネントに依存性注入をすればテストのモックが簡単になり、
グローバル汚染もなくなりうっかり別のテストに影響してしまうこともなくなる。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;additional-tools-for-testing-angular-applications:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Additional tools for testing Angular applications&lt;/h3&gt;

&lt;p&gt;Angularアプリケーションのテストでは、テストをより簡単にセットアップし実行するために使うべきツールがある。&lt;/p&gt;

&lt;h4 id=&#34;karma:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Karma&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://karma-runner.github.io/&#34;&gt;Karma&lt;/a&gt;はコマンドラインツールである。
アプリケーションのコードを読み込み、実行するWebサーバーを用意する。
アプリケーションがサポートする全てのブラウザにで操作することをテストするために、ブラウザの数分に対してKarmaを実行するように設定することができる。
Karmaをコマンドライン上で実行すると、ブラウザでのテスト実行結果をコマンドライン上にすぐに表示する。&lt;/p&gt;

&lt;p&gt;KarmaはNodeJS製のアプリケーションであり、npmでインストールする。
インストールガイドについては&lt;a href=&#34;http://karma-runner.github.io/0.12/intro/installation.html&#34;&gt;Karmaのサイト&lt;/a&gt;が役に立つ。&lt;/p&gt;

&lt;h4 id=&#34;jasmine:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Jasmine&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html&#34;&gt;Jasmin&lt;/a&gt;はビヘイビア駆動開発のJavaScriptフレームワークであり、
Angularアプリケーションをテストするうえで最も人気のフレームワークである。
テストに構造をもたせ、アサーションを作成するための関数を提供する。
テストが大きくなっても構造的であり、ドキュメント性を保ちながら、アーカイブしてく。&lt;/p&gt;

&lt;p&gt;テストをグループ化するためには&lt;code&gt;describe&lt;/code&gt;を利用する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&amp;quot;sorting the list of users&amp;quot;, function() {
  // individual tests go here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;個々のテストは&lt;code&gt;it&lt;/code&gt;関数の中に定義される。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;sorting the list of users&#39;, function() {
  it(&#39;sorts in descending order by default&#39;, function() {
    // your test assertion goes here
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関連するテストを&lt;code&gt;describe&lt;/code&gt;ブロックでグルーピングし、個々のテストは&lt;code&gt;it&lt;/code&gt;関数内に記述することで
テストをドキュメントとして保ち続けることが可能になる。&lt;/p&gt;

&lt;p&gt;最後に、Jasmineは作成するアサーションのマッチャーを提供する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;sorting the list of users&#39;, function() {
  it(&#39;sorts in descending order by default&#39;, function() {
    var users = [&#39;jack&#39;, &#39;igor&#39;, &#39;jeff&#39;];
    var sorted = sortUsers(users);
    expect(sorted).toEqual([&#39;jeff&#39;, &#39;jack&#39;, &#39;igor&#39;]);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jasminは様々なアサーションを作成するためのたくさんのマッチャーから成っている。
マッチャーについては&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html#section-Matchers&#34;&gt;こちらの記事&lt;/a&gt;を読むこと。
KarmaとJasminを使うために、&lt;a href=&#34;https://github.com/karma-runner/karma-jasmine&#34;&gt;karma-jasmin&lt;/a&gt;を利用する。&lt;/p&gt;

&lt;h4 id=&#34;angular-mocks:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;angular-mocks&lt;/h4&gt;

&lt;p&gt;Angularはテスト用のモックを提供する&lt;code&gt;ngMock&lt;/code&gt;というものを用意している。
ユニットテスト内でのAngularサービスをモックしたりインジェクトするために用いられる。
加えて、別のモジュールを拡張できるので、同期的だ。
テストを同期することで明確に保ち、簡単に動作させることができる。
もっとも便利なうちのひとつが&lt;code&gt;$httpBackend&lt;/code&gt;だ。
テストでXHRリクエストのモックを行うことができ、代わりにサンプルのデータを返す。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-a-controller:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing a Controller&lt;/h3&gt;

&lt;p&gt;Angularのビューレイヤーはロジックから切り離されているので、コントローラを簡単にテストすることができる。
下記でコントローラをどのようにテストしているか見ていこう。
パスワードの長さに基づいてスコープのプロパティをセットする&lt;code&gt;$scope.grade&lt;/code&gt;を提供している。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;angular.module(&#39;app&#39;, [])
.controller(&#39;PasswordController&#39;, function PasswordController($scope) {
  $scope.password = &#39;&#39;;
  $scope.grade = function() {
    var size = $scope.password.length;
    if (size &amp;gt; 8) {
      $scope.strength = &#39;strong&#39;;
    } else if (size &amp;gt; 3) {
      $scope.strength = &#39;medium&#39;;
    } else {
      $scope.strength = &#39;weak&#39;;
    }
  };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コントローラはグローバルスコープでは利用できないため、
はじめに&lt;code&gt;angular.mock.inject&lt;/code&gt;を使ってコントローラをインジェクトする必要がある。
最初のステップは、angular-mocksが提供する&lt;code&gt;module&lt;/code&gt;関数を使うことだ。
この関数は与えられたモジュールを読み込み、読み込まれたモジュールはテスト内で利用う可能となる。
これをJasminの提供する関数であり、各テストの前にコードを実行できる&lt;code&gt;beforeEach&lt;/code&gt;に渡す。
そしてコントローラのインスタンス化に責任を持つサービス&lt;code&gt;$controller&lt;/code&gt;にアクセスするために&lt;code&gt;inject&lt;/code&gt;を用いる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ネストした&lt;code&gt;describe&lt;/code&gt;の呼び出しや、文字列を用いて呼び出す時の描写でテストが明確になっていることに注目する。
何をテストしているかハッキリと記し、何が起きているかを簡単に理解できる。
では3文字以下のパスワードを追加して、&lt;code&gt;$scope.strength&lt;/code&gt;が&amp;rdquo;weak&amp;rdquo;であるか見ていこう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });

    it(&#39;sets the strength to &amp;quot;weak&amp;quot; if the password length &amp;lt;3 chars&#39;, function() {
      var $scope = {};
      var controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
      $scope.password = &#39;a&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;weak&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在２つのテストがあるが、テストが重複していることに気付いて欲しい。
両方で&lt;code&gt;$scope&lt;/code&gt;を作成しており、コントローラを生成している。
テストを重複するならこの重複は良くない。
ありがたいことにJasminには&lt;code&gt;beforeEach&lt;/code&gt;がある。
個々のテストの前に関数を実行してくれる。
どのようにテストをセットするか確認しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;PasswordController&#39;, function() {
  beforeEach(module(&#39;app&#39;));

  var $controller;

  beforeEach(inject(function(_$controller_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $controller = _$controller_;
  }));

  describe(&#39;$scope.grade&#39;, function() {
    var $scope, controller;

    beforeEach(function() {
      $scope = {};
      controller = $controller(&#39;PasswordController&#39;, { $scope: $scope });
    });

    it(&#39;sets the strength to &amp;quot;strong&amp;quot; if the password length is &amp;gt;8 chars&#39;, function() {
      $scope.password = &#39;longerthaneightchars&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;strong&#39;);
    });

    it(&#39;sets the strength to &amp;quot;weak&amp;quot; if the password length &amp;lt;3 chars&#39;, function() {
      $scope.password = &#39;a&#39;;
      $scope.grade();
      expect($scope.strength).toEqual(&#39;weak&#39;);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重複部分を外へ出し、&lt;code&gt;beforeEach&lt;/code&gt;ブロックへ移動した。
これで個々のテストには特有のコードだけになり、全体に入っているようなコードはなくなった。
テストを拡張するうえで、テストをきちんとするためにどこで&lt;code&gt;beforeEach&lt;/code&gt;を使えるか目を見張ることだ。
Jasminが提供するのは&lt;code&gt;beforeEach&lt;/code&gt;だけじゃない。&lt;a href=&#34;http://jasmine.github.io/1.3/introduction.html#section-Setup_and_Teardown&#34;&gt;こちら&lt;/a&gt;も見てみること。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-filters:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Filters&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.angularjs.org/api/ng/provider/$filterProvider&#34;&gt;フィルタ&lt;/a&gt;はデータをユーザが読みやすいフォーマットに変換する。
これはフォーマットの責任をアプリケーションロジックから取り除くことになるのでとても重要なこと。さらにはアプリケーションロジックを単純にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myModule.filter(&#39;length&#39;, function() {
  return function(text) {
    return (&#39;&#39; + (text || &#39;&#39;)).length;
  }
});

describe(&#39;length filter&#39;, function() {

  var $filter;

  beforeEach(inject(function(_$filter_){
    $filter = _$filter_;
  }));

  it(&#39;returns 0 when given null&#39;, function() {
    var length = $filter(&#39;length&#39;);
    expect(length(null)).toEqual(0);
  });

  it(&#39;returns the correct value when given a string of chars&#39;, function() {
    var length = $filter(&#39;length&#39;);
    expect(length(&#39;abc&#39;)).toEqual(3);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;testing-directives:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Directives&lt;/h3&gt;

&lt;p&gt;AngularのディレクティブはカスタムHTMLタグや属性、クラス、コメントと複雑な機能に責任を持っている。
ディレクティブを使って生成したコンポーネントがさまざまな背景で思った通りに使われているかのテストになるので、
ディレクティブのユニットテストはとても重要です。&lt;/p&gt;

&lt;h4 id=&#34;simple-html-element-directive:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Simple HTML Element Directive&lt;/h4&gt;

&lt;p&gt;依存関係のないAngularアプリで始める。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = angular.module(&#39;myApp&#39;, []);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アプリにディレクティブを追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.directive(&#39;aGreatEye&#39;, function () {
    return {
        restrict: &#39;E&#39;,
        replace: true,
        template: &#39;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&#39;
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&lt;/code&gt;といったタグでこのディレクティブは利用する。
タグごと&lt;code&gt;&amp;lt;h1&amp;gt;lidless, wreathed in flame, {{1 + 1}} times&amp;lt;/h1&amp;gt;&lt;/code&gt;テンプレートを置き換えるものだ。
その機能を確認するためのJasminテストを書いていく。
レンダリングされると&lt;code&gt;{{1 + 1}}&lt;/code&gt;式が評価されることに注意する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe(&#39;Unit testing great quotes&#39;, function() {
  var $compile,
      $rootScope;

  // ディレクティブを含んだmyAppモジュールを読み込む
  beforeEach(module(&#39;myApp&#39;));

  // $rootScopeと$compileへの参照を保持する
  // このdescribeブロックにおいて全てのテストで利用可能になる
  beforeEach(inject(function(_$compile_, _$rootScope_){
    // The injector unwraps the underscores (_) from around the parameter names when matching
    $compile = _$compile_;
    $rootScope = _$rootScope_;
  }));

  it(&#39;Replaces the element with the appropriate content&#39;, function() {
    // ディレクティブのHTMLをコンパイルする
    var element = $compile(&amp;quot;&amp;lt;a-great-eye&amp;gt;&amp;lt;/a-great-eye&amp;gt;&amp;quot;)($rootScope);
    // ウォッチャーを発火させ、式を評価する
    $rootScope.$digest();
    // コンパイルされた要素がテンプレートの中身を含んでいることを確認する
    expect(element.html()).toContain(&amp;quot;lidless, wreathed in flame, 2 times&amp;quot;);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$compile&lt;/code&gt;サービスと&lt;code&gt;$rootScope&lt;/code&gt;をJasminテストの前にインジェクトする。
&lt;code&gt;$compile&lt;/code&gt;サービスはaGreatEyeディレクティブをレンダリングするために利用する。
レンダリング後に、&amp;rdquo;lidless, wreathed in flame, 2 times&amp;rdquo;は現れる。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Underscore notation:&lt;/strong&gt; &lt;code&gt;_$rootScope_&lt;/code&gt;といったアンダースコアの使い方は、テスト内での変数名をきれいに保つためAngularJSコミュニティ内で広く広がった風習である。
パラメータがマッチングした際に、&lt;code&gt;$injector&lt;/code&gt;がアンダースコアを取り払うのはこれが理由である。
このアンダースコアルールが働くのは名前が一つのアンダースコアで始まり一つのアンダースコアで終わる時のみに限られ、それ以外での置換は起こらない。&lt;/p&gt;

&lt;h4 id=&#34;testing-transclusion-directives:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Transclusion Directives&lt;/h4&gt;

&lt;p&gt;トランスクルージョンを使ったディレクティブはコンパイラに特別に扱われる。
コンパイル関数が呼び出される前に、ディレクティブ要素のコンテンツは取り除かれ、トランスクルージョン関数を通して提供される。
ディレクティブのテンプレートはその際に、ディレクティブ要素に追加され、トランスクルードされたコンテンツをテンプレート内に挿入する。&lt;/p&gt;

&lt;p&gt;コンピレーション前:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;
  Some transcluded content
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トランスクルージョンが引き抜かれる:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンピレーション後:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div transclude-directive&amp;gt;
  Some Template
  &amp;lt;span ng-transclude&amp;gt;Some transcluded content&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ディレクティブが&amp;rdquo;要素&amp;rdquo;のトランスクルージョンを利用しているのであれば、コンパイラは実質的にDOMからディレクティブ全体の要素を取り除き、
コメントノードを持ってそれを置き換える。
そしてコンパイラはディレクティブのテンプレートをコメントノードの&lt;strong&gt;後に&lt;/strong&gt;、兄弟として挿入する。&lt;/p&gt;

&lt;p&gt;コンピレーション前:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div element-transclude&amp;gt;
  Some Content
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;トランスクルージョンが引き抜かれる:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- elementTransclude --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンピレーション後:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- elementTransclude --&amp;gt;
&amp;lt;div element-transclude&amp;gt;
  Some Template
  &amp;lt;span ng-transclude&amp;gt;Some transcluded content&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要素のトランスクルージョンを使ったディレクティブのテストを書いている時に、このことに気づくことが重要。
もし&lt;code&gt;$compile&lt;/code&gt;へ渡すDOMフラグメントのルート要素にディレクティブを置くのであれば、関連する関数から返されるDOMノードはコメントノードであり、テンプレートとトランスクルードされたコンテンツを繋ぐ能力には負けるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var node = $compile(&#39;&amp;lt;div element-transclude&amp;gt;&amp;lt;/div&amp;gt;&#39;)($rootScope);
expect(node[0].nodeType).toEqual(node.COMMENT_NODE);
expect(node[1]).toBeUndefined();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに対処するためには単純に要素をトランスクルードするディレクティブを&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;のようなエレメントでラップする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var node = $compile(&#39;&amp;lt;div&amp;gt;&amp;lt;div element-transclude&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&#39;)($rootScope);
var contents = node.contents();
expect(contents[0].nodeType).toEqual(node.COMMENT_NODE);
expect(contents[1].nodeType).toEqual(node.ELEMENT_NODE);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;testing-directives-with-external-templates:1ccf9de45f59b655d54913e04f01fa76&#34;&gt;Testing Directives With External Templates&lt;/h4&gt;

&lt;p&gt;もぢディレクティブで&lt;code&gt;templateUrl&lt;/code&gt;を使っているのであれば、HTMLテンプレートをプリコンパイルするために&lt;a href=&#34;https://github.com/karma-runner/karma-ng-html2js-preprocessor&#34;&gt;karma-ng-html2js-preprocessor&lt;/a&gt;を使うことを考え、HTTPリクエストを使ってテキストをロードすることは避けること。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ES6とReact試してみた</title>
      <link>http://kotazi.github.io/blog/post/2016/0130_react_calendar/</link>
      <pubDate>Mon, 01 Feb 2016 12:06:51 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0130_react_calendar/</guid>
      <description>&lt;p&gt;FullCalendarとReactとES6を使ったサンプルを作ってみた。&lt;/p&gt;

&lt;p&gt;jQueryとReactは相性が悪いと聞いていたが、特に感じられなかった。&lt;/p&gt;

&lt;p&gt;&lt;p data-height=&#34;266&#34; data-theme-id=&#34;15717&#34; data-slug-hash=&#34;KVoXob&#34; data-default-tab=&#34;result&#34; data-user=&#34;kotazi&#34; class=&#39;codepen&#39;&gt;See the Pen &lt;a href=&#39;http://codepen.io/kotazi/pen/KVoXob/&#39;&gt;FullCalendar With React ES6&lt;/a&gt; by Kohei  Saeki (&lt;a href=&#39;http://codepen.io/kotazi&#39;&gt;@kotazi&lt;/a&gt;) on &lt;a href=&#39;http://codepen.io&#39;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;script async src=&#34;//assets.codepen.io/assets/embed/ei.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【訳読】React Tutorial</title>
      <link>http://kotazi.github.io/blog/post/2016/0128_react/</link>
      <pubDate>Thu, 28 Jan 2016 23:08:28 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0128_react/</guid>
      <description>

&lt;p&gt;勉強がてら&lt;a href=&#34;https://facebook.github.io/react/docs/tutorial.html&#34;&gt;Reactチュートリアル&lt;/a&gt;を翻訳しました。&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&#34;tutorial:c4edc588c83982a0e8967944828e886f&#34;&gt;Tutorial&lt;/h2&gt;

&lt;p&gt;シンプルではあるものの、ブログに書ける現実的なコメントボックスを実装していく。
この基本バージョンのリアルタイムコメントはDisqusやLibeFyre、Facebook commentsにオファーをいただいた。&lt;/p&gt;

&lt;p&gt;提供する機能:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全てのコメントのView&lt;/li&gt;
&lt;li&gt;コメントを送信するためのフォーム&lt;/li&gt;
&lt;li&gt;バックエンドをカスタムするためのHook&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;またこれらの機能もしっかり備えている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;オプティミスティックコメント&lt;/strong&gt;: サーバーに保存される前にコメントが表示されるため非常に速い&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ライブアップデート&lt;/strong&gt;: 他者のコメントがリアルタイムで反映される&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Markdown対応&lt;/strong&gt;: Markdownによる記述が可能&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;want-to-skip-all-this-and-just-see-the-source:c4edc588c83982a0e8967944828e886f&#34;&gt;Want to skip all this and just see the source?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/reactjs/react-tutorial&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;running-a-server:c4edc588c83982a0e8967944828e886f&#34;&gt;Running a server&lt;/h3&gt;

&lt;p&gt;チュートリアルを開始するためには、稼働しているサーバーが必要。
あくまでデータの取得と保存に使用するAPIエンドポイントとしてのサーバーだ。&lt;/p&gt;

&lt;p&gt;できるだけ簡単にするため、仕様を実現するシンプルなサーバーをいくつかのスクリプト言語で用意した。
開始に必要なものは&lt;a href=&#34;https://github.com/reactjs/react-tutorial/&#34;&gt;こちら&lt;/a&gt;からインストール可能。&lt;/p&gt;

&lt;p&gt;簡潔にするために、実行するサーバーはJSONファイルをデータベースとして利用する。
本番でこんなことはしないが、APIを用いたシュミレーションを行うには簡単でいいだろう。
一度サーバーを起動したら、APIエンドポイントをサポートし、必要なスタティックペーシを出してくれる。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;getting-started:c4edc588c83982a0e8967944828e886f&#34;&gt;Getting started&lt;/h3&gt;

&lt;p&gt;このチュートリアルでは、できるだけ簡単なものにしていくつもりである。
サーバーパッケージの中に私たちが動かすHTMLファイルが含まれている。
&lt;code&gt;public/index.html&lt;/code&gt;を好みのエディタで開いてみてほしい。このようになっているはずだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;React Tutorial&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.6/react.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/react/0.14.6/react-dom.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/babel&amp;quot; src=&amp;quot;scripts/example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt;
      // To get started with this tutorial running your own code, simply remove
      // the script tag loading scripts/example.js and start writing code here.
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このチュートリアルのリマインダーとして、このスクリプトタグの中にコードを記述している。
ライブリロードは備えていないので、ファイルを更新した際はブラウザをリロードすること。
(サーバー起動後、)ブラウザで&lt;code&gt;http://localhost:3000&lt;/code&gt;を開けば進捗が確認できる。
このファイルをそのまま開けば、完成したプロダクトを確認することができる。
準備ができたら&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグを削除して続けよう。&lt;/p&gt;

&lt;p&gt;注意: ajax呼び出しをシンプルに記述するため、jQueryを含んでいるが必ずしも必要なわけではない。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;your-first-component:c4edc588c83982a0e8967944828e886f&#34;&gt;Your first component&lt;/h3&gt;

&lt;p&gt;Reactは要するにmodular, composable componentsである。
コメントボックスのサンプルとして、次のようなコンポーネント構造を持つことにする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- CommentBox
  - CommentList
    - Comment
  - CommentForm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シンプルに&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;を使って、&lt;code&gt;CommentBox&lt;/code&gt;コンポーネントを作成しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial1.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        Hello, world! I am a CommentBox.
      &amp;lt;/div&amp;gt;
    );
  }
});
ReactDOM.render(
  &amp;lt;CommentBox /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ネイティブのHTMLエレメント名が小文字で綴られていることに注意。
Reactクラスは大文字で始まっている。&lt;/p&gt;

&lt;h5 id=&#34;jsx-syntax:c4edc588c83982a0e8967944828e886f&#34;&gt;JSX Syntax&lt;/h5&gt;

&lt;p&gt;JSがXMLのような構文だったことに気づかれただろう。
シンタックスシュガーをピュアJSに変換するシンプルなプリコンパイラを備えている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial1-raw.js
var CommentBox = React.createClass({displayName: &#39;CommentBox&#39;,
  render: function() {
    return (
      React.createElement(&#39;div&#39;, {className: &amp;quot;commentBox&amp;quot;},
        &amp;quot;Hello, world! I am a CommentBox.&amp;quot;
      )
    );
  }
});
ReactDOM.render(
  React.createElement(CommentBox, null),
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任意ではあるがJSXシンタックスを使ったほうがかんだんだ。
JSXについては&lt;a href=&#34;https://facebook.github.io/react/docs/jsx-in-depth.html&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;what-s-going-on:c4edc588c83982a0e8967944828e886f&#34;&gt;What&amp;rsquo;s going on&lt;/h5&gt;

&lt;p&gt;新しいReactコンポーネントを作成するために、&lt;code&gt;React.createClass()&lt;/code&gt;にいくつかのメソッドを持ったJSオブジェクトを渡した。
これらのメソッドの中で最も重要なものが&lt;code&gt;render&lt;/code&gt;メソッドだ。
Reactコンポーネントのツリー構造を返り値にし、ゆくゆくはHTMLにレンダリングするメソッドだ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;タグは実際のDOMノードではない。Reactの&lt;code&gt;div&lt;/code&gt;コンポーネントのインスタンスである。
これらのことはReactの操作方法を知るデータの欠片や印と思ってくれていい。
Reactは安全だ。
HTML文字列を生成しないため、XSS対策をデフォルトでしていることになる。&lt;/p&gt;

&lt;p&gt;基本的なHTMLを返す必要はない。あなた(もしくは誰か)の組み立てたコンポーネントのツリーを返せばいい。
これがReactをcomposableにしてくれる。フロントエンドを保守するキーとなる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;はルートコンポーネントをインスタンス化し、骨組みを作る。
そしてマークアップ部分を生のDOMへ注入し、ふたつ目の引数として提供される。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ReactDOM&lt;/code&gt;モジュールはDOM特有のメソッドを提供する。
&lt;code&gt;React&lt;/code&gt;は&lt;a href=&#34;http://facebook.github.io/react-native/&#34;&gt;React Native&lt;/a&gt;といったことなるプラットフォーム上で共有されるコアのツールを持つ。
&lt;code&gt;ReactDOM.render&lt;/code&gt;がこのチュートリアルのスクリプトの最下部にとどまることは重要な事だ。
&lt;code&gt;ReactDOM.render&lt;/code&gt;は複合的なコンポーネントが定義された後に呼び出されるべきだからである。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;composing-components:c4edc588c83982a0e8967944828e886f&#34;&gt;Composing components&lt;/h3&gt;

&lt;p&gt;それでは再びシンプルな&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;を使って&lt;code&gt;CommentList&lt;/code&gt;と&lt;code&gt;CommentForm&lt;/code&gt;の骨組みを作成しよう。
ファイルに２つのコンポーネントを作成し、&lt;code&gt;CommentBox&lt;/code&gt;宣言を保ったうえで&lt;code&gt;ReactDOM.render&lt;/code&gt;を呼び出す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial2.js
var CommentList = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        Hello, world! I am a CommentList.
      &amp;lt;/div&amp;gt;
    );
  }
});

var CommentForm = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentForm&amp;quot;&amp;gt;
        Hello, world! I am a CommentForm.
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;続いて&lt;code&gt;CommentBox&lt;/code&gt;コンポーネントを更新し、新しいコンポーネントを利用する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial3.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どのようにしてHTMLタグと作成したコンポーネントを混在させるかに注意すること。
HTMLコンポーネントは通常Reactコンポーネントであり、ひとつの違いはあるが、あなたが定義したもののようだ。
JSXコンパイラは自動的にHTMLタグを&lt;code&gt;React.createElement(tagName)&lt;/code&gt;式に書き直し、全てを孤独にする。
これが名前名前汚染を防ぐことになる。&lt;/p&gt;

&lt;h4 id=&#34;using-props:c4edc588c83982a0e8967944828e886f&#34;&gt;Using props&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Comment&lt;/code&gt;コンポーネントを作成しよう。親から渡されたデータに依存するものになる。
親コンポーネントから渡されたデータは子コンポーネントの&lt;code&gt;property&lt;/code&gt;として利用可能だ。
これらのプロパティには&lt;code&gt;this.props&lt;/code&gt;を使ってアクセスする。&lt;code&gt;props&lt;/code&gt;を使えば、&lt;code&gt;CommentList&lt;/code&gt;から渡された&lt;code&gt;Comment&lt;/code&gt;を読むことができ、レンダリングも可能だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial4.js
var Comment = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        {this.props.children}
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSXの中のJavaScript式を取り囲むことで、ツリー内にReactコンポーネントを書くことができる。
コンポーネントの属性やネストされた要素に&lt;code&gt;this.props&lt;/code&gt;や&lt;code&gt;this.props.children&lt;/code&gt;を用いてアクセスする。&lt;/p&gt;

&lt;h4 id=&#34;component-properties:c4edc588c83982a0e8967944828e886f&#34;&gt;Component Properties&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Comment&lt;/code&gt;コンポーネントの定義が完了したところで、コンポーネントに名前とコメント分を渡していきたい。
各ユニークなコメントに対して同じコードの再利用が可能になる。
&lt;code&gt;CommentList&lt;/code&gt;にコメントを追加してみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial5.js
var CommentList = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        &amp;lt;Comment author=&amp;quot;Pete Hunt&amp;quot;&amp;gt;This is one comment&amp;lt;/Comment&amp;gt;
        &amp;lt;Comment author=&amp;quot;Jordan Walke&amp;quot;&amp;gt;This is *another* comment&amp;lt;/Comment&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;親の&lt;code&gt;CommentList&lt;/code&gt;コンポーネントから子の&lt;code&gt;Comment&lt;/code&gt;コンポーネントにデータを渡していることに注目。
たとえば、属性をお通して&amp;rdquo;Pete Hunt&amp;rdquo;、XMLのような子ノードで&amp;rdquo;This is one comment&amp;rdquo;を渡している。
さらに、&lt;code&gt;Comment&lt;/code&gt;コンポーネントはこれらのプロパティに&lt;code&gt;this.props.author&lt;/code&gt;や&lt;code&gt;this.props.children&lt;/code&gt;を通してアクセスしている。&lt;/p&gt;

&lt;h4 id=&#34;adding-markdown:c4edc588c83982a0e8967944828e886f&#34;&gt;Adding Markdown&lt;/h4&gt;

&lt;p&gt;Markdownはテキストをシンプルに記述するためのフォーマットだ。
例えばテキストをアスタリスクで囲めば、テキストを強調させる。&lt;/p&gt;

&lt;p&gt;このチュートリアルでは、受け取ったMarkdownを生のHTMLにコンバートするサードパーティライブラリである*marked*を利用する。既にこのライブラリは読み込んであるので、もう使いはじめることができる。コメント文のMarkdownをコンバートして出力しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial6.js
var Comment = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        {marked(this.props.children.toString())}
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここではmarkedライブラリの呼び出しを行っているだけだ。&lt;code&gt;this.props.children&lt;/code&gt;をReactのラッパーテキストからmarkedが理解できるように生の文字列にコンバートする必要があるため&lt;code&gt;toString()&lt;/code&gt;を呼び出している。&lt;/p&gt;

&lt;p&gt;けれども問題がひとつ！レンダリングされたコメントが&lt;code&gt;&amp;lt;p&amp;gt;This is &amp;lt;em&amp;gt;another&amp;lt;/em&amp;gt; comment&amp;lt;/p&amp;gt;&lt;/code&gt;のようになっている。
タグを実際のHTMLとしてレンダリングしたいのに。&lt;/p&gt;

&lt;p&gt;これは&lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-site_scripting&#34;&gt;XSS攻撃&lt;/a&gt;からの防御手段となる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial7.js
var Comment = React.createClass({
  rawMarkup: function() {
    var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
    return { __html: rawMarkup };
  },

  render: function() {
    return (
      &amp;lt;div className=&amp;quot;comment&amp;quot;&amp;gt;
        &amp;lt;h2 className=&amp;quot;commentAuthor&amp;quot;&amp;gt;
          {this.props.author}
        &amp;lt;/h2&amp;gt;
        &amp;lt;span dangerouslySetInnerHTML={this.rawMarkup()} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特別なAPIを使って故意に生HTMLの挿入を難しくしているが、markedにとってはメリットとなる。&lt;/p&gt;

&lt;p&gt;こうすることでmarkedの安全性に信頼を置くことができる。このケースでは、&lt;code&gt;sanitize: true&lt;/code&gt;を渡してmarkedにそのまま渡すのではなくソース内のどんなHTMLでもエスケープするように伝えた。&lt;/p&gt;

&lt;h4 id=&#34;hook-up-the-data-model:c4edc588c83982a0e8967944828e886f&#34;&gt;Hook up the data model&lt;/h4&gt;

&lt;p&gt;これまで私たちはコメントをソースコード内に直接挿入してきた。
代わりにJSONデータの塊をコメントリストにレンダリングしてみよう。
ゆくゆくはサーバーから受け取るデータだが、ここではコード内に記述しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial8.js
var data = [
  {id: 1, author: &amp;quot;Pete Hunt&amp;quot;, text: &amp;quot;This is one comment&amp;quot;},
  {id: 2, author: &amp;quot;Jordan Walke&amp;quot;, text: &amp;quot;This is *another* comment&amp;quot;}
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;データをモジュール方式に&lt;code&gt;CommentList&lt;/code&gt;に入れる必要がある。
&lt;code&gt;CommentBox&lt;/code&gt;を修正し、このデータをプロパティを通して&lt;code&gt;CommentList&lt;/code&gt;に入れるために&lt;code&gt;ReactDom.render()&lt;/code&gt;を呼び出す。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial9.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.props.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});

ReactDOM.render(
  &amp;lt;CommentBox data={data} /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでデータが&lt;code&gt;CommentList&lt;/code&gt;内で利用可能になる、コメントをレンダリングしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial10.js
var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (
        &amp;lt;Comment author={comment.author} key={comment.id}&amp;gt;
          {comment.text}
        &amp;lt;/Comment&amp;gt;
      );
    });
    return (
      &amp;lt;div className=&amp;quot;commentList&amp;quot;&amp;gt;
        {commentNodes}
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;fetching-from-the-server:c4edc588c83982a0e8967944828e886f&#34;&gt;Fetching from the server&lt;/h4&gt;

&lt;p&gt;ハードコーディングしてあるデータをサーバーから受け取るように書き換えよう。
データプロパティを取り除き、フェッチするURLに置き換える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial11.js
ReactDOM.render(
  &amp;lt;CommentBox url=&amp;quot;/api/comments&amp;quot; /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコンポーネントは先ほどまでのコンポーネントとは異なる。なぜなら自身で再度レンダリングする必要があるからだ。
コンポーネントにはサーバーからのリクエストが返ってくるまで何もデータがなく、返ってきたら新しいコメントをレンダリングする必要がある。&lt;/p&gt;

&lt;h4 id=&#34;reactive-state:c4edc588c83982a0e8967944828e886f&#34;&gt;Reactive state&lt;/h4&gt;

&lt;p&gt;これまではプロパティに基づいて各コンポーネントは1回だけレンダリングをしてきた。
&lt;code&gt;props&lt;/code&gt;は不変のものだったのだ。親からもらったり、自身で所持していたり。
インタラクションを実装するために、コンポーネントにmutable(変わりやすい)stateを紹介する。
&lt;code&gt;this.state&lt;/code&gt;はprovateであり、&lt;code&gt;this.setState()&lt;/code&gt;を呼び出すことで変更される。
ステートが更新されると、コンポーネントは自身を再レンダリングする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;render()&lt;/code&gt;メソッドは&lt;code&gt;this.props&lt;/code&gt;と&lt;code&gt;this.state&lt;/code&gt;の関数の宣言的に記述されている。
フレームワークはUIが常に入力に対して安定していることを保証する。&lt;/p&gt;

&lt;p&gt;サーバーがデータをフェッチすると、所持しているコメントデータを変更する必要がある。
&lt;code&gt;CommentBox&lt;/code&gt;コンポーネントに自身のステートとしてコメントデータの配列を追加しよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial12.js
var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getInitialState()&lt;/code&gt;はコンポーネントのライフサイクルの中で正確に一度だけ実行され、コンポーネントの初期ステートをセットアップする。&lt;/p&gt;

&lt;h4 id=&#34;updating-state:c4edc588c83982a0e8967944828e886f&#34;&gt;Updating state&lt;/h4&gt;

&lt;p&gt;コンポーネントが最初に作成されたら、サーバーからJSONをGETし、最新のデータを反映させるためにステートを更新したい。
サーバーへの非同期通信を行い、必要なデータを手早くフェッチするためにjQueryを使うつもりだ。
起動しているサーバーの中には既にデータが含まれている。(&lt;code&gt;comments.json&lt;/code&gt;)
なので一度フェッチして、&lt;code&gt;this.state.date&lt;/code&gt;を見ていこう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {&amp;quot;author&amp;quot;: &amp;quot;Pete Hunt&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;This is one comment&amp;quot;},
  {&amp;quot;author&amp;quot;: &amp;quot;Jordan Walke&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;This is *another* comment&amp;quot;}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// tutorial13.js
var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;componentDidMount&lt;/code&gt;メソッドはコンポーネントが最初にレンダリングされた際にReactから自動的に呼び出されるメソッドである。
ダイナミックな更新のキーとなっているのが&lt;code&gt;this.setState()&lt;/code&gt;の呼び出しである。
古いコメントの配列をサーバーから取得した新しい物に置き換え、UIを自動的に更新する。
このリアクティブ性のために、小さな変更を加えライブアップデートを実現する。
ここではシンプルなポーリングを行うが、WebSocketやその他のテクノロジーを使うため簡単にできる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial14.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});

ReactDOM.render(
  &amp;lt;CommentBox url=&amp;quot;/api/comments&amp;quot; pollInterval={2000} /&amp;gt;,
  document.getElementById(&#39;content&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この変更で行ったことはAJAX呼び出しのメソッドを分割して移動し、そのメソッドをコンポーネントの初期読み込み時とその後毎2秒おきに呼び出すというものだ。試しにブラウザで実行し&lt;code&gt;comments.json&lt;/code&gt;を変更してみよう。
2秒以内に変更が反映されるはずだ！&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;adding-new-comments:c4edc588c83982a0e8967944828e886f&#34;&gt;Adding new comments&lt;/h3&gt;

&lt;p&gt;ここではフォームを組み立てよう。&lt;code&gt;CommentForm&lt;/code&gt;コンポーネントはユーザーに名前とコメントテキストを求め、コメントを保存するためにサーバーへ送信する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial15.js
var CommentForm = React.createClass({
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Your name&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Say something...&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;controlled-components:c4edc588c83982a0e8967944828e886f&#34;&gt;Controlled components&lt;/h4&gt;

&lt;p&gt;伝統的なDOMでは、&lt;code&gt;input&lt;/code&gt;要素はレンダリングされ、ブラウザはステートを管理する。
その結果、実際のDOMのステートとコンポーネントのステートの間に差分が生じる。
ビューのステートがコンポーネントのステートを異なるのは理想的ではない。
Reactの場合、初期化の時だけでなくコンポーネントは常にビューのステートを表す。&lt;/p&gt;

&lt;p&gt;それゆえに、入力されたユーザーのインプットを保存するには&lt;code&gt;this.state&lt;/code&gt;を用いる。
私たちは初期の&lt;code&gt;state&lt;/code&gt;を２つのプロパティ、&lt;code&gt;author&lt;/code&gt;と&lt;code&gt;text&lt;/code&gt;で定義し、それらに空の文字列を入れた。
Reactの&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;要素では、コンポーネントの&lt;code&gt;state&lt;/code&gt;を反映させるための&lt;code&gt;value&lt;/code&gt;プロパティをセットし、&lt;code&gt;onChange&lt;/code&gt;ハンドラをつけた。これらの&lt;code&gt;value&lt;/code&gt;つきの&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;要素は&amp;rdquo;controlled components&amp;rdquo;と呼ばれる。
より詳しく知りければ&lt;a href=&#34;https://facebook.github.io/react/docs/forms.html#controlled-components&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot;&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;events:c4edc588c83982a0e8967944828e886f&#34;&gt;Events&lt;/h4&gt;

&lt;p&gt;Reactではコンポーネントにイベントハンドラを付けるときにキャメルケースを使う。
私たちは２つの&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;要素に&lt;code&gt;onChange&lt;/code&gt;というイベントハンドラをつけた。
ここで、ユーザーが&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;フィールドにテキストを入力した場合、&lt;code&gt;onChange&lt;/code&gt;コールバックは発火し、コンポーネントの&lt;code&gt;state&lt;/code&gt;が変更される。&lt;/p&gt;

&lt;p&gt;その後&lt;code&gt;input&lt;/code&gt;要素のレンダリングされた値は現在のコンポーネントの&lt;code&gt;state&lt;/code&gt;を反映するために更新される。&lt;/p&gt;

&lt;h4 id=&#34;submitting-the-form:c4edc588c83982a0e8967944828e886f&#34;&gt;Submitting the form&lt;/h4&gt;

&lt;p&gt;インタラクティブなフォームを作成しよう！
ユーザーがフォームを送信する時、それらをクリアする必要があり、リクエストをサーバーに送信し、そしてコメントのリストをリフレッシュする。
はじめに、フォームの送信イベントをキャッチしてクリアしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial17.js
var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    // TODO: send request to the server
    this.setState({author: &#39;&#39;, text: &#39;&#39;});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot; onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正しい入力でフォームが送信された時はフォームをクリアするような&lt;code&gt;onSubmit&lt;/code&gt;ハンドラを追加した。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;preventDefault()&lt;/code&gt;を呼び出してブラウザのデフォルトのフォーム送信アクションを妨げる。&lt;/p&gt;

&lt;h4 id=&#34;callbacks-as-props:c4edc588c83982a0e8967944828e886f&#34;&gt;Callbacks as props&lt;/h4&gt;

&lt;p&gt;ユーザーがコメントを送信したら、新しいコメントを追加した状態でリストをリフレッシュ留守必要がある。
この全てのロジックを&lt;code&gt;CommentBox&lt;/code&gt;内で行うので、&lt;code&gt;CommentBox&lt;/code&gt;はコメントリストに相応するステートを所有する。&lt;/p&gt;

&lt;p&gt;子コンポーネントから親コンポーネントにデータを渡す必要がある。それを親の&lt;code&gt;render&lt;/code&gt;メソッド内で子に新しいコールバック(&lt;code&gt;handleCommentSubmit&lt;/code&gt;)を渡し、それを子の&lt;code&gt;onCommentSubmit&lt;/code&gt;にバインドすることで実行する。
イベントがトリガーされた時は、コールバックが発動する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial18.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    // TODO: submit to the server and refresh the list
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ユーザがフォームを送信した時は&lt;code&gt;CommentForm&lt;/code&gt;からコールバックを呼びだそう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial19.js
var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    this.props.onCommentSubmit({author: author, text: text});
    this.setState({author: &#39;&#39;, text: &#39;&#39;});
  },
  render: function() {
    return (
      &amp;lt;form className=&amp;quot;commentForm&amp;quot; onSubmit={this.handleSubmit}&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Your name&amp;quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&amp;gt;
        &amp;lt;input
          type=&amp;quot;text&amp;quot;
          placeholder=&amp;quot;Say something...&amp;quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Post&amp;quot; /&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コールバックについて平たく言えば、サーバーに送信してリストをリフレッシュするんだ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial20.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;optimization-optimistic-updates:c4edc588c83982a0e8967944828e886f&#34;&gt;Optimization: optimistic updates&lt;/h3&gt;

&lt;p&gt;このアプリケーションについて機能は完璧であるが、コメントが表示されるまでリクエストが完了するのを待たなければならないため遅いように感じる。
アプリがより早く感じられるようにコメントをリストに追加することが可能だ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// tutorial21.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    var comments = this.state.data;
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now();
    var newComments = comments.concat([comment]);
    this.setState({data: newComments});
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        this.setState({data: comments});
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &amp;lt;div className=&amp;quot;commentBox&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;Comments&amp;lt;/h1&amp;gt;
        &amp;lt;CommentList data={this.state.data} /&amp;gt;
        &amp;lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;congrats:c4edc588c83982a0e8967944828e886f&#34;&gt;Congrats!&lt;/h3&gt;

&lt;p&gt;いくつかのシンプルなステップとを押してコメントボックスを作成することができた。
&lt;a href=&#34;https://facebook.github.io/react/docs/why-react.html&#34;&gt;何故Reactを使うのか&lt;/a&gt;、もしくは&lt;a href=&#34;https://facebook.github.io/react/docs/top-level-api.html&#34;&gt;APIリファレンス&lt;/a&gt;について学び開発を始めよう！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】コンピュータはなぜ動くのか</title>
      <link>http://kotazi.github.io/blog/post/2016/0127_why_computer/</link>
      <pubDate>Wed, 27 Jan 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0127_why_computer/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4822281655/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4822281655&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;コンピュータはなぜ動くのか～知っておきたいハードウエア＆ソフトウエアの基礎知識～&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4822281655&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;を読んだ。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;本の構成:5107f846ab8915f5eb5dfb42a6814246&#34;&gt;本の構成&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;【第1章】コンピュータの3大原則とは&lt;/li&gt;
&lt;li&gt;【第2章】コンピュータを作ってみよう&lt;/li&gt;
&lt;li&gt;【第3章】一度は体験してほしいハンド・アセンブル&lt;/li&gt;
&lt;li&gt;【第4章】川の流れのようにプログラムは流れる&lt;/li&gt;
&lt;li&gt;【第5章】アルゴリズムと仲良くなる7つのポイント&lt;/li&gt;
&lt;li&gt;【第6章】データ構造と仲良くなる7つのポイント&lt;/li&gt;
&lt;li&gt;【第7章】オブジェクト指向プログラミングを語れるようになろう&lt;/li&gt;
&lt;li&gt;【第8章】作れば分かるデータベース&lt;/li&gt;
&lt;li&gt;【第9章】簡単な実験7つでTCP/IPネットワークを理解する&lt;/li&gt;
&lt;li&gt;【第10章】データを暗号化してみよう&lt;/li&gt;
&lt;li&gt;【第11章】そもそもXMLって何だっけ&lt;/li&gt;
&lt;li&gt;【第12章】SEはコンピュータ・システム構築の現場監督&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;2003年に執筆された本。今から13年も前になるので内容としては古い。
ただ入力・演算・出力から始まり、ハードウェアとソフトウェア、プログラミング、データベース、ネットワークなど、コンピュータの初等教育で扱われる内容をほぼひととおり網羅している。&lt;/p&gt;

&lt;p&gt;現場に役に立つ知識ではないが、間違ったことがかかれているわけでもない。
自分の知らない分野について少し知るという意味ではいい。
特にコンピュータのハードウェア的な動作についてやアセンブルについてはとても勉強になった。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;以下、メモ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コンピュータは「入力、演算、出力」を行う装置である&lt;/li&gt;
&lt;li&gt;プログラムは命令とデータの集合体である&lt;/li&gt;
&lt;li&gt;コンピュータの都合は人間の感覚と異なる場合がある&lt;/li&gt;
&lt;li&gt;コンピュータのハードウェアはたくさん「IC」から構成され、ICには数多くのピンがついている&lt;/li&gt;
&lt;li&gt;ピンは入力用、出力用のいずれか&lt;/li&gt;
&lt;li&gt;CPUは内部で演算を行い、メモリとI/Oを制御&lt;/li&gt;
&lt;li&gt;メモリは命令とデータを記憶&lt;/li&gt;
&lt;li&gt;I/Oは周辺機器と接続し、データの受け渡しを可能にする&lt;/li&gt;
&lt;li&gt;CPUを動作させるためには「クロック信号」という電気信号が必要&lt;/li&gt;
&lt;li&gt;クロック信号を出力する部品を「クロックジェネレータ」と呼ぶ&lt;/li&gt;
&lt;li&gt;レジスタはCPU及びI/Oの中で、データを記憶する部分&lt;/li&gt;
&lt;li&gt;0と1の羅列にニックネームを付けてプログラムする手法を「ニーモニック」と呼ぶ&lt;/li&gt;
&lt;li&gt;「ニーモニック」を使う言語が「アセンブリ言語」&lt;/li&gt;
&lt;li&gt;アセンブリの文法は1行に「ラベル」と「オペコード(命令)」と「オペランド(対象)」を記述するだけ&lt;/li&gt;
&lt;li&gt;アセンブリ言語ではオペランドにレジスタの名前を指定する&lt;/li&gt;
&lt;li&gt;CPU資料を見ればアセンブリ言語を手作業でマシン語に変換でき、それを「ハンドアセンブル」という&lt;/li&gt;
&lt;li&gt;ユークリッドの互除法: 最大公約数を求める&lt;/li&gt;
&lt;li&gt;エラトステネスのふるい: 素数を求める&lt;/li&gt;
&lt;li&gt;線形探索: データを探索&lt;/li&gt;
&lt;li&gt;2分探索: データを探索&lt;/li&gt;
&lt;li&gt;ハッシュ法: データを探索&lt;/li&gt;
&lt;li&gt;バブルソート: データを整列&lt;/li&gt;
&lt;li&gt;クイックソート: データを整列&lt;/li&gt;
&lt;li&gt;スタック: データを山のように積み上げる&lt;/li&gt;
&lt;li&gt;キュー: データを行列のように並ばせる&lt;/li&gt;
&lt;li&gt;LIFO: Last In First Out&lt;/li&gt;
&lt;li&gt;FIFO: First in First Out&lt;/li&gt;
&lt;li&gt;キーはテーブル間のリレーションシップを設定するもの&lt;/li&gt;
&lt;li&gt;インデックスはデータの検索速度を向上させる&lt;/li&gt;
&lt;li&gt;テーブルに登録される1行のデータのまとまりを「レコード」「ロウ」「行」と呼ぶ&lt;/li&gt;
&lt;li&gt;レコードを構成する項目を「フィールド」「カラム」「列」と呼ぶ&lt;/li&gt;
&lt;li&gt;正規化とは、テーブルを複数に分け、個々のテーブルのリレーションシップを設定して、データベースの構造を整理すること&lt;/li&gt;
&lt;li&gt;リレーションシップを設定するためにはテーブルとテーブルを関連ふけるためのフィールドが必要。それを「キー」と呼ぶ&lt;/li&gt;
&lt;li&gt;↑自分から見たら「主キー」、逆から見たら「外部キー」&lt;/li&gt;
&lt;li&gt;トランザクションはトラブルが発生した時にロールバックする&lt;/li&gt;
&lt;li&gt;TCPは送受信者が確認を取りながらデータを受け渡すプロトコル。&lt;/li&gt;
&lt;li&gt;↑このようなデータの送信方式が「ハンドシェイク」&lt;/li&gt;
&lt;li&gt;TCPでは大きなデータはパケット単位に分割する&lt;/li&gt;
&lt;li&gt;あらゆるデータは数値なので、形式が違っても暗号手法は基本的に同じ&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;ざっくりそんな感じ。書き出してみると為になったことけっこうあった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】アルゴリズムが世界を支配する</title>
      <link>http://kotazi.github.io/blog/post/2016/0213_algorithm/</link>
      <pubDate>Wed, 27 Jan 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0213_algorithm/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/B00FMI2XIW/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=B00FMI2XIW&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;アルゴリズムが世界を支配する (角川ＥＰＵＢ選書)&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=B00FMI2XIW&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;
を読みました。&lt;/p&gt;

&lt;p&gt;オンラインスーパーマーケットAisle50の共同設立社、クリストファー・スタイナーの著書。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次:ede789d548135e377784ce81f1ae62ff&#34;&gt;目次&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;第1章 ドミノの最初の一牌目、ウォールストリート&lt;/li&gt;
&lt;li&gt;第2章 人類とアルゴリズムの歴史&lt;/li&gt;
&lt;li&gt;第3章 ボット トップ40&lt;/li&gt;
&lt;li&gt;第4章 ボットの秘密のハイウェイ&lt;/li&gt;
&lt;li&gt;第5章 システムをゲーム化しろ&lt;/li&gt;
&lt;li&gt;第6章 ドクター・ボットを呼べ&lt;/li&gt;
&lt;li&gt;第7章 人類をカテゴライズする&lt;/li&gt;
&lt;li&gt;第8章 ウォールストリート vs シリコンバレー&lt;/li&gt;
&lt;li&gt;第9章 ウォールストリートが損をすれば他のみんなは儲かる&lt;/li&gt;
&lt;li&gt;第10章 未来はアルゴリズムとそのクリエイターのもの&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;ここのところ機械学習やディープラーニングの話題をよく耳にするので買ってみた。&lt;/p&gt;

&lt;p&gt;読んでみると株式取引や音楽を自動生成するアルゴリズムなどがかなり昔から存在することを知った。
近年ではポーカーや医療の場でもアルゴリズムは大きく活躍しており、
これからは本当にデータやアルゴリズムの時代のような気がしてしまった。&lt;/p&gt;

&lt;p&gt;アルゴリズムはすでに我々の言葉をきいて、その本音を読み取ることができるようになっている。
ポーカーや電話の自動オペレーターの話を読んでいると、今まではアルゴリズムは
天才的な人間のモデルを作ることだと思っていたけれど、どうやらそれには少し誤解があるらしかった。&lt;/p&gt;

&lt;p&gt;例えば電話対応の場合、ある電話は情報を得るためにかけられており、ある電話は共感や日常会話を求めてかかってきたものだとする。
最初の電話では、情報を伝えれば相手はすぐに満足するだろうが、雑談をし始めたらイライラするかもしれない。
2つ目の電話の場合、謝罪や誠実で思いやりのある対応が相手を最も満足させる。&lt;/p&gt;

&lt;p&gt;このようにアルゴリズムは相手によって対応を変える必要がある。&lt;br /&gt;
そして元々NASAで宇宙飛行士の相性を調べるために開発されたテービー・ケーラー博士の手法では
人間を以下の6つのタイプに分類するらしい。&lt;/p&gt;

&lt;p&gt;1: 感情重視型の人。課題に取り掛かる前に関係者と人間関係を築く。女性がこのグループの3/4を占める。全体の30%がこのグループ。窮地に陥ると劇的になり過剰反応を起こす&lt;br /&gt;
2: 思考重視型の人。社交辞令や冗談を言わない。現実ジを重視し、意思決定は厳格な現実主義に基づいて行われる。&lt;br /&gt;
3: 行動重視型の人。進捗や行動を望む。常に精力的で押しが強い。魅力的な人間が多い。&lt;br /&gt;
4: 内省重視型の人。温和で想像力が豊か。現実に取り組みよりも、これからどうなるだろうかと考えをめぐらせる。&lt;br /&gt;
5: 意見重視型の人。話し言葉は命令形と断定系が多い。状況の一面しか見ない傾向がある。自分お意見に固執する。政治家の70%はこのグループ。全人口ではったの10%。勤勉であり、問題解決まで粘り強い。&lt;br /&gt;
6: リアクション重視型の人。自発的で独創的。冗談が好きである。物事に対して強い反応を示す。起業家、発明家に多い。&lt;/p&gt;

&lt;p&gt;もちろん複数のタイプを持つこともある。&lt;/p&gt;

&lt;p&gt;この本を読んでアルゴリズムに興味が湧いた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】ユーザーストーリーマッピング</title>
      <link>http://kotazi.github.io/blog/post/2016/0213_user_story/</link>
      <pubDate>Wed, 27 Jan 2016 11:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0213_user_story/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4873117321/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4873117321&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;ユーザーストーリーマッピング&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4873117321&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;
を読みました。&lt;/p&gt;

&lt;p&gt;アジャイルUXの第一人者として活躍するジェフ・パットン氏の著書。&lt;br /&gt;
自身が開発した手法について書き下ろされら書籍。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://codezine.jp/article/detail/6404&#34;&gt;良いプロダクトを発見・具現化するために、チームはどう動くべきか？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://daipresents.com/2011/jeff-patton%E6%B0%8F%E3%81%AE-%E6%83%85%E7%86%B1%E3%83%97%E3%83%AD%E3%83%80%E3%82%AF%E3%83%88%E3%82%AA%E3%83%BC%E3%83%8A%E3%83%BC%E3%82%B7%E3%83%83%E3%83%97-%E3%81%AB%E5%8F%82%E5%8A%A0%E3%81%97/&#34;&gt;Jeff Patton氏の “情熱プロダクトオーナーシップ” に参加しました&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;目次:2179e5f5f3ee66c47dc4d32c38e661c1&#34;&gt;目次&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;0章 まず最初に読んでください&lt;/li&gt;
&lt;li&gt;1章 全体像&lt;/li&gt;
&lt;li&gt;2章 作るものを減らすためのプラン&lt;/li&gt;
&lt;li&gt;3章 より速く学ぶためのプラン&lt;/li&gt;
&lt;li&gt;4章 時間どおりに終わらせるためのプラン&lt;/li&gt;
&lt;li&gt;5章 あなたはもうやり方を知っている&lt;/li&gt;
&lt;li&gt;6章 ストーリーについての本当のストーリー&lt;/li&gt;
&lt;li&gt;7章 より良いストーリーテリングのために&lt;/li&gt;
&lt;li&gt;8章 カードに書かれていることが全てではない&lt;/li&gt;
&lt;li&gt;9章 カードは始まりにすぎない&lt;/li&gt;
&lt;li&gt;10章 ケーキのようにストーリーを焼く&lt;/li&gt;
&lt;li&gt;11章 岩を砕いていく&lt;/li&gt;
&lt;li&gt;12章 岩を砕く人&lt;/li&gt;
&lt;li&gt;13章 オポチュニティから始める&lt;/li&gt;
&lt;li&gt;14章 ディスカバリーを介して共通理解を築く&lt;/li&gt;
&lt;li&gt;15章 ディスカバリーによる検証された学習&lt;/li&gt;
&lt;li&gt;16章 リファイン、定義、構築&lt;/li&gt;
&lt;li&gt;17章 ストーリーは実際にはアステロイドに似ている&lt;/li&gt;
&lt;li&gt;18章 構築するすべてのものから学ぶ&lt;/li&gt;
&lt;li&gt;19章 終わり？それとも&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;多くの企業がアジャイルやリーンプロセスを取り入れる一環としてストーリーを取り入れている。
しかしその取組の中で、全体像を見失ってしまったり、何が作られているのか分からなくなってしまったり、
共通理解が得られなかったり。そういったチーム開発における悩みをユーザーストーリーマッピングを用いて紐解いていく本。&lt;/p&gt;

&lt;p&gt;ただ、この本の序文を&lt;a href=&#34;http://www.amazon.co.jp/Inspired-%E9%A1%A7%E5%AE%A2%E3%81%AE%E5%BF%83%E3%82%92%E6%8D%89%E3%81%88%E3%82%8B%E8%A3%BD%E5%93%81%E3%81%AE%E5%89%B5%E3%82%8A%E6%96%B9-%E3%83%9E%E3%83%BC%E3%83%86%E3%82%A3-%E3%82%B1%E3%82%A4%E3%82%AC%E3%83%B3-ebook/dp/B00TCM8TB4&#34;&gt;Inspired&lt;/a&gt;の著者マーティケーガンが執筆しており、
&lt;a href=&#34;http://www.amazon.co.jp/HARD-THINGS-%E7%AD%94%E3%81%88%E3%81%8C%E3%81%AA%E3%81%84%E9%9B%A3%E5%95%8F%E3%81%A8%E5%9B%B0%E9%9B%A3%E3%81%AB%E3%81%8D%E3%81%BF%E3%81%AF%E3%81%A9%E3%81%86%E7%AB%8B%E3%81%A1%E5%90%91%E3%81%8B%E3%81%86%E3%81%8B-%E3%83%99%E3%83%B3-%E3%83%9B%E3%83%AD%E3%82%A6%E3%82%A3%E3%83%83%E3%83%84-ebook/dp/B00W535LOU&#34;&gt;HARD THINGS&lt;/a&gt;の著者ベン・ホロヴィッツの
&lt;a href=&#34;https://a16z.files.wordpress.com/2014/08/good-product-manager.pdf&#34;&gt;Good Product Manager/Bad Product Manager&lt;/a&gt;
に倣い、強力な製品開発チームと非力なチームの重要な違いを挙げている。&lt;br /&gt;
それが面白かったので引用したい。&lt;/p&gt;

&lt;p&gt;優れたチームには、使命感といえるほどの情熱を持って追求したくなる圧倒的な魅力のあるビジョンがある。
ダメなチームは報酬しか考えない。&lt;/p&gt;

&lt;p&gt;優れたチームは、リアルな問題を解決するためにスコアカードKPI，顧客の苦闘の状況、顧客が製品を使った時に生成されるデータを良く見て、絶えず新技術を応用するチャンスを探しながら、ヒントやアイディアを掴んでいる。ダメなチームは営業や顧客から要件を集めてくる。&lt;/p&gt;

&lt;p&gt;優れたチームは、もっとも大切なステークホルダーが誰か、そのステークホルダーがどのような制約を抱えているのかを理解し、
ユーザーと顧客のために役立つだけでなく、ビジネスの制約の枠内で作れるソリューションを作り出すことに力を注いでいる。
ダメなチームは、ステークホルダーから要件を集めてくる。&lt;/p&gt;

&lt;p&gt;優れたチームは、そのアイディアが本当に構築に値するのか見極めるために、アイディアをすぐに試せるテクニックを習熟している。
ダメなチームは、優先順位を指定したロードマップを作るために会議を開く。&lt;/p&gt;

&lt;p&gt;優れたチームは、社内各部署の優秀なリーダーを集めたブレーンストーミングを積極的に行う。ダメなチームは、チーム外の誰かが提案してくれても反発する。&lt;/p&gt;

&lt;p&gt;優れたチームは、製品担当、デザイン担当、技術担当が隣同士に座り、機能、ユーザーエクスペリエンス、実現するためのテクノロジーにおける助け合いを推進している。ダメなチームは、それぞれの部門の席に座り、部門の外からのサービスの以来には、文書による以来や会議の日程調整を要求する。&lt;/p&gt;

&lt;p&gt;優れたチームは、イノベーションのためにいつでも新しいアイディアを試そうとするが、収益とブランドはきっちり守る。
ダメなチームはテストの実行許可を待ち続ける。&lt;/p&gt;

&lt;p&gt;優れたチームは、力のあるインタラクションデザインなど、勝てる商品を作るために必要なスキルセットの確保にこだわる。
ダメなチームは、インタラクションデザインがどのような仕事かさえ知らない。&lt;/p&gt;

&lt;p&gt;優れたチームは、エンジニアが毎日ディスカバリープロトタイプを試す時間を持っている。製品をよくするための意見も言える。
ダメなチームは、急ぎの案件の時だけ、見積書を作るためにエンジニアにプロトタイプを見せる。&lt;/p&gt;

&lt;p&gt;優れたチームは、顧客をよりよく理解し、最新のアイディアに対する顧客の反応を見るために毎週、顧客と直接議論する。
ダメなチームは、自分がお客さんだと思っている。&lt;/p&gt;

&lt;p&gt;優れたチームは、自分たちが気に入ったアイディアの多くが顧客の役に立たないことを知っており、役に立つかもしれないものでも、
望ましい成果を挙げるまでには、数回のイテレーションが必要であることを知っている。
ダメなチームは、ロードマップに載ったものを作り、納期と要件を満たしていれば満足してしまう。&lt;/p&gt;

&lt;p&gt;優れたチームは、スピードの重要性を知っていて、イノベーションで鍵を握るのがイテレーションの早さであることを理解している。
ここで言うスピードは、適切なテクニックによって得られるもので、時間労働のようなもので得られるものではないこともわかっている。
ダメなチームは、同僚が働いてくれないからペースが上がらないと不満を言う。&lt;/p&gt;

&lt;p&gt;優れたチームは、顧客からの要望をよく吟味し、顧客と自社の業績に貢献できそうなソリューションだと確信したら、
その実現のために力を注ぐ。
ダメなチームは、営業に振り回される会社だと文句を言う。&lt;/p&gt;

&lt;p&gt;優れたチームは、フィードバックの仕組みを作る。製品がどのように使われているかをすばやく知り、そのデータにもとづいて製品に調整を加える。
ダメなチームは、分析、レポート機能を、あると良い機能だと思っている。&lt;/p&gt;

&lt;p&gt;優れたチームは、コンスタントに小規模なリリースを重ねたほうが顧客に安定したソリューションを提供できることを知っている。
そのために継続的にインテグレーション、リリースを行う。ダメなチームは、苦痛に満ちたインテグレーションのフェーズの
最後にマニュアルでテストを行い、それからすべてをまとめてリリースをする。&lt;/p&gt;

&lt;p&gt;優れたチームは、重要な顧客のことで悩む。
ダメなチームは、競合他社のことで悩む。&lt;/p&gt;

&lt;p&gt;優れたチームは、ビジネスKPIに大きなインパクトを与えられたときに祝杯をあげる。
ダメなチームは、何かをリリース出来たときに祝杯をあげる。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;序文を引用したら長くなってしまった。
とにかく本著の内容は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ストーリーは、要件を形式に落としこむためのものではない。言葉と絵を使いながらストーリーを話すのは、共通理解を築くためのメカニズムだ。&lt;/li&gt;
&lt;li&gt;ストーリーは要件ではない。会社、顧客、ユーザーが抱える問題の解決についての議論であり、何を作るかについての意見を一致に導くものだ。&lt;/li&gt;
&lt;li&gt;あなたがしなければならないことは、より早くより多くのソフトウェアを作ることではない。作ると決めたものから最大限の成果とインパクトを生み出すことだ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということである。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;最後に、もっとも感動した一文。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「本当は、あなたの仕事は世界を変えることだ。」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;素晴らしいアイディアを製品に転化するのであれば、
それを使う人々の世界を少し、あるいは少なからず変えてしまうことになる。&lt;br /&gt;
実際にそうなっていなければ、あなたの取り組みは失敗なのだ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【訳読】JSX</title>
      <link>http://kotazi.github.io/blog/post/2016/0126_jsx/</link>
      <pubDate>Tue, 26 Jan 2016 21:47:07 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0126_jsx/</guid>
      <description>

&lt;p&gt;勉強がてら&lt;a href=&#34;https://jsx.github.io/doc/tutorial.html&#34;&gt;JSXのTutorial&lt;/a&gt;を翻訳しました。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;background:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;JSXはJavaScriptへのコンパイルが可能な、静的型付けかつオブジェクト指向のプログラミング言語です。
JavaScriptよりも頑丈なプログラミング言語が必要だったためにJSXは開発されました。
とはいえ、JSXはとりわけ文や式など、そこそこJavaScriptに近いように作られています。&lt;/p&gt;

&lt;p&gt;ミスタイポや変数名や関数の定義忘れなどをコンパイル時に検知可能のため、静的型付け言語は頑丈なプログラミング言語といえます。
これは特に多くのエンジニアが携わる中規模から大規模のプロジェクトにおいて重要なことです。&lt;/p&gt;

&lt;p&gt;それゆえに、JSXは静的型付け言語として設計されました。
全ての値と変数には静的な型があり、適切な方の値のみを代入することができます。
加えて、全ての関数はパラメータと返り値によって決定されたクロージャーに含まれます。
引数の型が間違っていると代入することはできません。&lt;/p&gt;

&lt;p&gt;またJSXを開発した別の重要な理由として、JSのパフォーマンスを引き上げつことがありました。
JavaScript自身が遅いということはないのですが、大規模開発になると抽象的なレイヤーが肥大化しがちです。
例えば代用的なクラスやアクセサメソッドのことであり、これらはしばしばパフォーマンスにネガティブな影響を与えます。
JSZでは&amp;rdquo;inline expansion&amp;rdquo;によってパフォーマンスを引き上げています。
これはコンパイル時に関数呼び出しが決定したものを、関数本体を呼び出し元の方へ拡張することです。
静的型付け言語のパフォーマンスのちからになります。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;run-hello-world:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Run &amp;ldquo;Hello, World!&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;JSXのプログタムを実行してみましょう。&lt;code&gt;jsx&lt;/code&gt;コマンドを使い、JSXをJavaScriptにコンパイルします。&lt;/p&gt;

&lt;p&gt;まずはnpmでjsxをインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install -g jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしたら下記のコードで&lt;code&gt;hello.jsx&lt;/code&gt;を作成しましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class _Main {
    static function main(args : string[]) : void {
        log &amp;quot;Hello, world!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下記のコマンドでJSXを実行することができ、&amp;rdquo;Hello, world&amp;rdquo;がコンソール上に出力されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jsx --run hello.jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次のセクションではhello.jsxについて詳しく見ていきましょう。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;program-structure:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Program Structure&lt;/h3&gt;

&lt;p&gt;ここでは&amp;rdquo;Hello world!&amp;ldquo;サンプルであるhello.jsxについて取り扱っていきます。
このプログラムに名前や静的型付け、クラス構造といったいくつかのJSXの機能を見ることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class _Main {
    static function main(args : string[]) : void {
        log &amp;quot;Hello, world!&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_Main&lt;/code&gt;クラスは&lt;code&gt;main&lt;/code&gt;という名前の静的メンバ関数を持ちます。&lt;code&gt;main&lt;/code&gt;関数は文字列型の配列を引数に取り、返り値はありません。
&lt;code&gt;_Main.main(:string[]):&lt;/code&gt;はJSXアプリケーションのエントリーポイントであり、ユーザーがコマンドラインからアプリケーションを実行した時に呼び出されるものです。JSXはJavaのように、トップレベルに文や関数を置くことを許しません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;log&lt;/code&gt;文はJavaScriptの&lt;code&gt;console.log()&lt;/code&gt;をマップしたものです。&lt;/p&gt;

&lt;p&gt;続いて、別の典型的なライブラリのクラスを見ていきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Point {
    var x = 0;
    var y = 0;

    function constructor() {
    }

    function constructor(x : number, y : number) {
        this.set(x, y);
    }

    function constructor(other : Point) {
        this.set(other);
    }

    function set(x : number, y : number) : void {
        this.x = x;
        this.y = y;
    }

    function set(other : Point) : void {
        this.set(other.x, other.y);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見て分かる通り、Pointのメンバ変数であるxとyは型なしで宣言されています。
けれどもそれらの方は初期値からnumber型であることが分かります。&lt;/p&gt;

&lt;p&gt;複数のconstructorsに驚いたかもしれません。
ひとつはパラメータをとらず、他のものはとります。
パラメータの型が重複しています。
あなたが&lt;code&gt;new Point()&lt;/code&gt;を用いてクラスを生成する場合、最初のコンストラクタは引数無しで呼びだされます。
ふたつ目のコンストラクタは、&lt;code&gt;new Point(2, 3)&lt;/code&gt;といったように２つの引数を必要とします。３つめはコピーのコンストラクタとしてひとつ引数にとります。
&lt;code&gt;new Point(42)&lt;/code&gt;や&lt;code&gt;new Point(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;)&lt;/code&gt;といったその他の方法では、コンパイル時にエラーが起きます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Point#set()&lt;/code&gt;関数もまた重複しており、コンパイラは正しい引数の取り方を知っています。&lt;/p&gt;

&lt;Hr&gt;

&lt;h3 id=&#34;static-typing:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Static Typing&lt;/h3&gt;

&lt;p&gt;基本的な型の概要についてはこの章で述べます。プリミティブ型やオブジェクト型、Variant型、Null型がJSZには存在します。&lt;/p&gt;

&lt;h4 id=&#34;pritimive-types:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Pritimive Types&lt;/h4&gt;

&lt;p&gt;JSXには3つのプリミティブ型が存在します。&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;です。
これらの3つはNull型にはならず、不変の型です。&lt;/p&gt;

&lt;p&gt;下の例文では&lt;code&gt;s&lt;/code&gt;、&lt;code&gt;n&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;の変数を型とともに宣言しています。&lt;code&gt;:&lt;/code&gt;マークを使って変数名の右側に記述します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s : string;
var n : number;
var b : boolean;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;型宣言は初期値を代入することで省略することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s = &amp;quot;hello&amp;quot;;  // s is string, initialized as &amp;quot;hello&amp;quot;
var n = 42;       // n is number, initialized as 42
var b = true;     // b is boolean, initialized as true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;object-types:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Object Types&lt;/h4&gt;

&lt;p&gt;オブジェクト型はクラスのインスタンスオブジェクトに参照を持つ方になります。
例えば、関数、文字列配列、Dateオブジェクトは全てオブジェクト型になります。
型が変わりやすいかは各クラスの定義に依存しいます。&lt;/p&gt;

&lt;p&gt;大半のオブジェクトは&lt;code&gt;new&lt;/code&gt;演算子を用いて生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var d = new Date();            // instantiate an object of class Date
var a = new Array.&amp;lt;string&amp;gt;();  // instantiate an array of string
var m = new Map.&amp;lt;number&amp;gt;();    // instantiate an associative map of strings to numbers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayとMapについては初期化式を用いたイニシャライズが可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a1 = [] : Array.&amp;lt;string&amp;gt;;  // a1 is Array.&amp;lt;string&amp;gt;, and is empty
var a2 = [ 1, 2, 3 ];          // a2 is Array.&amp;lt;number&amp;gt; with three elements

var m1 : {} : Map.&amp;lt;number&amp;gt;;    // m1 is Map.&amp;lt;number&amp;gt;
var m2 = {                     // m2 is Map.&amp;lt;string&amp;gt;
  en: &amp;quot;Good morning&amp;quot;,
  de: &amp;quot;Guten Morgen&amp;quot;,
  ja: &amp;quot;ãã¯ãããããã¾ã&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Functionクラスの変数のみ、静的関数として生成することや、またfunction式やfunction文を使って生成することが可能です。&lt;/p&gt;

&lt;h4 id=&#34;the-variant-type:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;The Variant Type&lt;/h4&gt;

&lt;p&gt;Variant型は&amp;rdquo;静的型情報がない&amp;rdquo;という意味です。既存のJavaScriptAPIに役立ちます。
バリアント変数を返すJavaScriptライブラリもあるかもしれません。これらの型はコンパイル時に決定することができません。
バリアントの値に対してできることは、variantのあたいかそうでない値かをチェックすることだけです。&lt;/p&gt;

&lt;p&gt;何かする前に値に対してチェックをする必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function guessTheType(v : variant) : void {
    if (typeof v == &amp;quot;string&amp;quot;) {
        log &amp;quot;v is string and the value is:&amp;quot; + v as string;
    } else {
        log &amp;quot;v is not string&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;nullable-types:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Nullable Types&lt;/h4&gt;

&lt;p&gt;Nullable型はメタ型です。値がnullかもしれないことを示します。
primitive型にnullを代入することは禁止されています。(Object型はデフォルトではnullです。)
Nullable型はこのような目的で使われます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s1 : string;
s1 = &amp;quot;abc&amp;quot;;       // ok
s1 = null;        // compile error!  cannot assign null to string

var s2 : Nullable.&amp;lt;string&amp;gt;;
s2 = &amp;quot;abc&amp;quot;;       // ok
s2 = null;        // ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nullable型の最も特出した使い方は、配列との使い方です。
ある配列の数より多い値にアクセスするとnullを返します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = [ 1, 2, 3 ]; // creates Array.&amp;lt;number&amp;gt; with three elements
a[3];                // out-of-bounds access, returns null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nullableを返すAPIが他にも存在します。例えば&lt;code&gt;&amp;lt;string&amp;gt;#shift() is Nullable.&amp;lt;string&amp;gt;&lt;/code&gt;。
Nullableな値を使った時、その値がnullでないか確認する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function shiftOrReturnEmptyString(args : string[]) : string {
    if (args.length &amp;gt; 0)
        return args.shift();
    else
        return &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードがデバッグモードでコンパイルされる時(デフォルト値です。)、コンパイラは実行時に型の確認コードを埋め込みます。
null値の誤用が検知されると例外が発生します。
ランタイム型確認では&lt;code&gt;--release&lt;/code&gt;オプションでコンパイルを生着することができます。&lt;/p&gt;

&lt;p&gt;より詳しく知るためには&lt;a href=&#34;https://jsx.github.io/doc/typeref.html&#34;&gt;Types&lt;/a&gt;セクションを参照してください。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;expressions:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Expressions&lt;/h3&gt;

&lt;p&gt;JSXにおける演算子の定義はほとんどJavaScriptと同じです。しかしながら違う点もあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;算術演算子は非演算子に数字のみをとります&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var a = 3;
a + 1;      // OK, returns 4
a * a;      // OK, returns 9
a + &amp;quot;abc&amp;quot;;  // compile error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意: 連結演算子(+)による文字列の結合は存在します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ドット演算子によるプロパティアクセスは定義されたプロパティのみになります&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class Point {
    var x : number;
    var y : number;
    function print() : void {
        log this.z;             // compile error! no property named z
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;プロパティではMapかvariantのみにアクセスできます&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var m = {            // m is Map.&amp;lt;string&amp;gt;
    hello: &amp;quot;world!&amp;quot;
};
log m[&amp;quot;hello&amp;quot;];      // OK
log m.hello;         // compile error!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;as&lt;/code&gt;演算子を導入します。型変換に用いられます&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var n = 123;
var s = &amp;quot;value of n is &amp;quot; + (n as string);
log s;               // print &amp;quot;value of n is 123&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;, ||&lt;/code&gt;演算子はBooleanを返します。&lt;code&gt;?:&lt;/code&gt;を導入します。これは&lt;code&gt;||&lt;/code&gt;と等価です。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;https://jsx.github.io/doc/operatorref.html&#34;&gt;Operator Reference&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;h4 id=&#34;statements:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Statements&lt;/h4&gt;

&lt;p&gt;JSXではJavaScriptで提供される多くの構文をサポートします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;log statement&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;log &amp;quot;hello, world&amp;quot;;    // log strings to console, can turned off with compile option: --release
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;assert statement&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var n = 123;
assert n != 0;         // assertions.  also can be turned off with --release
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;try-catch-finally statement&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;try {
    ...
} catch (e : TypeError) {
    // got TypeError
} catch (e : Error) {
    // got Error, which is not TypeError
} catch (e : variant) {
    // applications may throw any kind of value
} finally {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;try-catch-finally statement&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;https://jsx.github.io/doc/statementref.html&#34;&gt;Statement Reference&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;classes-and-interfaces:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Classes and Interfaces&lt;/h3&gt;

&lt;p&gt;JSXはクラスベースのオブジェクト指向言語です。クラスモデルはJavaに似ています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;クラスを別のクラスに拡張できる&lt;/li&gt;
&lt;li&gt;クラスは福通のインターフェイスやミックスインを実装する&lt;/li&gt;
&lt;li&gt;すべてのクラスはひとつのルートクラスをシェアする: Objectクラス&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;all classes share a single root class: the Object class
interface Flyable {
    abstract function fly() : void;
}

abstract class Animal {
    function eat() : void {
      log &amp;quot;An animal is eating!&amp;quot;;
    }
}

class Bat extends Animal implements Flyable {
    override function fly() : void {
        log &amp;quot;A bat is flying!&amp;quot;;
    }
}

abstract class Insect {
}

class Bee extends Insect implements Flyable {
    override function fly() : void {
        log &amp;quot;A bee is flying!&amp;quot;;
    }
}

class _Main {

    static function main(args : string[]) : void {
        // fo bar
        var bat = new Bat();

        var animal : Animal = bat; // OK. A bat is an animal.
        animal.eat();

        var flyable : Flyable = bat; // OK. A bat can fly
        flyable.fly();

        // for Bee
        var bee = new Bee();

        flyable = bee; // A bee is also flyable
        flyable.fly();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例において、BatクラスはAnimalクラスを拡張したものであり、&lt;code&gt;Animal#eat()&lt;/code&gt;というメンバ関数を継承しています。そしてAnimal型に変数に代入することも可能です。
BatクラスはまたFlyableクラスの&lt;code&gt;Flyable#fly()&lt;/code&gt;メンバ関数をオーバーライドして実装しています。そのため、Flyableの変数に代入することも可能です。
また、別のflyableクラスがありいます。Beeクラスです。
Flyableインターフェイスを使うことで、例えbeeとbatが完全に異なる組織だったとしても、両方のクラスに対応することができます。&lt;/p&gt;

&lt;p&gt;メンバ関数をオーバーライドした時に、&lt;code&gt;override&lt;/code&gt;キーワードの使用は委任されます。
それにも関わらず、コンパイラはエラーを発生させます。言い換えれば、やっかいなエラーを出す代わりに、予期せぬベースクラスのインターフェイスの変更による編集エラーからあなたを救っています。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;functions-and-closures:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Functions and Closures&lt;/h3&gt;

&lt;p&gt;JSXでは、関数が最初のクラスオブジェクトであり、静的な型をもっています。
&lt;code&gt;var f : function(arg : number) : number&lt;/code&gt;といった関数型の変数を宣言することができます。
関数は引数にnumberを取り、別のnumberを返すといったように。(同じ値を返すかもしれませんがここでは重要ではありません。)
その変数&lt;code&gt;f&lt;/code&gt;は&lt;code&gt;f(42)&lt;/code&gt;といって呼び出しをされ、数値を返しいます。&lt;/p&gt;

&lt;p&gt;function式やfunction文を使ってクロージャーを定義することができあmす。
典型的な方法でGUIプログラミングで人気のイベントリスナやコールバックを実装します。
クロージャーはJavaScriptの&lt;code&gt;this&lt;/code&gt;に似ています。メンバ関数内でクロージャーが出意義された時、メンバ関数のレシーバーを参照します。下記のサンプルを見てください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class _Main {
    var foo = 42;

    function constructor() {
        var f = function() : void {
            log this.foo;
        };

        f(); // says 42
    }

    static function main(args : string[]) : void {
        var o = new _Main();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;function式やfunction文のアノテーションはコンパイラに推測された場合に省略されるかもしれません。
下記の例では、引数のnも式の返り値も&lt;code&gt;Array#map&lt;/code&gt;の定義からnumberになることが推測されます。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;modules:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Modules&lt;/h3&gt;

&lt;p&gt;JSXはモジュールシステムを持ちます。&lt;code&gt;import&lt;/code&gt;式を使ってJSXのクラスライブラリを利用することができます。
例えば、下記のプログラムでは&lt;code&gt;timer.jsx&lt;/code&gt;モジュールを使用し、Timerクラスをエクスポートしています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;timer.jsx&amp;quot;;

class _Main {

    static function main(args : string[]) : void {
        Timer.setTimeout(function() : void {
            log &amp;quot;Hello, world!&amp;quot;;
        }, 1000);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;モジュールは複数のクラスをエクスポートしますが、インポートするモジュールを指定したり、インポートしたモジュールにネームスペースをつけたりすることができます。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;interface-to-web-browsers:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Interface to Web Browsers&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;js/web.jsx&lt;/code&gt;モジュールはWebブラウザへのインターフェイスを提供します。
下記のサンプルではどのように挿入するかを見せます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// hello.jsx
import &amp;quot;js/web.jsx&amp;quot;;

class _Main {

    static function main(args : string[]) : void {
        var document = dom.window.document;

        var text = document.createTextNode(&amp;quot;Hello, world!&amp;quot;);
        document.getElementById(&amp;quot;hello&amp;quot;).appendChild(text);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hello, world!&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;hello.jsx.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;p id=&amp;quot;hello&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以前コマンドからコンパイルした&lt;code&gt;hello.jsx&lt;/code&gt;を用いて、アクセスしたHTMLで&amp;rdquo;Hello, world!&amp;ldquo;を確認できます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bin/jsx --executable web --output hello.jsx.js hello.jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;further-learning:eefede6fd0575a7a2327da935aefa0bf&#34;&gt;Further Learning&lt;/h3&gt;

&lt;p&gt;より詳しいドキュメントは&lt;a href=&#34;https://github.com/jsx/JSX/wiki&#34;&gt;wiki&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;p&gt;サンプルを探しているのであれば、&lt;a href=&#34;https://jsx.github.io/#examples&#34;&gt;example&lt;/a&gt;を参照してください。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【FullCalendar】Current Date</title>
      <link>http://kotazi.github.io/blog/post/2016/0125_calendar/</link>
      <pubDate>Mon, 25 Jan 2016 22:53:46 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0125_calendar/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fullcalendar.io/docs/current_date/&#34;&gt;Current Date&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;agendaWeek&lt;/code&gt;と&lt;code&gt;agendaDay&lt;/code&gt;用のオプションです。&lt;/p&gt;

&lt;hr&gt;

&lt;h5 id=&#34;defaultdate-http-fullcalendar-io-docs-current-date-defaultdate:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/defaultDate&#34;&gt;defaultDate&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;最初の読み込み時に表示する日時。&lt;/p&gt;

&lt;h5 id=&#34;nowindicator-http-fullcalendar-io-docs-current-date-nowindicator:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/nowIndicator&#34;&gt;nowIndicator&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;現在時刻にマーカーを引くかどうか。&lt;/p&gt;

&lt;h5 id=&#34;prev-method-http-fullcalendar-io-docs-current-date-prev:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/prev&#34;&gt;prev (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;前に戻るためのメソッド。&lt;/p&gt;

&lt;h5 id=&#34;next-method-http-fullcalendar-io-docs-current-date-next:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/next&#34;&gt;next (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;次に進むためのメソッド。&lt;/p&gt;

&lt;h5 id=&#34;prevyear-method-http-fullcalendar-io-docs-current-date-prevyear:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/prevYear&#34;&gt;prevYear (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;前年に戻る。&lt;/p&gt;

&lt;h5 id=&#34;nextyear-method-http-fullcalendar-io-docs-current-date-nextyear:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/nextYear&#34;&gt;nextYear (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;翌年に進む。&lt;/p&gt;

&lt;h5 id=&#34;today-method-http-fullcalendar-io-docs-current-date-today:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/today&#34;&gt;today(method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;今日を表示する。&lt;/p&gt;

&lt;h5 id=&#34;gotodate-method-http-fullcalendar-io-docs-current-date-gotodate:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/gotoDate&#34;&gt;gotoDate(method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;指定日へ移動する。&lt;/p&gt;

&lt;h5 id=&#34;incrementdate-method-http-fullcalendar-io-docs-current-date-incrementdate:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/incrementDate&#34;&gt;incrementDate(method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;指定日時分だけ移動する。&lt;/p&gt;

&lt;h5 id=&#34;getdate-method-http-fullcalendar-io-docs-current-date-getdate:64626c8a94a6af0c72d57024092cd2ec&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/current_date/getDate&#34;&gt;getDate(method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;日付を取得する。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】How Google Works</title>
      <link>http://kotazi.github.io/blog/post/2016/0129_google/</link>
      <pubDate>Sun, 24 Jan 2016 18:40:44 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0129_google/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4532319552/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4532319552&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;How Google Works (ハウ・グーグル・ワークス)  ―私たちの働き方とマネジメント&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4532319552&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;を読んだ。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;ラリー・ペイジとセルゲイ・ブリンによって創業された企業「Google」。&lt;br /&gt;
そのGoogleの働き方について書かれた本である。著者は元CEOのエリック・シュミット。&lt;/p&gt;

&lt;p&gt;この本は次の各章から構成される。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;はじめに&lt;/li&gt;
&lt;li&gt;文化&lt;/li&gt;
&lt;li&gt;戦略&lt;/li&gt;
&lt;li&gt;人材&lt;/li&gt;
&lt;li&gt;意思決定&lt;/li&gt;
&lt;li&gt;コミュニケーション&lt;/li&gt;
&lt;li&gt;イノベーション&lt;/li&gt;
&lt;li&gt;おわりに&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;文化や人材、イノベーションといった様々な分野からGoogleという企業について語られる。
非常に学びどころの多い本であったが、ひとつ大事なキーワードを挙げるとすれば、
「スマート・クリエイティブ」だろう。&lt;/p&gt;

&lt;p&gt;1998年にGoogleを創業した当時、ラリーとセルゲイは経営の知識もなければ経験もなかった。
「ユーザーを中心に考えること」を重要視し、最高のサービスを生み出せばお金は後からついてくると信じていた。
成功し壮大な野望を成し遂げるためにはとびきり優秀なエンジニアを惹きつけ、引っ張っていくしかないと感じていた。&lt;/p&gt;

&lt;p&gt;実際業務プロセスも適当で、壮大な志を遂げられるような会社を作る戦術はなかったのだ。
ただ一つはっきりしていた経営戦術は、「私たちが20世紀に学んだことのほとんどは間違っており、それを根本から見直すべき時期がきている。」ということだけだった。&lt;/p&gt;

&lt;p&gt;技術成長に伴う時代の変化の結果、いまや企業の成功に最も重要な要素はプロダクトの優位性になった。
アマゾン創業者兼CEOのジェフ・ベゾスも次のように述べている。&lt;br /&gt;
「古い世界では持てる時間の30%を優れたプロダクトの開発に、70%をそれがどれほど素晴らしいプロダクトか吹聴してまわるのに充てていた。それが新たな世界では逆転した」&lt;/p&gt;

&lt;p&gt;また優位性が重要視されるようになるのに伴い、新たな試みをし失敗するコストが大幅に低下した。
プロダクト開発はより柔軟でスピードが求められるプロセスになった。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;スマート-クリエイティブ:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;スマート・クリエイティブ&lt;/h3&gt;

&lt;p&gt;実験のコストや失敗のコストは大幅に低下し、希少だったデータやPCも簡単に手に入るようになった。
そして、突如して「ひとり」のプレイヤー、マネージャー、経営者がとほうもないインパクトを生み出せるようになった。&lt;/p&gt;

&lt;p&gt;こんにち成功している企業の際立った特色は、最高のプロダクトを生み出し続ける能力だ。
それを手に入れる唯一の道は、スマートクリエイティブを惹きつけ、彼らが偉業を成し遂げられるような環境を作り出すことだ。&lt;/p&gt;

&lt;p&gt;スマート・クリエイティブはどのような人間か。
彼らは自分の”商売道具”を使いこなすための高度な専門知識を持っており経験値も高い。分析力とビジネス感覚にも優れており、競争心も好奇心も旺盛だ。
ユーザーのこともよく分かっている。リスクをいとわない。自発的である。あらゆる可能性にオープンであり、コミュニケーション能力も高い。
すべてのスマート・クリエイティブがこうした特徴を全て備えているわけではなくむしろ稀である。&lt;/p&gt;

&lt;p&gt;共通して持っているものは「努力をいとわず、これまでの常識的方法に疑問を持ち、新しいやり方を試すことに積極的であること」だ。
これがスマート・クリエイティブが大きな影響を持ちうる理由である。&lt;/p&gt;

&lt;p&gt;2003年ごろのGoogleが課題にしていたことは、こうしたスマート・クリエイティブな社員たちが真価を発揮できるような新たな労働環境を生み出し、維持することだった。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;文化:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;文化&lt;/h3&gt;

&lt;p&gt;企業を立ち上げるときに、最初にどんな文化を作りたいか考え、明確にしておくほうが懸命だ。
文化を生み出すのは創業者だが、それを最もよく反映するのは、会社を立ち上げる時に集まった、創業者が信頼を置くチームである。
「ぼくらにとって大切なことは何か」「信念は何か」「どんな存在になりたいのか」「会社の行動や意思決定の方法はどうあるべきか」
成功する会社とそうでない会社の違いは、従業員がこうした文言を信じているかどうかにある。&lt;/p&gt;

&lt;p&gt;PMについて良い文章があったので引用する。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;インタ-ネット世紀のプロダクトマネジャーの役割は、最高のプロダクトの設計、エンジニアリング、開発を担う人々とともに働くことだ。
そのなかには、プロダクトのライフサイクルを管理し、プロダクトのロードマップを決定し、消費者の声を代弁し、そうした事柄をチームや経営陣に伝えるといった従来型の管理業務も含まれる。だが、スマート・クリエイティブ型のプロダクト・マネジャーに何より求められるのは、プロダクトをさらに良くするための技術的ヒントを見つけることだ。それは消費者のプロダクトの使い方(そして技術の進歩とともにそのパターンがどのように変化するか)を把握すること、データの理解や分析、技術のトレンドやそれが業界に及ぼす影響を見きわめることによって得られる。そのためにプロダクト・マネジャーはチームのエンジニア(あるいは化学者、生物学者、デザイナーなど、プロダクトの設計や開発のために採用されたスマート・クリエイティブ)と仕事も食事も生活もともにする必要がある。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;能力主義を浸透させるには:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 能力主義を浸透させるには&lt;/h5&gt;

&lt;p&gt;能力主義を浸透させるには、「異議を唱える義務」を重視する文化が必要。ある考え方に問題があると思った人は、懸念を表明しなければならない。そうしなければ最高とはいえない考え方が通り、懸念を口にしなかったものも共同責任を負うことになる。&lt;/p&gt;

&lt;h5 id=&#34;優れた仕事は楽しくなければならない:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 優れた仕事は楽しくなければならない&lt;/h5&gt;

&lt;p&gt;あなたが死ぬほど働いているのに、ちっとも楽しくないという場合、おそらく何か間違っている。
楽しい理由の一つは、将来の成功の予感かもしれない。だが、一番大きいのは、同僚と一緒に笑ったり、ジョークを言い合ったり、ともに仕事をする楽しさのはずだ。&lt;/p&gt;

&lt;h5 id=&#34;戦略会議:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 戦略会議&lt;/h5&gt;

&lt;p&gt;正しい先着にはある種の美しさがある、多くの人やアイディアが成功のためにひとつになっている感覚。
まずは「5年後はどうなっているか」と尋ねるところから始めよう。
自身が挑戦者である場合、アイディアを軸にプロダクトを開発し、事業を構築しなければならない。
成功している大企業は例外なく次の点から出発している。&lt;/p&gt;

&lt;p&gt;① 問題をまったく新しい方法で解決する&lt;br /&gt;
② その方法を活かして急速に成長・拡大する&lt;br /&gt;
③ 成功の最大の要因はプロダクトである&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;人材:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;人材&lt;/h3&gt;

&lt;h5 id=&#34;ラーニングアニマルを採用する:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ ラーニングアニマルを採用する&lt;/h5&gt;

&lt;p&gt;ヘンリー・フォードは「人は学習を辞めたとき老いる。20歳の老人もいれば、80歳の若者もいる。学びつづける者は若さを失わない。人生で何よりすばらしいのは、自分の心の若さを保つことだ」と言った。
自分の能力は変わらないと考えていると、その自己イメージを維持するために「到達目標」を設定する。一方で人は変われる、適応できると考えている人は「学習目標」を設定する。&lt;/p&gt;

&lt;h5 id=&#34;laxテスト:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ LAXテスト&lt;/h5&gt;

&lt;p&gt;Googleでは「LAXテスト（LAX＝ロサンゼルス国際空港で6時間足止めをくらったとして、それでも一緒にいたいと思う人材かどうかで判断すること）」を採用している。
採用候補者に欠かせない資質として、情熱、知力、ラーニングアニマルのマインドセットを述べた。
もう一つの重要な要素が人格。
単に親切で信頼感があるかというだけでなく、多才で、世界と深く関わっている人間、つまり「おもしろい」人間。&lt;/p&gt;

&lt;h5 id=&#34;google-採用のおきて:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ Google「採用のおきて」&lt;/h5&gt;

&lt;p&gt;Googleの採用のおきてを引用する。
採用だけでなく、自分の仕事ぶりを振り返るいい指標にもなる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自分より優秀で博識な人物を採用せよ。学ぶもののない、あるいは手強いと感じない人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;プロダクトと企業文化に付加価値をもたらしそうな人物を採用せよ。問題について考えるだけの人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;仕事を成し遂げる人物を採用せよ。仕事がほしいだけの人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;熱意があり、自発的で、情熱的な人物を採用せよ。仕事がほしいだけの人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;周囲に刺激を与え、協力できる人物を採用せよ。ひとりで仕事をしたがる人物を採用してはならない。&lt;/li&gt;
&lt;li&gt;チームや会社とともに成長しそうな人物を採用せよ。スキルセットや興味の幅が狭い人間は採用してはならない。&lt;/li&gt;
&lt;li&gt;多才で、ユニークな興味や才能を持っている人物を採用せよ。仕事しか能がない人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;倫理観があり、素直に意思を伝える人物を採用せよ。駆け引きをシたり、他人を操ろうとする人物は採用してはならない。&lt;/li&gt;
&lt;li&gt;最高の候補者を見つけた場合のみ採用せよ。一切の妥協は許されない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;キャリア計画:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ キャリア計画&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;トム・レーラー「人生は下水管のようなものだ。何が出てくるかは、何を入れるかで決まる。」&lt;/li&gt;
&lt;li&gt;ヨギ・ベラ「目的地がどこかわからないときは、注意したほうがいい。おそらくそこには辿り着けないから」&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;意思決定:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;意思決定&lt;/h3&gt;

&lt;h5 id=&#34;正しい意思決定:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 正しい意思決定&lt;/h5&gt;

&lt;p&gt;正しい選択をすることだけに集中してはいけない。判断に到達するプロセス、タイミング、判断を実行に移す方法も、判断の内容そのものと同じくらいに重要。
どれか一つでも欠ければまずい結果になりかねない。意思決定すべき事柄は次々と出てくるので、そのプロセスに問題があると弊害はとめどなく広がっていく。&lt;/p&gt;

&lt;h5 id=&#34;行動志向:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 行動志向&lt;/h5&gt;

&lt;p&gt;「とにかく、”何か”行動を起こすんだ。間違っていたっていい」&lt;br /&gt;
トム・ピーターズはこのような考え方を「行動志向」と呼んだ。
「デザイン的思考の中核的マインドセット」である。
行動志向は、実践的で試行錯誤をいとわない考え方である。
ある行動をとることが正しいか確信が持てないなら、一番いいのは実際にやってみて軌道修正することだ。&lt;/p&gt;

&lt;h5 id=&#34;すべての会議には-オーナー-が必要:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ すべての会議には&amp;rdquo;オーナー&amp;rdquo;が必要。&lt;/h5&gt;

&lt;p&gt;意思決定の舞台はたいてい会議。エリックの作り上げた会議のルール。&lt;/p&gt;

&lt;p&gt;会議には単一の意思決定者、すなわち&amp;rdquo;オーナー&amp;rdquo;を置く。意思決定に責任を持つ人物である。
そしてその意思決定者は自ら動くこと。会議の目的が意思決定でない場合でも(情報共有やブレストでも)必ずオーナーを決めること。
参加者の顔ぶれが適切であること、議題が明確であること。必要な準備がきちんとなされていること。こういったことに責任を持つ。
会議は簡単に廃止できるようにする。運営しやすい規模に留める。時間管理は重要。締めくくりには結論と行動計画をおさらいする。
会議に出るのならまじめにでること。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;イノベーション:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;イノベーション&lt;/h3&gt;

&lt;h5 id=&#34;新しいプロジェクトに取り組むか決める時:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 新しいプロジェクトに取り組むか決める時&lt;/h5&gt;

&lt;p&gt;Googleチームではベン図を使う。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数百万人、数十億人に影響をおよぼすような大きな問題あるいはチャンスか&lt;/li&gt;
&lt;li&gt;すでに市場に存在するものとは根本的に異なる解決策のアイディアはあるか&lt;/li&gt;
&lt;li&gt;根本的に異なる解決策を世に送り出すための画期的な技術は存在しているのか&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;イノベーションを生む環境:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ イノベーションを生む環境&lt;/h5&gt;

&lt;p&gt;イノベーションがうまれるにはふさわしい環境が必要。
たいてい急速に成長しており、たくさんの競合がひしめく市場。
からっぽの市場にひとりぼっち、というのは避けること。
イノベーションに取り組む舞台には、大きなあるいは今後大きくなりそうな市場を選ぶべき。
未開の地を夢見てしまう起業家は多い。&lt;/p&gt;

&lt;h5 id=&#34;世に出てから手直しする:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 世に出てから手直しする&lt;/h5&gt;

&lt;p&gt;新しいアイディアが初めから完璧であることはありえない。完璧になるまで待っている時間はない。
プロダクトを作り、出荷し、市場の反応を見てから、改善策を考え実践し、再び出荷する。
勝つのはこのプロセスを最も速く繰り返すことにできる企業。&lt;/p&gt;

&lt;h5 id=&#34;良い失敗をする:c8c2508cddce353cb3ee152cf74b8410&#34;&gt;◯ 良い失敗をする&lt;/h5&gt;

&lt;p&gt;イノベーションを生み出すには、良い失敗のしかたを身につけなければならない。
失敗から学ぶのだ。どんな失敗プロジェクトからも、次の試みに役に立つような技術、ユーザー、市場への理解が得られるはず。&lt;/p&gt;

&lt;p&gt;経営者の仕事はリスクを最小限に抑えたり、失敗を防ぐことではない。
リスクを取り、避けられない失敗に耐えうる組織をつくること。&lt;/p&gt;

&lt;p&gt;おそらく、最も難しいのは失敗のタイミングを見極めること。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Googleという企業の取り組んできたさまざまなプロジェクトや、乗り越えてきたたくさんの困難を通して
多くの実践的な考えを学びながらGoogleという企業について知ることができた。良書。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【FullCalendar】General Display</title>
      <link>http://kotazi.github.io/blog/post/2016/0123_calendar/</link>
      <pubDate>Sat, 23 Jan 2016 22:53:46 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0123_calendar/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fullcalendar.io/docs/display/&#34;&gt;General Display&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h5 id=&#34;header-http-fullcalendar-io-docs-display-header:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/header/&#34;&gt;header&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;カレンダー上部のボタンとタイトルを定義します。&lt;/p&gt;

&lt;h5 id=&#34;custombuttons-http-fullcalendar-io-docs-display-custombuttons:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/customButtons&#34;&gt;customButtons&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;ヘッダーで使用されるカスタムボタンを定義します。&lt;/p&gt;

&lt;h5 id=&#34;buttonicons-http-fullcalendar-io-docs-display-buttonicons:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/buttonIcons&#34;&gt;buttonIcons&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;ヘッダーボタンで表示するアイコンを決めます。&lt;/p&gt;

&lt;h5 id=&#34;theme-http-fullcalendar-io-docs-display-theme:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/theme&#34;&gt;theme&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;jQuery UIテーマの使用不使用です。&lt;/p&gt;

&lt;h5 id=&#34;themebuttonicons-http-fullcalendar-io-docs-display-themebuttonicons:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/themeButtonIcons&#34;&gt;themeButtonIcons&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;テーマで使用するアイコンを決定します。&lt;/p&gt;

&lt;h5 id=&#34;firstday-http-fullcalendar-io-docs-display-firstday:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/firstDay&#34;&gt;firstDay&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;週始めを決めます。&lt;/p&gt;

&lt;h5 id=&#34;isrtl-http-fullcalendar-io-docs-display:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/&#34;&gt;isRTL&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;カレンダーの表示向きです。&lt;/p&gt;

&lt;h5 id=&#34;weekends-http-fullcalendar-io-docs-display-weekends:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/weekends&#34;&gt;weekends&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;カレンダーのビューに土日を含めるかどうかです。&lt;/p&gt;

&lt;h5 id=&#34;hiddendays-http-fullcalendar-io-docs-display-hiddendays:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/hiddenDays&#34;&gt;hiddenDays&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;決まった曜日を非表示にすることができます。&lt;/p&gt;

&lt;h5 id=&#34;fixedweekcount-http-fullcalendar-io-docs-display-fixedweekcount:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/fixedWeekCount&#34;&gt;fixedWeekCount&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;デフォルトは&lt;code&gt;true&lt;/code&gt;.必ず6週です。
&lt;code&gt;false&lt;/code&gt;の場合は4や5週の場合があります。&lt;/p&gt;

&lt;h5 id=&#34;weeknumbers-http-fullcalendar-io-docs-display-weeknumbers:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/weekNumbers&#34;&gt;weekNumbers&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;週番号を表示するかです。&lt;code&gt;true&lt;/code&gt;にすると左側に入ります。&lt;/p&gt;

&lt;h5 id=&#34;weeknumbercalculation-http-fullcalendar-io-docs-display:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/&#34;&gt;weekNumberCalculation&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;weekNumbersの設定に合わせて週の数を計算します。&lt;/p&gt;

&lt;h5 id=&#34;businesshours-http-fullcalendar-io-docs-display-businesshours:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/businessHours&#34;&gt;businessHours&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;ビジネスタイムの設定。&lt;/p&gt;

&lt;h5 id=&#34;height-http-fullcalendar-io-docs-display-height:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/height&#34;&gt;height&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;カレンダーの高さを指定します。&lt;/p&gt;

&lt;h5 id=&#34;aspectratio-http-fullcalendar-io-docs-display-aspectratio:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/aspectRatio&#34;&gt;aspectRatio&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;縦横のアスペクト比を決定します。&lt;/p&gt;

&lt;h5 id=&#34;handlewindowresize-http-fullcalendar-io-docs-display-handlewindowresize:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/handleWindowResize&#34;&gt;handleWindowResize&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;ブラウザがリサイズされた時に、カレンダーをリサイズします。&lt;/p&gt;

&lt;h5 id=&#34;eventlimit-http-fullcalendar-io-docs-display-eventlimit:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/eventLimit&#34;&gt;eventLimit&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;一日に表示するイベントの数の上限。&lt;/p&gt;

&lt;h5 id=&#34;eventlimitclick-http-fullcalendar-io-docs-display-eventlimitclick:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/eventLimitClick&#34;&gt;eventLimitClick&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;eventLimitで設定した上限を超え、&lt;code&gt;more&lt;/code&gt;をクリックした時のアクション。&lt;/p&gt;

&lt;h5 id=&#34;viewrender-callback-http-fullcalendar-io-docs-display-viewrender:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/viewRender&#34;&gt;viewRender (callback)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;レンダリング後のコールバック&lt;/p&gt;

&lt;h5 id=&#34;viewdestroy-callback-http-fullcalendar-io-docs-display-viewdestroy:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/viewDestroy&#34;&gt;viewDestroy (callback)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;データ破壊後のコールバック&lt;/p&gt;

&lt;h5 id=&#34;dayrender-callback-http-fullcalendar-io-docs-display-dayrender:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/dayRender&#34;&gt;dayRender (callback)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;セルを修正した時のコールバック&lt;/p&gt;

&lt;h5 id=&#34;windowresize-callback-http-fullcalendar-io-docs-display-windowresize:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/windowResize&#34;&gt;windowResize (callback)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;リサイズ時のコールバック&lt;/p&gt;

&lt;h5 id=&#34;render-method-http-fullcalendar-io-docs-display-render:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/render&#34;&gt;render (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;レンダリングメソッド。&lt;/p&gt;

&lt;h5 id=&#34;destroy-method-http-fullcalendar-io-docs-display-destroy:9292537d398d35e2714a7e18b5b2d7a6&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/display/destroy&#34;&gt;destroy (method)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;要素を取り除く。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【FullCalendar】Google Calendar</title>
      <link>http://kotazi.github.io/blog/post/2016/0122_calendar/</link>
      <pubDate>Fri, 22 Jan 2016 22:53:46 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0122_calendar/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://fullcalendar.io/&#34;&gt;FullCalendar&lt;/a&gt;のGoogleCalendar同期について。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fullcalendar.io/docs/google_calendar/&#34;&gt;Google Calendar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;google-calendar:d1c1dad631980de0087d81fc9c503c32&#34;&gt;Google Calendar&lt;/h3&gt;

&lt;p&gt;FullCalendarではGoogle Calendarのイベントを表示することができます。
GoogleCalendarはバックエンド側で管理・保持しているイベントデータを提供することができます。
(FullCalendarにはない機能)&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;before-you-code:d1c1dad631980de0087d81fc9c503c32&#34;&gt;Before you code&amp;hellip;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;GoogleCalendarのAPIキーが必要です&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://console.developers.google.com/&#34;&gt;Google Developer Console&lt;/a&gt;から新しいプロジェクトを作成してください&lt;/li&gt;
&lt;li&gt;そのプロジェクトのサイドバーから、「APIs &amp;amp; auth &amp;gt; APIs」と移動します&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Calendar API&amp;rdquo;をオンにしてください。&lt;/li&gt;
&lt;li&gt;サイドバーから「APIs &amp;amp; auth &amp;gt; Credentials」と移動します&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Public API access&amp;rdquo;セクション内の&amp;rdquo;Create new Key&amp;rdquo;をクリックします&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Browser Key&amp;rdquo;を選択します&lt;/li&gt;
&lt;li&gt;カレンダーをホストするドメインが分かれば入力してください。いつでも変更できるので分からなければそのままで大丈夫です&lt;/li&gt;
&lt;li&gt;新しいAPIキーが現れます。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;p&gt;&lt;strong&gt;Googleを公開する&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;GoogleCalendarのインターフェイスで、左側にある&amp;rdquo;My calendars&amp;rdquo;へ&lt;/li&gt;
&lt;li&gt;カレンダーにカーソルを当て、矢印をクリックします&lt;/li&gt;
&lt;li&gt;メニューが表示されるので&amp;rdquo;Share this Calendar&amp;rdquo;をクリックします&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Make this calendar public&amp;rdquo;にチェックします&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Share only my free/busy information&amp;rdquo;にチェックが入っていないことを確認してください&lt;/li&gt;
&lt;li&gt;保存します&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;p&gt;&lt;strong&gt;GoogleCalendarのIDを取得する&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;GoogleCalendarのインターフェイスで、左側にある&amp;rdquo;My calendars&amp;rdquo;へ&lt;/li&gt;
&lt;li&gt;カレンダーにカーソルを当て、矢印をクリックします&lt;/li&gt;
&lt;li&gt;メニューが表示されるので&amp;rdquo;Calendar settings&amp;rdquo;をクリックします&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Calendar Address&amp;rdquo;セクションのCalendarIDを見てください。 &amp;ldquo;abcd1234@group.calendar.google.com&amp;rdquo;のようなものです。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;h3 id=&#34;dependencies:d1c1dad631980de0087d81fc9c503c32&#34;&gt;Dependencies&lt;/h3&gt;

&lt;p&gt;続いて、必要なJS/CSSを追加します。標準的なファイルに加え、&lt;code&gt;gcal.js&lt;/code&gt;も追加します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&#39;text/javascript&#39; src=&#39;fullcalendar/gcal.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;writing-the-code:d1c1dad631980de0087d81fc9c503c32&#34;&gt;Writing the code&lt;/h3&gt;

&lt;p&gt;JSでカレンダーを初期化する準備が整いました。これが最小のサンプルになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&#39;text/javascript&#39;&amp;gt;

$(document).ready(function() {
    $(&#39;#calendar&#39;).fullCalendar({
        googleCalendarApiKey: &#39;&amp;lt;YOUR API KEY&amp;gt;&#39;,
        events: {
            googleCalendarId: &#39;abcd1234@group.calendar.google.com&#39;
        }
    });
});

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特定の&lt;a href=&#34;http://fullcalendar.io/docs/event_data/Event_Source_Object/&#34;&gt;Event Source&lt;/a&gt;オプションを追加したければ、&lt;code&gt;events&lt;/code&gt;オブジェクトに含めることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&#39;text/javascript&#39;&amp;gt;

$(document).ready(function() {
    $(&#39;#calendar&#39;).fullCalendar({
        googleCalendarApiKey: &#39;&amp;lt;YOUR API KEY&amp;gt;&#39;,
        events: {
            googleCalendarId: &#39;abcd1234@group.calendar.google.com&#39;,
            className: &#39;gcal-event&#39; // an option!
        }
    });
});

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;timezones:d1c1dad631980de0087d81fc9c503c32&#34;&gt;Timezones&lt;/h3&gt;

&lt;p&gt;GoogleCalendarのプラグインでは&lt;a href=&#34;http://fullcalendar.io/docs/timezone/timezone/&#34;&gt;timezone&lt;/a&gt;をリスペクトしています。
&lt;code&gt;false&lt;/code&gt;(デフォルト)にしておくと、GoogleCalendarのタイムゾーン設定が使用されます。特定のものを指定していれば、これらは無視されます。&lt;/p&gt;

&lt;Hr&gt;

&lt;h3 id=&#34;multiple-google-calendars:d1c1dad631980de0087d81fc9c503c32&#34;&gt;Multiple Google Calendars&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;eventSources&lt;/code&gt;オプションを利用すれば複数のGoogleCalendarを利用することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&#39;text/javascript&#39;&amp;gt;

$(document).ready(function() {
    $(&#39;#calendar&#39;).fullCalendar({
        googleCalendarApiKey: &#39;&amp;lt;YOUR API KEY&amp;gt;&#39;,
        eventSources: [
            {
                googleCalendarId: &#39;abcd1234@group.calendar.google.com&#39;
            },
            {
                googleCalendarId: &#39;efgh5678@group.calendar.google.com&#39;,
                className: &#39;nice-event&#39;
            }
        ]
    });
});

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;Hr&gt;

&lt;h3 id=&#34;advanced:d1c1dad631980de0087d81fc9c503c32&#34;&gt;Advanced&lt;/h3&gt;

&lt;p&gt;カレンダーごとに異なるAPIキーを利用する場合、&lt;code&gt;googleCalendarApiKey&lt;/code&gt;をセットするには個々の[EventSource]を用います。&lt;/p&gt;

&lt;p&gt;GoogleAPIのエラーを検知する必要がある場合、jQueryのAJAZエラーハンドリングには方法がありません。FullCalendarの&lt;code&gt;googleCalendarError&lt;/code&gt;を使います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【FullCalendar】Basic Usage</title>
      <link>http://kotazi.github.io/blog/post/2016/0121_calendar/</link>
      <pubDate>Thu, 21 Jan 2016 22:53:46 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0121_calendar/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://fullcalendar.io/&#34;&gt;FullCalendar&lt;/a&gt;の基本的な使い方です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fullcalendar.io/docs/usage/&#34;&gt;Basic Usage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h3 id=&#34;basic-usage:618077e916e5f8ed5fedc9c7378a801b&#34;&gt;Basic Usage&lt;/h3&gt;

&lt;p&gt;Webページにカレンダーを組み込む最初のステップは、正しいJSとCSSファイルを用意することです。
FullCalendarのスタイルシート、FullCalendar、jQuery、Momentファイルを&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;に含めたことを確認してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&#39;stylesheet&#39; href=&#39;fullcalendar/fullcalendar.css&#39; /&amp;gt;
&amp;lt;script src=&#39;lib/jquery.min.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&#39;lib/moment.min.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&#39;fullcalendar/fullcalendar.js&#39;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQueryとMomentは必ずFullCalendarのJSファイルより先に読み込んでください。&lt;/p&gt;

&lt;p&gt;もしドラッグやリサイズをするのであれば、追加する必要のあるライブラリがあるかもしれないので、&lt;a href=&#34;http://fullcalendar.io/docs/event_ui/Requirements/&#34;&gt;こちら&lt;/a&gt;を見てください。&lt;/p&gt;

&lt;p&gt;依存関係を書き終えたら、カレンダーを初期化するためのスクリプトを記述します。
このコードはページの初期化後に実行される必要があります。最も良い方法はjQueryの&lt;code&gt;$(document).ready&lt;/code&gt;あたりを使うことです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {

    // page is now ready, initialize the calendar...

    $(&#39;#calendar&#39;).fullCalendar({
        // put your options and callbacks here
    })

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記のコードは&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;タグで囲んでください。
ページ内のID&lt;code&gt;calendar&lt;/code&gt;要素の中にカレンダーを生成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&#39;calendar&#39;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで空っぽの月カレンダーが表示されると思います。
イベントの表示方法について学ぶには&lt;a href=&#34;http://fullcalendar.io/docs/google_calendar/&#34;&gt;Google Calendar&lt;/a&gt;もしくは&lt;a href=&#34;http://fullcalendar.io/docs/event_data/&#34;&gt;Event Data&lt;/a&gt;のセクションを参考にしてください。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;options:618077e916e5f8ed5fedc9c7378a801b&#34;&gt;Options&lt;/h3&gt;

&lt;p&gt;FullCalendarのドキュメントの大半は、オプションの影響や振る舞いについてです。
オプションはこのように、たいていカレンダーの初期化時にセットされます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;#calendar&#39;).fullCalendar({
    weekends: false // will hide Saturdays and Sundays
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;callbacks:618077e916e5f8ed5fedc9c7378a801b&#34;&gt;Callbacks&lt;/h3&gt;

&lt;p&gt;コールバックはオプションのように並べられますが、これらの関数は特別なことが起こらなければ呼ばれません。
下記のサンプルでは、ユーザーが日にちをクリックするとアラートが表示されるものです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;#calendar&#39;).fullCalendar({
    dayClick: function() {
        alert(&#39;a day has been clicked!&#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;

&lt;h3 id=&#34;methods:618077e916e5f8ed5fedc9c7378a801b&#34;&gt;Methods&lt;/h3&gt;

&lt;p&gt;メソッドは様々な方法を提供します。
メソッドは既に初期化されたカレンダーのjQueryオブジェクトに対し、&lt;code&gt;fullCalendar&lt;/code&gt;コマンドを買います。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;#calendar&#39;).fullCalendar(&#39;next&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは&lt;code&gt;next&lt;/code&gt;メソッドです。カレンダーを次に進めるためのメソッドです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【読書】強いチームはオフィスを捨てる</title>
      <link>http://kotazi.github.io/blog/post/2016/0119_37signals/</link>
      <pubDate>Tue, 19 Jan 2016 22:53:46 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0119_37signals/</guid>
      <description>

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/4152094338/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=247&amp;creative=1211&amp;creativeASIN=4152094338&amp;linkCode=as2&amp;tag=kotazi-22&#34;&gt;強いチームはオフィスを捨てる: 37シグナルズが考える「働き方革命」&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=kotazi-22&amp;l=as2&amp;o=9&amp;a=4152094338&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;を読みました。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;本書は37signalsのCEO、ジェイソン・フリードに書かれた本である。
37signalsは1999年にシカゴに設立されたウェブアプリケーションの会社である。
プロジェクト管理ツール「Basecamp」や、Ruby用のフレームワークである「Runy on Rails」を開発した会社として有名。&lt;/p&gt;

&lt;p&gt;この本は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;はじめに&lt;/li&gt;
&lt;li&gt;イントロダクション: オフィスのない世界&lt;/li&gt;
&lt;li&gt;リモートワークの時代がやってきた&lt;/li&gt;
&lt;li&gt;リモートワークの誤解を解く&lt;/li&gt;
&lt;li&gt;リモートのコラボレーション術&lt;/li&gt;
&lt;li&gt;リモートワークの落とし穴&lt;/li&gt;
&lt;li&gt;リモート時代の人材採用&lt;/li&gt;
&lt;li&gt;リモート時代のマネジメント&lt;/li&gt;
&lt;li&gt;リモートワーカーの仕事スタイル&lt;/li&gt;
&lt;li&gt;おわりに&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;といった各章から成る。
小題は2ページ程度で挿絵も入っていて読みやすい。&lt;/p&gt;

&lt;p&gt;本書はリモートワークに対する考え方をアップデートするために書かれた本だ。&lt;/p&gt;

&lt;p&gt;技術は既に揃った。
世界中の人といつでも簡単にコミュニケーションが取れ、
一緒に作業を進められるツールがいくらでもある。&lt;/p&gt;

&lt;p&gt;オフィスに集まって働くという固定概念をくつがえし、新しい働き方を提唱する本だ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;往復2時間の通勤時間が無駄。それだけで疲弊する。&lt;/li&gt;
&lt;li&gt;本気で日中のオフィスが働きやすいと思っているのか？&lt;/li&gt;
&lt;li&gt;もっとも自分の集中力の高まる時間に働くべき。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ざっくりまとめると従来のオフィスでの働き方を上記の理由から否定する。　
リモートワークであればこれらに縛られることなく好きな時に好きな場所で働くことができる。&lt;/p&gt;

&lt;p&gt;実際にリモートワークを取り入れている会社もたくさんある。&lt;/p&gt;

&lt;h5 id=&#34;従業員数1万人以上:5370d8405ec555469de54826754668f4&#34;&gt;◯ 従業員数1万人以上&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;AT&amp;amp;T(通信)&lt;/li&gt;
&lt;li&gt;ユナイテッドヘルス・グループ(医療)&lt;/li&gt;
&lt;li&gt;マッキンゼー・アンド・カンパニー(コンサルティング)&lt;/li&gt;
&lt;li&gt;インテル(IT)&lt;/li&gt;
&lt;li&gt;SCジョンソン(メーカー)&lt;/li&gt;
&lt;li&gt;エトナ(保険)&lt;/li&gt;
&lt;li&gt;シスコ(IT)&lt;/li&gt;
&lt;li&gt;デロイト(会計)&lt;/li&gt;
&lt;li&gt;HSBC UK(金融)&lt;/li&gt;
&lt;li&gt;ブリティッシュ・テレコム(通信)&lt;/li&gt;
&lt;li&gt;ユニリーバ(消費財)&lt;/li&gt;
&lt;li&gt;エクスプレス・スクリプツ(薬剤給付管理)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;従業員数1000-1万人:5370d8405ec555469de54826754668f4&#34;&gt;◯ 従業員数1000〜1万人&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;メルセデス・ベンツUSA(自動車)&lt;/li&gt;
&lt;li&gt;ティーチ・フォー・アメリカ(教育)&lt;/li&gt;
&lt;li&gt;プランテ・モラン(会計・コンサルティング)&lt;/li&gt;
&lt;li&gt;ドリームワークス・アニメーションSKG(アニメ制作)&lt;/li&gt;
&lt;li&gt;パーキンス・クーイ(法律)&lt;/li&gt;
&lt;li&gt;アメリカン・フィデリティ・アシュアランス(保険)&lt;/li&gt;
&lt;li&gt;米国教育省(行政)&lt;/li&gt;
&lt;li&gt;ヴァージン・アトランティック(航空)&lt;/li&gt;
&lt;li&gt;ブロケード・コミュニケーションズ・システムズ(IT)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h5 id=&#34;従業員数1000人以下:5370d8405ec555469de54826754668f4&#34;&gt;◯ 従業員数1000人以下&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;GitHub(ソフトウェア)&lt;/li&gt;
&lt;li&gt;ライアン(税務)&lt;/li&gt;
&lt;li&gt;オートマティック(ウェブ開発)&lt;/li&gt;
&lt;li&gt;MWW(広報・PR)&lt;/li&gt;
&lt;li&gt;コニー(モバイルアプリケーション)&lt;/li&gt;
&lt;li&gt;テキストマスター(翻訳・コピーライティング)&lt;/li&gt;
&lt;li&gt;BeBanjo(オンデマンド配信)&lt;/li&gt;
&lt;li&gt;ブライトボックス(クラウドホスティング)&lt;/li&gt;
&lt;li&gt;HE:labs(ウェブ開発)&lt;/li&gt;
&lt;li&gt;フォトリア(画像素材)&lt;/li&gt;
&lt;li&gt;フリーエージェント(経理ソフト)&lt;/li&gt;
&lt;li&gt;プルーフ・ブランディング(ブランディングデザイン)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;実際弊社でもリモートワークは取り入れているし、個人的にもその魅力を強く感じている。
特に体制を整えれば世界のどこからでも優秀な人間を採用し、一緒に働ける点は大きい。&lt;/p&gt;

&lt;p&gt;けれども実際、別の課題が出てくる。
その点についてまとめたのが「リモートのコラボレーション術」である。&lt;/p&gt;

&lt;h5 id=&#34;コアタイムを決める:5370d8405ec555469de54826754668f4&#34;&gt;◯ コアタイムを決める&lt;/h5&gt;

&lt;p&gt;共通のコアタイムを決める。毎日4時間は一緒に働けるといい。
コミュニケーションもうまくいくし、チームの一体感が出てくる。&lt;/p&gt;

&lt;p&gt;また個人的には、見えない相手が確実に捕まる時間をこちらで把握できていることが非常に大きいと感じる。&lt;/p&gt;

&lt;h5 id=&#34;同じ画面を見る:5370d8405ec555469de54826754668f4&#34;&gt;◯ 同じ画面を見る&lt;/h5&gt;

&lt;p&gt;互いの顔を見るのではなく、画面共有を使うということ。
フォーカスを仕事に当てる。&lt;/p&gt;

&lt;h5 id=&#34;情報を閉じ込めてはいけない:5370d8405ec555469de54826754668f4&#34;&gt;◯ 情報を閉じ込めてはいけない&lt;/h5&gt;

&lt;p&gt;同じオフィスで働くと些細な確認や質問が飛び交う。
これは相手の集中力を途切れさせる良くない習慣であるが、
このあたりの仕組みを整えないままリモートワークをすると困ってしまうことが多い。&lt;/p&gt;

&lt;p&gt;必要な資料や情報がいつでもみんなの手の届くところに来るようにしておくことが大切&lt;/p&gt;

&lt;h5 id=&#34;バーチャルな雑談場を作る:5370d8405ec555469de54826754668f4&#34;&gt;◯ バーチャルな雑談場を作る&lt;/h5&gt;

&lt;p&gt;チームが雑談できる場所を作る。
オフィスにいない分、小さなコミュニケーションが生まれなかったり、
しばらく一緒に働いていても相手のことをよく知れなかったりすることがある。&lt;/p&gt;

&lt;p&gt;リモートワークで働く場合はこういった文化は積極的に取り組むべき。&lt;/p&gt;

&lt;h5 id=&#34;進み具体を共有する:5370d8405ec555469de54826754668f4&#34;&gt;◯ 進み具体を共有する&lt;/h5&gt;

&lt;p&gt;同じオフィスで働いていると社内の情報ななんとなく耳にするものだが、
リモートワークでは周りのことがよく分からなくなってしまうことがある。&lt;/p&gt;

&lt;p&gt;定期的に自分のやっていることを報告したり、
たまには相手の仕事に興味を持ってみるのもいいかもしれない。&lt;br /&gt;
弊社でも「週報」を導入するか現在検討中。&lt;/p&gt;

&lt;h5 id=&#34;印象よりも中身を見る:5370d8405ec555469de54826754668f4&#34;&gt;◯ 印象よりも中身を見る&lt;/h5&gt;

&lt;p&gt;これはオフィスワークと一長一短。&lt;/p&gt;

&lt;p&gt;オフィスワークでは、毎日5分遅れる人、フェイスブックをいつも開いている人。
その人の仕事ぶりにかかわらず、その印象が残ってしまう。
リモートワークではそういった部分が垣間見えないものの、純粋に仕事で相手を測ることができる。&lt;/p&gt;

&lt;h5 id=&#34;まずは近くで試してみる:5370d8405ec555469de54826754668f4&#34;&gt;◯ まずは近くで試してみる&lt;/h5&gt;

&lt;p&gt;これからリモートワークを導入する人は、
いきなり遠くの人を採用しなくとも、今のメンバーで始めてみればいい。&lt;/p&gt;

&lt;h5 id=&#34;ひとつの場所に依存しない:5370d8405ec555469de54826754668f4&#34;&gt;◯ ひとつの場所に依存しない&lt;/h5&gt;

&lt;p&gt;チームがリモートワークに対応できるような柔軟なチームであれば、
例えば雪で電車が大きく遅れるようなことがあっても、みんないつも通りの仕事をこなすことができる。&lt;/p&gt;

&lt;h5 id=&#34;ミーティングを減らそう:5370d8405ec555469de54826754668f4&#34;&gt;◯ ミーティングを減らそう&lt;/h5&gt;

&lt;p&gt;リモートワークに対して懐疑的な人間はだいたい次の2点を言う。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;みんな同じ場所にいないとその場でミーティングができない&lt;/li&gt;
&lt;li&gt;その場で見張っていないと、部下が仕事しているかどうかわからない&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;5人で1時間のミーティングは5時間使っている。
ミーティングはもっと高い質でやったほうがいい。&lt;/p&gt;

&lt;p&gt;といった感じだ。&lt;/p&gt;

&lt;p&gt;他の章も面白いので是非読んで欲しい。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;読んでくれてありがとうございました。&lt;br /&gt;
せっかくなので、最近僕が面白いなあと思っているサービス「コデアル」のリンクを貼っておきます。&lt;br /&gt;
こういうサービスから新しい働き方が広がったら素晴らしいことだと思います。&lt;/p&gt;

&lt;iframe src=&#34;//dspb1oyxjua32.cloudfront.net/p?t=YOj5SQJVvS9yi0j79FoK5YHyUUu5UYSOi7t1HB0qSAU%3D&#34; frameborder=&#34;0&#34; height=&#34;230&#34; width=&#34;170&#34;&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>【FullCalendar】Agenda Options</title>
      <link>http://kotazi.github.io/blog/post/2016/0124_calendar/</link>
      <pubDate>Tue, 19 Jan 2016 22:53:46 +0900</pubDate>
      
      <guid>http://kotazi.github.io/blog/post/2016/0124_calendar/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fullcalendar.io/docs/agenda/&#34;&gt;Agenda Options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;agendaWeek&lt;/code&gt;と&lt;code&gt;agendaDay&lt;/code&gt;用のオプションです。&lt;/p&gt;

&lt;hr&gt;

&lt;h5 id=&#34;alldayslot-http-fullcalendar-io-docs-agenda-alldayslot:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/allDaySlot&#34;&gt;allDaySlot&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;&amp;ldquo;all-day&amp;rdquo;(終日)の表示をカレンダーの上部にするかどうか。&lt;/p&gt;

&lt;h5 id=&#34;alldaytext-http-fullcalendar-io-docs-agenda-alldaytext:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/allDayText&#34;&gt;allDayText&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;&amp;ldquo;all-day&amp;rdquo;に表示するテキスト。&lt;/p&gt;

&lt;h5 id=&#34;slotduration-http-fullcalendar-io-docs-agenda-slotduration:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/slotDuration&#34;&gt;slotDuration&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;枠の間隔。&lt;/p&gt;

&lt;h5 id=&#34;slotlabelformat-http-fullcalendar-io-docs-agenda-slotlabelformat:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/slotLabelFormat&#34;&gt;slotLabelFormat&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;枠の部分の表示フォーマット。&lt;/p&gt;

&lt;h5 id=&#34;slotlabelinterval-http-fullcalendar-io-docs-agenda-slotlabelinterval:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/slotLabelInterval&#34;&gt;slotLabelInterval&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;枠部分にテキストを表示する間隔を決めます。&lt;/p&gt;

&lt;h5 id=&#34;snapduration-http-fullcalendar-io-docs-agenda-snapduration:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/snapDuration&#34;&gt;snapDuration&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;イベントをドラックでずらす間隔を決めます。&lt;/p&gt;

&lt;h5 id=&#34;scrolltime-http-fullcalendar-io-docs-agenda-scrolltime:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/scrollTime&#34;&gt;scrollTime&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;スクロール枠を決めます。&lt;/p&gt;

&lt;h5 id=&#34;mintime-http-fullcalendar-io-docs-agenda-mintime:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/minTime&#34;&gt;minTime&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;表示する時間の最低枠を決めます。&lt;/p&gt;

&lt;h5 id=&#34;maxtime-http-fullcalendar-io-docs-agenda-maxtime:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/maxTime&#34;&gt;maxTime&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;表示する時間の最大枠を決めます。&lt;/p&gt;

&lt;h5 id=&#34;loteventoverlap-http-fullcalendar-io-docs-agenda-loteventoverlap:fa802ff0768f75770328542af23e0887&#34;&gt;◯ &lt;a href=&#34;http://fullcalendar.io/docs/agenda/lotEventOverlap&#34;&gt;lotEventOverlap&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;イベントの時間が重複した際の表示方法&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>